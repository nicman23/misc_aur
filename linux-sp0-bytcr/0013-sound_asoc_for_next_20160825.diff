diff -uwr linux-4.8-rc4.new/arch/arm/mach-s3c24xx/mach-mini2440.c linux-4.8-rc4.orig/arch/arm/mach-s3c24xx/mach-mini2440.c
--- linux-4.8-rc4.new/arch/arm/mach-s3c24xx/mach-mini2440.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/arch/arm/mach-s3c24xx/mach-mini2440.c	2016-09-04 01:14:32.076274608 +0000
@@ -497,9 +497,28 @@
 	},
 };
 
+static struct uda134x_platform_data s3c24xx_uda134x = {
+	.l3 = {
+		.gpio_clk = S3C2410_GPB(4),
+		.gpio_data = S3C2410_GPB(3),
+		.gpio_mode = S3C2410_GPB(2),
+		.use_gpios = 1,
+		.data_hold = 1,
+		.data_setup = 1,
+		.clock_high = 1,
+		.mode_hold = 1,
+		.mode = 1,
+		.mode_setup = 1,
+	},
+	.model = UDA134X_UDA1341,
+};
+
 static struct platform_device uda1340_codec = {
 		.name = "uda134x-codec",
 		.id = -1,
+		.dev = {
+			.platform_data	= &s3c24xx_uda134x,
+		},
 };
 
 static struct platform_device *mini2440_devices[] __initdata = {
diff -uwr linux-4.8-rc4.new/Documentation/devicetree/bindings/sound/rt5659.txt linux-4.8-rc4.orig/Documentation/devicetree/bindings/sound/rt5659.txt
--- linux-4.8-rc4.new/Documentation/devicetree/bindings/sound/rt5659.txt	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/Documentation/devicetree/bindings/sound/rt5659.txt	2016-09-04 01:14:31.924280124 +0000
@@ -12,6 +12,9 @@
 
 Optional properties:
 
+- clocks: The phandle of the master clock to the CODEC
+- clock-names: Should be "mclk"
+
 - realtek,in1-differential
 - realtek,in3-differential
 - realtek,in4-differential
diff -uwr linux-4.8-rc4.new/Documentation/devicetree/bindings/sound/sunxi,sun4i-spdif.txt linux-4.8-rc4.orig/Documentation/devicetree/bindings/sound/sunxi,sun4i-spdif.txt
--- linux-4.8-rc4.new/Documentation/devicetree/bindings/sound/sunxi,sun4i-spdif.txt	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/Documentation/devicetree/bindings/sound/sunxi,sun4i-spdif.txt	2016-09-04 01:14:41.259941300 +0000
@@ -9,6 +9,7 @@
 
   - compatible		: should be one of the following:
     - "allwinner,sun4i-a10-spdif": for the Allwinner A10 SoC
+    - "allwinner,sun6i-a31-spdif": for the Allwinner A31 SoC
 
   - reg			: Offset and length of the register set for the device.
 
@@ -25,6 +26,8 @@
 	"apb"		  clock for the spdif bus.
 	"spdif"		  clock for spdif controller.
 
+  - resets		: reset specifier for the ahb reset (A31 and newer only)
+
 Example:
 
 spdif: spdif@01c21000 {
diff -uwr linux-4.8-rc4.new/include/sound/l3.h linux-4.8-rc4.orig/include/sound/l3.h
--- linux-4.8-rc4.new/include/sound/l3.h	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/include/sound/l3.h	2016-09-04 01:14:32.032276205 +0000
@@ -2,9 +2,15 @@
 #define _L3_H_ 1
 
 struct l3_pins {
-	void (*setdat)(int);
-	void (*setclk)(int);
-	void (*setmode)(int);
+	void (*setdat)(struct l3_pins *, int);
+	void (*setclk)(struct l3_pins *, int);
+	void (*setmode)(struct l3_pins *, int);
+
+	int gpio_data;
+	int gpio_clk;
+	int gpio_mode;
+	int use_gpios;
+
 	int data_hold;
 	int data_setup;
 	int clock_high;
@@ -13,6 +19,9 @@
 	int mode_setup;
 };
 
+struct device;
+
 int l3_write(struct l3_pins *adap, u8 addr, u8 *data, int len);
+int l3_set_gpio_ops(struct device *dev, struct l3_pins *adap);
 
 #endif
diff -uwr linux-4.8-rc4.new/include/sound/s3c24xx_uda134x.h linux-4.8-rc4.orig/include/sound/s3c24xx_uda134x.h
--- linux-4.8-rc4.new/include/sound/s3c24xx_uda134x.h	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/include/sound/s3c24xx_uda134x.h	2016-09-04 01:14:32.076274608 +0000
@@ -7,7 +7,6 @@
 	int l3_clk;
 	int l3_mode;
 	int l3_data;
-	void (*power) (int);
 	int model;
 };
 
diff -uwr linux-4.8-rc4.new/include/sound/simple_card_utils.h linux-4.8-rc4.orig/include/sound/simple_card_utils.h
--- linux-4.8-rc4.new/include/sound/simple_card_utils.h	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/include/sound/simple_card_utils.h	2016-09-04 01:14:53.859484018 +0000
@@ -27,10 +27,45 @@
 				  struct device_node *codec,
 				  char *prefix,
 				  unsigned int *retfmt);
+__printf(3, 4)
 int asoc_simple_card_set_dailink_name(struct device *dev,
 				      struct snd_soc_dai_link *dai_link,
 				      const char *fmt, ...);
 int asoc_simple_card_parse_card_name(struct snd_soc_card *card,
 				     char *prefix);
 
+#define asoc_simple_card_parse_clk_cpu(node, dai_link, simple_dai)		\
+	asoc_simple_card_parse_clk(node, dai_link->cpu_of_node, simple_dai)
+#define asoc_simple_card_parse_clk_codec(node, dai_link, simple_dai)		\
+	asoc_simple_card_parse_clk(node, dai_link->codec_of_node, simple_dai)
+int asoc_simple_card_parse_clk(struct device_node *node,
+			       struct device_node *dai_of_node,
+			       struct asoc_simple_dai *simple_dai);
+
+#define asoc_simple_card_parse_cpu(node, dai_link,				\
+				   list_name, cells_name, is_single_link)	\
+	asoc_simple_card_parse_dai(node, &dai_link->cpu_of_node,		\
+		&dai_link->cpu_dai_name, list_name, cells_name, is_single_link)
+#define asoc_simple_card_parse_codec(node, dai_link, list_name, cells_name)	\
+	asoc_simple_card_parse_dai(node, &dai_link->codec_of_node,		\
+		&dai_link->codec_dai_name, list_name, cells_name, NULL)
+#define asoc_simple_card_parse_platform(node, dai_link, list_name, cells_name)	\
+	asoc_simple_card_parse_dai(node, &dai_link->platform_of_node,		\
+		NULL, list_name, cells_name, NULL)
+int asoc_simple_card_parse_dai(struct device_node *node,
+				  struct device_node **endpoint_np,
+				  const char **dai_name,
+				  const char *list_name,
+				  const char *cells_name,
+				  int *is_single_links);
+
+int asoc_simple_card_init_dai(struct snd_soc_dai *dai,
+			      struct asoc_simple_dai *simple_dai);
+
+int asoc_simple_card_canonicalize_dailink(struct snd_soc_dai_link *dai_link);
+void asoc_simple_card_canonicalize_cpu(struct snd_soc_dai_link *dai_link,
+				      int is_single_links);
+
+int asoc_simple_card_clean_reference(struct snd_soc_card *card);
+
 #endif /* __SIMPLE_CARD_CORE_H */
diff -uwr linux-4.8-rc4.new/include/sound/soc.h linux-4.8-rc4.orig/include/sound/soc.h
--- linux-4.8-rc4.new/include/sound/soc.h	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/include/sound/soc.h	2016-09-04 01:14:37.800066871 +0000
@@ -898,14 +898,6 @@
 	int (*resume)(struct snd_soc_codec *);
 	struct snd_soc_component_driver component_driver;
 
-	/* Default control and setup, added after probe() is run */
-	const struct snd_kcontrol_new *controls;
-	int num_controls;
-	const struct snd_soc_dapm_widget *dapm_widgets;
-	int num_dapm_widgets;
-	const struct snd_soc_dapm_route *dapm_routes;
-	int num_dapm_routes;
-
 	/* codec wide operations */
 	int (*set_sysclk)(struct snd_soc_codec *codec,
 			  int clk_id, int source, unsigned int freq, int dir);
@@ -1547,17 +1539,6 @@
 	return snd_soc_component_get_drvdata(&platform->component);
 }
 
-static inline void snd_soc_pcm_set_drvdata(struct snd_soc_pcm_runtime *rtd,
-		void *data)
-{
-	dev_set_drvdata(rtd->dev, data);
-}
-
-static inline void *snd_soc_pcm_get_drvdata(struct snd_soc_pcm_runtime *rtd)
-{
-	return dev_get_drvdata(rtd->dev);
-}
-
 static inline void snd_soc_initialize_card_lists(struct snd_soc_card *card)
 {
 	INIT_LIST_HEAD(&card->codec_dev_list);
diff -uwr linux-4.8-rc4.new/include/uapi/sound/asoc.h linux-4.8-rc4.orig/include/uapi/sound/asoc.h
--- linux-4.8-rc4.new/include/uapi/sound/asoc.h	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/include/uapi/sound/asoc.h	2016-09-04 01:14:51.667563571 +0000
@@ -83,7 +83,7 @@
 #define SND_SOC_TPLG_NUM_TEXTS		16
 
 /* ABI version */
-#define SND_SOC_TPLG_ABI_VERSION	0x4
+#define SND_SOC_TPLG_ABI_VERSION	0x5
 
 /* Max size of TLV data */
 #define SND_SOC_TPLG_TLV_SIZE		32
@@ -105,7 +105,8 @@
 #define SND_SOC_TPLG_TYPE_CODEC_LINK	9
 #define SND_SOC_TPLG_TYPE_BACKEND_LINK	10
 #define SND_SOC_TPLG_TYPE_PDATA		11
-#define SND_SOC_TPLG_TYPE_MAX	SND_SOC_TPLG_TYPE_PDATA
+#define SND_SOC_TPLG_TYPE_BE_DAI	12
+#define SND_SOC_TPLG_TYPE_MAX		SND_SOC_TPLG_TYPE_BE_DAI
 
 /* vendor block IDs - please add new vendor types to end */
 #define SND_SOC_TPLG_TYPE_VENDOR_FW	1000
@@ -124,6 +125,11 @@
 #define SND_SOC_TPLG_TUPLE_TYPE_WORD	4
 #define SND_SOC_TPLG_TUPLE_TYPE_SHORT	5
 
+/* BE DAI flags */
+#define SND_SOC_TPLG_DAI_FLGBIT_SYMMETRIC_RATES         (1 << 0)
+#define SND_SOC_TPLG_DAI_FLGBIT_SYMMETRIC_CHANNELS      (1 << 1)
+#define SND_SOC_TPLG_DAI_FLGBIT_SYMMETRIC_SAMPLEBITS    (1 << 2)
+
 /*
  * Block Header.
  * This header precedes all object and object arrays below.
@@ -251,6 +257,7 @@
 	__le32 period_size_max;	/* max period size bytes */
 	__le32 buffer_size_min;	/* min buffer size bytes */
 	__le32 buffer_size_max;	/* max buffer size bytes */
+	__le32 sig_bits;        /* number of bits of content */
 } __attribute__((packed));
 
 /*
@@ -285,6 +292,8 @@
 	__le32 graph_elems;	/* number of graph elements */
 	__le32 pcm_elems;	/* number of PCM elements */
 	__le32 dai_link_elems;	/* number of DAI link elements */
+	__le32 be_dai_elems;	/* number of BE DAI elements */
+	__le32 reserved[20];	/* reserved for new ABI element types */
 	struct snd_soc_tplg_private priv;
 } __attribute__((packed));
 
@@ -450,4 +459,26 @@
 	struct snd_soc_tplg_stream stream[SND_SOC_TPLG_STREAM_CONFIG_MAX]; /* supported configs playback and captrure */
 	__le32 num_streams;     /* number of streams */
 } __attribute__((packed));
+
+/*
+ * Describes SW/FW specific features of BE DAI.
+ *
+ * File block representation for BE DAI :-
+ * +-----------------------------------+-----+
+ * | struct snd_soc_tplg_hdr           |  1  |
+ * +-----------------------------------+-----+
+ * | struct snd_soc_tplg_be_dai        |  N  |
+ * +-----------------------------------+-----+
+ */
+struct snd_soc_tplg_be_dai {
+	__le32 size;            /* in bytes of this structure */
+	char dai_name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN]; /* name - used to match */
+	__le32 dai_id;          /* unique ID - used to match */
+	__le32 playback;        /* supports playback mode */
+	__le32 capture;         /* supports capture mode */
+	struct snd_soc_tplg_stream_caps caps[2]; /* playback and capture for DAI */
+	__le32 flag_mask;       /* bitmask of flags to configure */
+	__le32 flags;           /* SND_SOC_TPLG_DAI_FLGBIT_* */
+	struct snd_soc_tplg_private priv;
+} __attribute__((packed));
 #endif
diff -uwr linux-4.8-rc4.new/include/uapi/sound/Kbuild linux-4.8-rc4.orig/include/uapi/sound/Kbuild
--- linux-4.8-rc4.new/include/uapi/sound/Kbuild	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/include/uapi/sound/Kbuild	2016-09-04 01:14:51.643564442 +0000
@@ -13,3 +13,4 @@
 header-y += sfnt_info.h
 header-y += tlv.h
 header-y += usb_stream.h
+header-y += snd_sst_tokens.h
diff -uwr linux-4.8-rc4.new/sound/soc/atmel/atmel-classd.c linux-4.8-rc4.orig/sound/soc/atmel/atmel-classd.c
--- linux-4.8-rc4.new/sound/soc/atmel/atmel-classd.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/atmel/atmel-classd.c	2016-09-04 01:14:34.824174877 +0000
@@ -308,9 +308,11 @@
 
 static struct snd_soc_codec_driver soc_codec_dev_classd = {
 	.probe		= atmel_classd_codec_probe,
+	.get_regmap	= atmel_classd_codec_get_remap,
+	.component_driver = {
 	.controls	= atmel_classd_snd_controls,
 	.num_controls	= ARRAY_SIZE(atmel_classd_snd_controls),
-	.get_regmap	= atmel_classd_codec_get_remap,
+	},
 };
 
 /* codec dai component */
diff -uwr linux-4.8-rc4.new/sound/soc/atmel/atmel-pdmic.c linux-4.8-rc4.orig/sound/soc/atmel/atmel-pdmic.c
--- linux-4.8-rc4.new/sound/soc/atmel/atmel-pdmic.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/atmel/atmel-pdmic.c	2016-09-04 01:14:45.235797002 +0000
@@ -80,7 +80,7 @@
 
 	if (pdata->mic_max_freq < pdata->mic_min_freq) {
 		dev_err(dev,
-			"mic-max-freq should not less than mic-min-freq\n");
+			"mic-max-freq should not be less than mic-min-freq\n");
 		return ERR_PTR(-EINVAL);
 	}
 
@@ -115,8 +115,10 @@
 		return ret;
 
 	ret =  clk_prepare_enable(dd->pclk);
-	if (ret)
+	if (ret) {
+		clk_disable_unprepare(dd->gclk);
 		return ret;
+	}
 
 	/* Clear all bits in the Control Register(PDMIC_CR) */
 	regmap_write(dd->regmap, PDMIC_CR, 0);
@@ -283,7 +285,7 @@
 	8, ARRAY_SIZE(mic_gain_table)-1, TLV_DB_SCALE_ITEM(-6500, 100, 0),
 );
 
-int pdmic_get_mic_volsw(struct snd_kcontrol *kcontrol,
+static int pdmic_get_mic_volsw(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
 	struct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);
@@ -357,8 +359,10 @@
 
 static struct snd_soc_codec_driver soc_codec_dev_pdmic = {
 	.probe		= atmel_pdmic_codec_probe,
+	.component_driver = {
 	.controls	= atmel_pdmic_snd_controls,
 	.num_controls	= ARRAY_SIZE(atmel_pdmic_snd_controls),
+	},
 };
 
 /* codec dai component */
@@ -596,7 +600,7 @@
 	dd->irq = platform_get_irq(pdev, 0);
 	if (dd->irq < 0) {
 		ret = dd->irq;
-		dev_err(dev, "failed to could not get irq: %d\n", ret);
+		dev_err(dev, "failed to get irq: %d\n", ret);
 		return ret;
 	}
 
@@ -614,7 +618,7 @@
 		return ret;
 	}
 
-	/* The gclk clock frequency must always be tree times
+	/* The gclk clock frequency must always be three times
 	 * lower than the pclk clock frequency
 	 */
 	ret = clk_set_rate(dd->gclk, clk_get_rate(dd->pclk)/3);
@@ -649,7 +653,7 @@
 		return ret;
 	}
 
-	/* Get the minimal and maximal sample rate that micphone supports */
+	/* Get the minimal and maximal sample rate that the microphone supports */
 	atmel_pdmic_get_sample_rate(dd, &rate_min, &rate_max);
 
 	/* register cpu dai */
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/88pm860x-codec.c linux-4.8-rc4.orig/sound/soc/codecs/88pm860x-codec.c
--- linux-4.8-rc4.new/sound/soc/codecs/88pm860x-codec.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/88pm860x-codec.c	2016-09-04 01:14:34.820175022 +0000
@@ -1361,12 +1361,14 @@
 	.set_bias_level	= pm860x_set_bias_level,
 	.get_regmap	= pm860x_get_regmap,
 
+	.component_driver = {
 	.controls = pm860x_snd_controls,
 	.num_controls = ARRAY_SIZE(pm860x_snd_controls),
 	.dapm_widgets = pm860x_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(pm860x_dapm_widgets),
 	.dapm_routes = pm860x_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(pm860x_dapm_routes),
+	},
 };
 
 static int pm860x_codec_probe(struct platform_device *pdev)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/ab8500-codec.c linux-4.8-rc4.orig/sound/soc/codecs/ab8500-codec.c
--- linux-4.8-rc4.new/sound/soc/codecs/ab8500-codec.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/ab8500-codec.c	2016-09-04 01:14:34.844174151 +0000
@@ -2408,28 +2408,28 @@
 {
 	u32 value;
 
-	if (of_get_property(np, "stericsson,amic1-type-single-ended", NULL))
+	if (of_property_read_bool(np, "stericsson,amic1-type-single-ended"))
 		codec->amics.mic1_type = AMIC_TYPE_SINGLE_ENDED;
 	else
 		codec->amics.mic1_type = AMIC_TYPE_DIFFERENTIAL;
 
-	if (of_get_property(np, "stericsson,amic2-type-single-ended", NULL))
+	if (of_property_read_bool(np, "stericsson,amic2-type-single-ended"))
 		codec->amics.mic2_type = AMIC_TYPE_SINGLE_ENDED;
 	else
 		codec->amics.mic2_type = AMIC_TYPE_DIFFERENTIAL;
 
 	/* Has a non-standard Vamic been requested? */
-	if (of_get_property(np, "stericsson,amic1a-bias-vamic2", NULL))
+	if (of_property_read_bool(np, "stericsson,amic1a-bias-vamic2"))
 		codec->amics.mic1a_micbias = AMIC_MICBIAS_VAMIC2;
 	else
 		codec->amics.mic1a_micbias = AMIC_MICBIAS_VAMIC1;
 
-	if (of_get_property(np, "stericsson,amic1b-bias-vamic2", NULL))
+	if (of_property_read_bool(np, "stericsson,amic1b-bias-vamic2"))
 		codec->amics.mic1b_micbias = AMIC_MICBIAS_VAMIC2;
 	else
 		codec->amics.mic1b_micbias = AMIC_MICBIAS_VAMIC1;
 
-	if (of_get_property(np, "stericsson,amic2-bias-vamic1", NULL))
+	if (of_property_read_bool(np, "stericsson,amic2-bias-vamic1"))
 		codec->amics.mic2_micbias = AMIC_MICBIAS_VAMIC1;
 	else
 		codec->amics.mic2_micbias = AMIC_MICBIAS_VAMIC2;
@@ -2525,12 +2525,14 @@
 
 static struct snd_soc_codec_driver ab8500_codec_driver = {
 	.probe =		ab8500_codec_probe,
+	.component_driver = {
 	.controls =		ab8500_ctrls,
 	.num_controls =		ARRAY_SIZE(ab8500_ctrls),
 	.dapm_widgets =		ab8500_dapm_widgets,
 	.num_dapm_widgets =	ARRAY_SIZE(ab8500_dapm_widgets),
 	.dapm_routes =		ab8500_dapm_routes,
 	.num_dapm_routes =	ARRAY_SIZE(ab8500_dapm_routes),
+	},
 };
 
 static int ab8500_codec_driver_probe(struct platform_device *pdev)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/ac97.c linux-4.8-rc4.orig/sound/soc/codecs/ac97.c
--- linux-4.8-rc4.new/sound/soc/codecs/ac97.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/ac97.c	2016-09-04 01:14:34.792176038 +0000
@@ -117,10 +117,12 @@
 	.suspend =	ac97_soc_suspend,
 	.resume =	ac97_soc_resume,
 
+	.component_driver = {
 	.dapm_widgets = ac97_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(ac97_widgets),
 	.dapm_routes = ac97_routes,
 	.num_dapm_routes = ARRAY_SIZE(ac97_routes),
+	},
 };
 
 static int ac97_probe(struct platform_device *pdev)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/ad1836.c linux-4.8-rc4.orig/sound/soc/codecs/ad1836.c
--- linux-4.8-rc4.new/sound/soc/codecs/ad1836.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/ad1836.c	2016-09-04 01:14:34.808175458 +0000
@@ -327,12 +327,14 @@
 	.suspend = ad1836_suspend,
 	.resume = ad1836_resume,
 
+	.component_driver = {
 	.controls = ad183x_controls,
 	.num_controls = ARRAY_SIZE(ad183x_controls),
 	.dapm_widgets = ad183x_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(ad183x_dapm_widgets),
 	.dapm_routes = ad183x_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(ad183x_dapm_routes),
+	},
 };
 
 static const struct reg_default ad1836_reg_defaults[] = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/ad193x.c linux-4.8-rc4.orig/sound/soc/codecs/ad193x.c
--- linux-4.8-rc4.new/sound/soc/codecs/ad193x.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/ad193x.c	2016-09-04 01:14:34.812175312 +0000
@@ -410,12 +410,14 @@
 
 static struct snd_soc_codec_driver soc_codec_dev_ad193x = {
 	.probe = ad193x_codec_probe,
+	.component_driver = {
 	.controls = ad193x_snd_controls,
 	.num_controls = ARRAY_SIZE(ad193x_snd_controls),
 	.dapm_widgets = ad193x_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(ad193x_dapm_widgets),
 	.dapm_routes = audio_paths,
 	.num_dapm_routes = ARRAY_SIZE(audio_paths),
+	},
 };
 
 const struct regmap_config ad193x_regmap_config = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/ad1980.c linux-4.8-rc4.orig/sound/soc/codecs/ad1980.c
--- linux-4.8-rc4.new/sound/soc/codecs/ad1980.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/ad1980.c	2016-09-04 01:14:34.796175893 +0000
@@ -299,12 +299,14 @@
 	.probe = 	ad1980_soc_probe,
 	.remove = 	ad1980_soc_remove,
 
+	.component_driver = {
 	.controls = ad1980_snd_ac97_controls,
 	.num_controls = ARRAY_SIZE(ad1980_snd_ac97_controls),
 	.dapm_widgets = ad1980_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(ad1980_dapm_widgets),
 	.dapm_routes = ad1980_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(ad1980_dapm_routes),
+	},
 };
 
 static int ad1980_probe(struct platform_device *pdev)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/ad73311.c linux-4.8-rc4.orig/sound/soc/codecs/ad73311.c
--- linux-4.8-rc4.new/sound/soc/codecs/ad73311.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/ad73311.c	2016-09-04 01:14:34.800175748 +0000
@@ -55,10 +55,12 @@
 };
 
 static struct snd_soc_codec_driver soc_codec_dev_ad73311 = {
+	.component_driver = {
 	.dapm_widgets = ad73311_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(ad73311_dapm_widgets),
 	.dapm_routes = ad73311_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(ad73311_dapm_routes),
+	},
 };
 
 static int ad73311_probe(struct platform_device *pdev)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/adau1373.c linux-4.8-rc4.orig/sound/soc/codecs/adau1373.c
--- linux-4.8-rc4.new/sound/soc/codecs/adau1373.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/adau1373.c	2016-09-04 01:14:34.808175458 +0000
@@ -1466,12 +1466,14 @@
 
 	.set_pll = adau1373_set_pll,
 
+	.component_driver = {
 	.controls = adau1373_controls,
 	.num_controls = ARRAY_SIZE(adau1373_controls),
 	.dapm_widgets = adau1373_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(adau1373_dapm_widgets),
 	.dapm_routes = adau1373_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(adau1373_dapm_routes),
+	},
 };
 
 static int adau1373_i2c_probe(struct i2c_client *client,
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/adau1701.c linux-4.8-rc4.orig/sound/soc/codecs/adau1701.c
--- linux-4.8-rc4.new/sound/soc/codecs/adau1701.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/adau1701.c	2016-09-04 01:14:34.792176038 +0000
@@ -765,13 +765,14 @@
 	.set_bias_level		= adau1701_set_bias_level,
 	.idle_bias_off		= true,
 
+	.component_driver = {
 	.controls		= adau1701_controls,
 	.num_controls		= ARRAY_SIZE(adau1701_controls),
 	.dapm_widgets		= adau1701_dapm_widgets,
 	.num_dapm_widgets	= ARRAY_SIZE(adau1701_dapm_widgets),
 	.dapm_routes		= adau1701_dapm_routes,
 	.num_dapm_routes	= ARRAY_SIZE(adau1701_dapm_routes),
-
+	},
 	.set_sysclk		= adau1701_set_sysclk,
 };
 
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/adau1761.c linux-4.8-rc4.orig/sound/soc/codecs/adau1761.c
--- linux-4.8-rc4.new/sound/soc/codecs/adau1761.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/adau1761.c	2016-09-04 01:14:34.984169070 +0000
@@ -719,12 +719,14 @@
 	.set_bias_level	= adau1761_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
 	.controls = adau1761_controls,
 	.num_controls = ARRAY_SIZE(adau1761_controls),
 	.dapm_widgets = adau1x61_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(adau1x61_dapm_widgets),
 	.dapm_routes = adau1x61_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(adau1x61_dapm_routes),
+	},
 };
 
 #define ADAU1761_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE | \
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/adau1781.c linux-4.8-rc4.orig/sound/soc/codecs/adau1781.c
--- linux-4.8-rc4.new/sound/soc/codecs/adau1781.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/adau1781.c	2016-09-04 01:14:35.176162102 +0000
@@ -432,12 +432,14 @@
 	.set_bias_level = adau1781_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
 	.controls = adau1781_controls,
 	.num_controls = ARRAY_SIZE(adau1781_controls),
 	.dapm_widgets = adau1781_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(adau1781_dapm_widgets),
 	.dapm_routes = adau1781_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(adau1781_dapm_routes),
+	},
 };
 
 #define ADAU1781_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE | \
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/adau1977.c linux-4.8-rc4.orig/sound/soc/codecs/adau1977.c
--- linux-4.8-rc4.new/sound/soc/codecs/adau1977.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/adau1977.c	2016-09-04 01:14:35.308157311 +0000
@@ -873,12 +873,14 @@
 	.set_sysclk = adau1977_set_sysclk,
 	.idle_bias_off = true,
 
+	.component_driver = {
 	.controls = adau1977_snd_controls,
 	.num_controls = ARRAY_SIZE(adau1977_snd_controls),
 	.dapm_widgets = adau1977_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(adau1977_dapm_widgets),
 	.dapm_routes = adau1977_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(adau1977_dapm_routes),
+	},
 };
 
 static int adau1977_setup_micbias(struct adau1977 *adau1977)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/adau7002.c linux-4.8-rc4.orig/sound/soc/codecs/adau7002.c
--- linux-4.8-rc4.new/sound/soc/codecs/adau7002.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/adau7002.c	2016-09-04 01:14:34.788176183 +0000
@@ -39,10 +39,12 @@
 };
 
 static const struct snd_soc_codec_driver adau7002_codec_driver = {
+	.component_driver = {
 	.dapm_widgets = adau7002_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(adau7002_widgets),
 	.dapm_routes = adau7002_routes,
 	.num_dapm_routes = ARRAY_SIZE(adau7002_routes),
+	},
 };
 
 static int adau7002_probe(struct platform_device *pdev)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/adav80x.c linux-4.8-rc4.orig/sound/soc/codecs/adav80x.c
--- linux-4.8-rc4.new/sound/soc/codecs/adav80x.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/adav80x.c	2016-09-04 01:14:35.444152376 +0000
@@ -834,12 +834,14 @@
 	.set_pll = adav80x_set_pll,
 	.set_sysclk = adav80x_set_sysclk,
 
+	.component_driver = {
 	.controls = adav80x_controls,
 	.num_controls = ARRAY_SIZE(adav80x_controls),
 	.dapm_widgets = adav80x_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(adav80x_dapm_widgets),
 	.dapm_routes = adav80x_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(adav80x_dapm_routes),
+	},
 };
 
 int adav80x_bus_probe(struct device *dev, struct regmap *regmap)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/ads117x.c linux-4.8-rc4.orig/sound/soc/codecs/ads117x.c
--- linux-4.8-rc4.new/sound/soc/codecs/ads117x.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/ads117x.c	2016-09-04 01:14:35.728142069 +0000
@@ -59,10 +59,12 @@
 };
 
 static struct snd_soc_codec_driver soc_codec_dev_ads117x = {
+	.component_driver = {
 	.dapm_widgets = ads117x_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(ads117x_dapm_widgets),
 	.dapm_routes = ads117x_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(ads117x_dapm_routes),
+	},
 };
 
 static int ads117x_probe(struct platform_device *pdev)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/ak4104.c linux-4.8-rc4.orig/sound/soc/codecs/ak4104.c
--- linux-4.8-rc4.new/sound/soc/codecs/ak4104.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/ak4104.c	2016-09-04 01:14:34.784176329 +0000
@@ -245,10 +245,12 @@
 	.suspend = ak4104_soc_suspend,
 	.resume = ak4104_soc_resume,
 
+	.component_driver = {
 	.dapm_widgets = ak4104_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(ak4104_dapm_widgets),
 	.dapm_routes = ak4104_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(ak4104_dapm_routes),
+	}
 };
 
 static const struct regmap_config ak4104_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/ak4535.c linux-4.8-rc4.orig/sound/soc/codecs/ak4535.c
--- linux-4.8-rc4.new/sound/soc/codecs/ak4535.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/ak4535.c	2016-09-04 01:14:35.868136988 +0000
@@ -395,12 +395,14 @@
 	.set_bias_level = ak4535_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
 	.controls = ak4535_snd_controls,
 	.num_controls = ARRAY_SIZE(ak4535_snd_controls),
 	.dapm_widgets = ak4535_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(ak4535_dapm_widgets),
 	.dapm_routes = ak4535_audio_map,
 	.num_dapm_routes = ARRAY_SIZE(ak4535_audio_map),
+	},
 };
 
 static int ak4535_i2c_probe(struct i2c_client *i2c,
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/ak4554.c linux-4.8-rc4.orig/sound/soc/codecs/ak4554.c
--- linux-4.8-rc4.new/sound/soc/codecs/ak4554.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/ak4554.c	2016-09-04 01:14:34.780176473 +0000
@@ -65,10 +65,12 @@
 };
 
 static struct snd_soc_codec_driver soc_codec_dev_ak4554 = {
+	.component_driver = {
 	.dapm_widgets = ak4554_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(ak4554_dapm_widgets),
 	.dapm_routes = ak4554_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(ak4554_dapm_routes),
+	},
 };
 
 static int ak4554_soc_probe(struct platform_device *pdev)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/ak4613.c linux-4.8-rc4.orig/sound/soc/codecs/ak4613.c
--- linux-4.8-rc4.new/sound/soc/codecs/ak4613.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/ak4613.c	2016-09-04 01:14:34.780176473 +0000
@@ -458,12 +458,14 @@
 	.suspend		= ak4613_suspend,
 	.resume			= ak4613_resume,
 	.set_bias_level		= ak4613_set_bias_level,
+	.component_driver = {
 	.controls		= ak4613_snd_controls,
 	.num_controls		= ARRAY_SIZE(ak4613_snd_controls),
 	.dapm_widgets		= ak4613_dapm_widgets,
 	.num_dapm_widgets	= ARRAY_SIZE(ak4613_dapm_widgets),
 	.dapm_routes		= ak4613_intercon,
 	.num_dapm_routes	= ARRAY_SIZE(ak4613_intercon),
+	},
 };
 
 static void ak4613_parse_of(struct ak4613_priv *priv,
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/ak4641.c linux-4.8-rc4.orig/sound/soc/codecs/ak4641.c
--- linux-4.8-rc4.new/sound/soc/codecs/ak4641.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/ak4641.c	2016-09-04 01:14:36.012131762 +0000
@@ -505,12 +505,14 @@
 };
 
 static struct snd_soc_codec_driver soc_codec_dev_ak4641 = {
+	.component_driver = {
 	.controls		= ak4641_snd_controls,
 	.num_controls		= ARRAY_SIZE(ak4641_snd_controls),
 	.dapm_widgets		= ak4641_dapm_widgets,
 	.num_dapm_widgets	= ARRAY_SIZE(ak4641_dapm_widgets),
 	.dapm_routes		= ak4641_audio_map,
 	.num_dapm_routes	= ARRAY_SIZE(ak4641_audio_map),
+	},
 	.set_bias_level		= ak4641_set_bias_level,
 	.suspend_bias_off	= true,
 };
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/ak4642.c linux-4.8-rc4.orig/sound/soc/codecs/ak4642.c
--- linux-4.8-rc4.new/sound/soc/codecs/ak4642.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/ak4642.c	2016-09-04 01:14:34.776176619 +0000
@@ -555,12 +555,14 @@
 	.suspend		= ak4642_suspend,
 	.resume			= ak4642_resume,
 	.set_bias_level		= ak4642_set_bias_level,
+	.component_driver = {
 	.controls		= ak4642_snd_controls,
 	.num_controls		= ARRAY_SIZE(ak4642_snd_controls),
 	.dapm_widgets		= ak4642_dapm_widgets,
 	.num_dapm_widgets	= ARRAY_SIZE(ak4642_dapm_widgets),
 	.dapm_routes		= ak4642_intercon,
 	.num_dapm_routes	= ARRAY_SIZE(ak4642_intercon),
+	},
 };
 
 static const struct regmap_config ak4642_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/ak4671.c linux-4.8-rc4.orig/sound/soc/codecs/ak4671.c
--- linux-4.8-rc4.new/sound/soc/codecs/ak4671.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/ak4671.c	2016-09-04 01:14:36.016131617 +0000
@@ -612,12 +612,14 @@
 
 static struct snd_soc_codec_driver soc_codec_dev_ak4671 = {
 	.set_bias_level = ak4671_set_bias_level,
+	.component_driver = {
 	.controls = ak4671_snd_controls,
 	.num_controls = ARRAY_SIZE(ak4671_snd_controls),
 	.dapm_widgets = ak4671_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(ak4671_dapm_widgets),
 	.dapm_routes = ak4671_intercon,
 	.num_dapm_routes = ARRAY_SIZE(ak4671_intercon),
+	},
 };
 
 static const struct regmap_config ak4671_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/ak5386.c linux-4.8-rc4.orig/sound/soc/codecs/ak5386.c
--- linux-4.8-rc4.new/sound/soc/codecs/ak5386.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/ak5386.c	2016-09-04 01:14:34.772176764 +0000
@@ -74,10 +74,12 @@
 	.remove = ak5386_soc_remove,
 	.suspend = ak5386_soc_suspend,
 	.resume = ak5386_soc_resume,
+	.component_driver = {
 	.dapm_widgets = ak5386_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(ak5386_dapm_widgets),
 	.dapm_routes = ak5386_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(ak5386_dapm_routes),
+	},
 };
 
 static int ak5386_set_dai_fmt(struct snd_soc_dai *codec_dai,
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/alc5632.c linux-4.8-rc4.orig/sound/soc/codecs/alc5632.c
--- linux-4.8-rc4.new/sound/soc/codecs/alc5632.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/alc5632.c	2016-09-04 01:14:36.020131471 +0000
@@ -1072,12 +1072,14 @@
 	.set_bias_level = alc5632_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
 	.controls = alc5632_snd_controls,
 	.num_controls = ARRAY_SIZE(alc5632_snd_controls),
 	.dapm_widgets = alc5632_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(alc5632_dapm_widgets),
 	.dapm_routes = alc5632_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(alc5632_dapm_routes),
+	},
 };
 
 static const struct regmap_config alc5632_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/bt-sco.c linux-4.8-rc4.orig/sound/soc/codecs/bt-sco.c
--- linux-4.8-rc4.new/sound/soc/codecs/bt-sco.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/bt-sco.c	2016-09-04 01:14:34.768176909 +0000
@@ -63,10 +63,12 @@
 };
 
 static struct snd_soc_codec_driver soc_codec_dev_bt_sco = {
+	.component_driver = {
 	.dapm_widgets = bt_sco_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(bt_sco_widgets),
 	.dapm_routes = bt_sco_routes,
 	.num_dapm_routes = ARRAY_SIZE(bt_sco_routes),
+	},
 };
 
 static int bt_sco_probe(struct platform_device *pdev)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/cs35l32.c linux-4.8-rc4.orig/sound/soc/codecs/cs35l32.c
--- linux-4.8-rc4.new/sound/soc/codecs/cs35l32.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/cs35l32.c	2016-09-04 01:14:34.764177054 +0000
@@ -231,13 +231,14 @@
 static const struct snd_soc_codec_driver soc_codec_dev_cs35l32 = {
 	.set_sysclk = cs35l32_codec_set_sysclk,
 
+	.component_driver = {
+		.controls		= cs35l32_snd_controls,
+		.num_controls		= ARRAY_SIZE(cs35l32_snd_controls),
 	.dapm_widgets = cs35l32_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(cs35l32_dapm_widgets),
 	.dapm_routes = cs35l32_audio_map,
 	.num_dapm_routes = ARRAY_SIZE(cs35l32_audio_map),
-
-	.controls = cs35l32_snd_controls,
-	.num_controls = ARRAY_SIZE(cs35l32_snd_controls),
+	},
 };
 
 /* Current and threshold powerup sequence Pg37 in datasheet */
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/cs35l33.c linux-4.8-rc4.orig/sound/soc/codecs/cs35l33.c
--- linux-4.8-rc4.new/sound/soc/codecs/cs35l33.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/cs35l33.c	2016-09-04 01:14:34.764177054 +0000
@@ -837,13 +837,14 @@
 	.set_bias_level = cs35l33_set_bias_level,
 	.set_sysclk = cs35l33_codec_set_sysclk,
 
+	.component_driver = {
+		.controls		= cs35l33_snd_controls,
+		.num_controls		= ARRAY_SIZE(cs35l33_snd_controls),
 	.dapm_widgets = cs35l33_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(cs35l33_dapm_widgets),
 	.dapm_routes = cs35l33_audio_map,
 	.num_dapm_routes = ARRAY_SIZE(cs35l33_audio_map),
-	.controls = cs35l33_snd_controls,
-	.num_controls = ARRAY_SIZE(cs35l33_snd_controls),
-
+	},
 	.idle_bias_off = true,
 };
 
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/cs4265.c linux-4.8-rc4.orig/sound/soc/codecs/cs4265.c
--- linux-4.8-rc4.new/sound/soc/codecs/cs4265.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/cs4265.c	2016-09-04 01:14:34.472187652 +0000
@@ -547,13 +547,14 @@
 static const struct snd_soc_codec_driver soc_codec_cs4265 = {
 	.set_bias_level = cs4265_set_bias_level,
 
+	.component_driver = {
+		.controls		= cs4265_snd_controls,
+		.num_controls		= ARRAY_SIZE(cs4265_snd_controls),
 	.dapm_widgets = cs4265_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(cs4265_dapm_widgets),
 	.dapm_routes = cs4265_audio_map,
 	.num_dapm_routes = ARRAY_SIZE(cs4265_audio_map),
-
-	.controls = cs4265_snd_controls,
-	.num_controls = ARRAY_SIZE(cs4265_snd_controls),
+	},
 };
 
 static const struct regmap_config cs4265_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/cs4270.c linux-4.8-rc4.orig/sound/soc/codecs/cs4270.c
--- linux-4.8-rc4.new/sound/soc/codecs/cs4270.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/cs4270.c	2016-09-04 01:14:34.332192733 +0000
@@ -617,12 +617,14 @@
 	.suspend =		cs4270_soc_suspend,
 	.resume =		cs4270_soc_resume,
 
+	.component_driver = {
 	.controls =		cs4270_snd_controls,
 	.num_controls =		ARRAY_SIZE(cs4270_snd_controls),
 	.dapm_widgets =		cs4270_dapm_widgets,
 	.num_dapm_widgets =	ARRAY_SIZE(cs4270_dapm_widgets),
 	.dapm_routes =		cs4270_dapm_routes,
 	.num_dapm_routes =	ARRAY_SIZE(cs4270_dapm_routes),
+	},
 };
 
 /*
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/cs4271.c linux-4.8-rc4.orig/sound/soc/codecs/cs4271.c
--- linux-4.8-rc4.new/sound/soc/codecs/cs4271.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/cs4271.c	2016-09-04 01:14:34.192197813 +0000
@@ -645,12 +645,14 @@
 	.suspend		= cs4271_soc_suspend,
 	.resume			= cs4271_soc_resume,
 
+	.component_driver = {
 	.controls		= cs4271_snd_controls,
 	.num_controls		= ARRAY_SIZE(cs4271_snd_controls),
 	.dapm_widgets		= cs4271_dapm_widgets,
 	.num_dapm_widgets	= ARRAY_SIZE(cs4271_dapm_widgets),
 	.dapm_routes		= cs4271_dapm_routes,
 	.num_dapm_routes	= ARRAY_SIZE(cs4271_dapm_routes),
+	},
 };
 
 static int cs4271_common_probe(struct device *dev,
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/cs42l51.c linux-4.8-rc4.orig/sound/soc/codecs/cs42l51.c
--- linux-4.8-rc4.new/sound/soc/codecs/cs42l51.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/cs42l51.c	2016-09-04 01:14:33.900208411 +0000
@@ -507,12 +507,14 @@
 static struct snd_soc_codec_driver soc_codec_device_cs42l51 = {
 	.probe = cs42l51_codec_probe,
 
+	.component_driver = {
 	.controls = cs42l51_snd_controls,
 	.num_controls = ARRAY_SIZE(cs42l51_snd_controls),
 	.dapm_widgets = cs42l51_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(cs42l51_dapm_widgets),
 	.dapm_routes = cs42l51_routes,
 	.num_dapm_routes = ARRAY_SIZE(cs42l51_routes),
+	},
 };
 
 const struct regmap_config cs42l51_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/cs42l52.c linux-4.8-rc4.orig/sound/soc/codecs/cs42l52.c
--- linux-4.8-rc4.new/sound/soc/codecs/cs42l52.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/cs42l52.c	2016-09-04 01:14:33.784212621 +0000
@@ -1056,13 +1056,14 @@
 	.set_bias_level = cs42l52_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
+		.controls		= cs42l52_snd_controls,
+		.num_controls		= ARRAY_SIZE(cs42l52_snd_controls),
 	.dapm_widgets = cs42l52_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(cs42l52_dapm_widgets),
 	.dapm_routes = cs42l52_audio_map,
 	.num_dapm_routes = ARRAY_SIZE(cs42l52_audio_map),
-
-	.controls = cs42l52_snd_controls,
-	.num_controls = ARRAY_SIZE(cs42l52_snd_controls),
+	},
 };
 
 /* Current and threshold powerup sequence Pg37 */
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/cs42l56.c linux-4.8-rc4.orig/sound/soc/codecs/cs42l56.c
--- linux-4.8-rc4.new/sound/soc/codecs/cs42l56.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/cs42l56.c	2016-09-04 01:14:33.456224524 +0000
@@ -1121,13 +1121,14 @@
 	.set_bias_level = cs42l56_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
+		.controls		= cs42l56_snd_controls,
+		.num_controls		= ARRAY_SIZE(cs42l56_snd_controls),
 	.dapm_widgets = cs42l56_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(cs42l56_dapm_widgets),
 	.dapm_routes = cs42l56_audio_map,
 	.num_dapm_routes = ARRAY_SIZE(cs42l56_audio_map),
-
-	.controls = cs42l56_snd_controls,
-	.num_controls = ARRAY_SIZE(cs42l56_snd_controls),
+	},
 };
 
 static const struct regmap_config cs42l56_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/cs42l73.c linux-4.8-rc4.orig/sound/soc/codecs/cs42l73.c
--- linux-4.8-rc4.new/sound/soc/codecs/cs42l73.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/cs42l73.c	2016-09-04 01:14:33.300230186 +0000
@@ -794,7 +794,7 @@
 	u8 mmcc;
 };
 
-static struct cs42l73_mclk_div cs42l73_mclk_coeffs[] = {
+static const struct cs42l73_mclk_div cs42l73_mclk_coeffs[] = {
 	/* MCLK, Sample Rate, xMMCC[5:0] */
 	{5644800, 11025, 0x30},
 	{5644800, 22050, 0x20},
@@ -844,7 +844,7 @@
 	u8 mclkdiv;
 };
 
-static struct cs42l73_mclkx_div cs42l73_mclkx_coeffs[] = {
+static const struct cs42l73_mclkx_div cs42l73_mclkx_coeffs[] = {
 	{5644800,  1, 0},	/* 5644800 */
 	{6000000,  1, 0},	/* 6000000 */
 	{6144000,  1, 0},	/* 6144000 */
@@ -1257,13 +1257,14 @@
 	.set_bias_level = cs42l73_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
+		.controls		= cs42l73_snd_controls,
+		.num_controls		= ARRAY_SIZE(cs42l73_snd_controls),
 	.dapm_widgets = cs42l73_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(cs42l73_dapm_widgets),
 	.dapm_routes = cs42l73_audio_map,
 	.num_dapm_routes = ARRAY_SIZE(cs42l73_audio_map),
-
-	.controls = cs42l73_snd_controls,
-	.num_controls = ARRAY_SIZE(cs42l73_snd_controls),
+	},
 };
 
 static const struct regmap_config cs42l73_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/cs42xx8.c linux-4.8-rc4.orig/sound/soc/codecs/cs42xx8.c
--- linux-4.8-rc4.new/sound/soc/codecs/cs42xx8.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/cs42xx8.c	2016-09-04 01:14:33.300230186 +0000
@@ -411,12 +411,14 @@
 	.probe = cs42xx8_codec_probe,
 	.idle_bias_off = true,
 
+	.component_driver = {
 	.controls = cs42xx8_snd_controls,
 	.num_controls = ARRAY_SIZE(cs42xx8_snd_controls),
 	.dapm_widgets = cs42xx8_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(cs42xx8_dapm_widgets),
 	.dapm_routes = cs42xx8_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(cs42xx8_dapm_routes),
+	},
 };
 
 const struct cs42xx8_driver_data cs42448_data = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/cs4349.c linux-4.8-rc4.orig/sound/soc/codecs/cs4349.c
--- linux-4.8-rc4.new/sound/soc/codecs/cs4349.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/cs4349.c	2016-09-04 01:14:33.120236719 +0000
@@ -256,13 +256,14 @@
 };
 
 static struct snd_soc_codec_driver soc_codec_dev_cs4349 = {
+	.component_driver = {
 	.controls		= cs4349_snd_controls,
 	.num_controls		= ARRAY_SIZE(cs4349_snd_controls),
-
 	.dapm_widgets		= cs4349_dapm_widgets,
 	.num_dapm_widgets	= ARRAY_SIZE(cs4349_dapm_widgets),
 	.dapm_routes		= cs4349_routes,
 	.num_dapm_routes	= ARRAY_SIZE(cs4349_routes),
+	},
 };
 
 static const struct regmap_config cs4349_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/cs47l24.c linux-4.8-rc4.orig/sound/soc/codecs/cs47l24.c
--- linux-4.8-rc4.new/sound/soc/codecs/cs47l24.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/cs47l24.c	2016-09-04 01:14:41.199943478 +0000
@@ -746,6 +746,16 @@
 	{ "IN2L", NULL, "SYSCLK" },
 	{ "IN2R", NULL, "SYSCLK" },
 
+	{ "ASRC1L", NULL, "SYSCLK" },
+	{ "ASRC1R", NULL, "SYSCLK" },
+	{ "ASRC2L", NULL, "SYSCLK" },
+	{ "ASRC2R", NULL, "SYSCLK" },
+
+	{ "ASRC1L", NULL, "ASYNCCLK" },
+	{ "ASRC1R", NULL, "ASYNCCLK" },
+	{ "ASRC2L", NULL, "ASYNCCLK" },
+	{ "ASRC2R", NULL, "ASYNCCLK" },
+
 	{ "MICBIAS1", NULL, "MICVDD" },
 	{ "MICBIAS2", NULL, "MICVDD" },
 
@@ -1190,12 +1200,14 @@
 	.set_sysclk = arizona_set_sysclk,
 	.set_pll = cs47l24_set_fll,
 
+	.component_driver = {
 	.controls = cs47l24_snd_controls,
 	.num_controls = ARRAY_SIZE(cs47l24_snd_controls),
 	.dapm_widgets = cs47l24_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(cs47l24_dapm_widgets),
 	.dapm_routes = cs47l24_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(cs47l24_dapm_routes),
+	},
 };
 
 static struct snd_compr_ops cs47l24_compr_ops = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/cs53l30.c linux-4.8-rc4.orig/sound/soc/codecs/cs53l30.c
--- linux-4.8-rc4.new/sound/soc/codecs/cs53l30.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/cs53l30.c	2016-09-04 01:14:32.748250219 +0000
@@ -466,7 +466,7 @@
 	u8 mclk_int_scale;
 };
 
-static struct cs53l30_mclk_div cs53l30_mclk_coeffs[] = {
+static const struct cs53l30_mclk_div cs53l30_mclk_coeffs[] = {
 	/* NOTE: Enable MCLK_INT_SCALE to save power. */
 
 	/* MCLK, Sample Rate, asp_rate, internal_fs_ratio, mclk_int_scale */
@@ -511,7 +511,7 @@
 	u8 mclkdiv;
 };
 
-static struct cs53l30_mclkx_div cs53l30_mclkx_coeffs[] = {
+static const struct cs53l30_mclkx_div cs53l30_mclkx_coeffs[] = {
 	{5644800,  1, CS53L30_MCLK_DIV_BY_1},
 	{6000000,  1, CS53L30_MCLK_DIV_BY_1},
 	{6144000,  1, CS53L30_MCLK_DIV_BY_1},
@@ -897,13 +897,14 @@
 	.set_bias_level = cs53l30_set_bias_level,
 	.idle_bias_off = true,
 
+	.component_driver = {
+		.controls		= cs53l30_snd_controls,
+		.num_controls		= ARRAY_SIZE(cs53l30_snd_controls),
 	.dapm_widgets = cs53l30_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(cs53l30_dapm_widgets),
 	.dapm_routes = cs53l30_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(cs53l30_dapm_routes),
-
-	.controls = cs53l30_snd_controls,
-	.num_controls = ARRAY_SIZE(cs53l30_snd_controls),
+	},
 };
 
 static struct regmap_config cs53l30_regmap = {
@@ -999,8 +1000,8 @@
 	/* Check if MCLK provided */
 	cs53l30->mclk = devm_clk_get(dev, "mclk");
 	if (IS_ERR(cs53l30->mclk)) {
-		if (PTR_ERR(cs53l30->mclk) == -EPROBE_DEFER) {
-			ret = -EPROBE_DEFER;
+		if (PTR_ERR(cs53l30->mclk) != -ENOENT) {
+			ret = PTR_ERR(cs53l30->mclk);
 			goto error;
 		}
 		/* Otherwise mark the mclk pointer to NULL */
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/cx20442.c linux-4.8-rc4.orig/sound/soc/codecs/cx20442.c
--- linux-4.8-rc4.new/sound/soc/codecs/cx20442.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/cx20442.c	2016-09-04 01:14:36.032131036 +0000
@@ -407,10 +407,12 @@
 	.reg_word_size = sizeof(u8),
 	.read = cx20442_read_reg_cache,
 	.write = cx20442_write,
+	.component_driver = {
 	.dapm_widgets = cx20442_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(cx20442_dapm_widgets),
 	.dapm_routes = cx20442_audio_map,
 	.num_dapm_routes = ARRAY_SIZE(cx20442_audio_map),
+	},
 };
 
 static int cx20442_platform_probe(struct platform_device *pdev)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/da7210.c linux-4.8-rc4.orig/sound/soc/codecs/da7210.c
--- linux-4.8-rc4.new/sound/soc/codecs/da7210.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/da7210.c	2016-09-04 01:14:36.032131036 +0000
@@ -1167,13 +1167,14 @@
 static struct snd_soc_codec_driver soc_codec_dev_da7210 = {
 	.probe			= da7210_probe,
 
+	.component_driver = {
 	.controls		= da7210_snd_controls,
 	.num_controls		= ARRAY_SIZE(da7210_snd_controls),
-
 	.dapm_widgets		= da7210_dapm_widgets,
 	.num_dapm_widgets	= ARRAY_SIZE(da7210_dapm_widgets),
 	.dapm_routes		= da7210_audio_map,
 	.num_dapm_routes	= ARRAY_SIZE(da7210_audio_map),
+	},
 };
 
 #if IS_ENABLED(CONFIG_I2C)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/da7213.c linux-4.8-rc4.orig/sound/soc/codecs/da7213.c
--- linux-4.8-rc4.new/sound/soc/codecs/da7213.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/da7213.c	2016-09-04 01:14:36.044130601 +0000
@@ -750,11 +750,18 @@
 		snd_soc_update_bits(codec, DA7213_PC_COUNT,
 				    DA7213_PC_FREERUN_MASK, 0);
 
-		/* Slave mode, if SRM not enabled no need for status checks */
+		/* If SRM not enabled then nothing more to do */
 		pll_ctrl = snd_soc_read(codec, DA7213_PLL_CTRL);
 		if (!(pll_ctrl & DA7213_PLL_SRM_EN))
 			return 0;
 
+		/* Assist 32KHz mode PLL lock */
+		if (pll_ctrl & DA7213_PLL_32K_MODE) {
+			snd_soc_write(codec, 0xF0, 0x8B);
+			snd_soc_write(codec, 0xF2, 0x03);
+			snd_soc_write(codec, 0xF0, 0x00);
+		}
+
 		/* Check SRM has locked */
 		do {
 			pll_status = snd_soc_read(codec, DA7213_PLL_STATUS);
@@ -771,6 +778,14 @@
 
 		return 0;
 	case SND_SOC_DAPM_POST_PMD:
+		/* Revert 32KHz PLL lock udpates if applied previously */
+		pll_ctrl = snd_soc_read(codec, DA7213_PLL_CTRL);
+		if (pll_ctrl & DA7213_PLL_32K_MODE) {
+			snd_soc_write(codec, 0xF0, 0x8B);
+			snd_soc_write(codec, 0xF2, 0x01);
+			snd_soc_write(codec, 0xF0, 0x00);
+		}
+
 		/* PC free-running */
 		snd_soc_update_bits(codec, DA7213_PC_COUNT,
 				    DA7213_PC_FREERUN_MASK,
@@ -1297,10 +1312,13 @@
 
 	switch (clk_id) {
 	case DA7213_CLKSRC_MCLK:
-		da7213->mclk_squarer_en = false;
+		snd_soc_update_bits(codec, DA7213_PLL_CTRL,
+				    DA7213_PLL_MCLK_SQR_EN, 0);
 		break;
 	case DA7213_CLKSRC_MCLK_SQR:
-		da7213->mclk_squarer_en = true;
+		snd_soc_update_bits(codec, DA7213_PLL_CTRL,
+				    DA7213_PLL_MCLK_SQR_EN,
+				    DA7213_PLL_MCLK_SQR_EN);
 		break;
 	default:
 		dev_err(codec_dai->dev, "Unknown clock source %d\n", clk_id);
@@ -1324,7 +1342,7 @@
 	return 0;
 }
 
-/* Supported PLL input frequencies are 5MHz - 54MHz. */
+/* Supported PLL input frequencies are 32KHz, 5MHz - 54MHz. */
 static int da7213_set_dai_pll(struct snd_soc_dai *codec_dai, int pll_id,
 			      int source, unsigned int fref, unsigned int fout)
 {
@@ -1336,22 +1354,26 @@
 	u32 freq_ref;
 	u64 frac_div;
 
-	/* Reset PLL configuration */
-	snd_soc_write(codec, DA7213_PLL_CTRL, 0);
-
-	pll_ctrl = 0;
-
 	/* Workout input divider based on MCLK rate */
 	if (da7213->mclk_rate == 32768) {
+		if (!da7213->master) {
+			dev_err(codec->dev,
+				"32KHz only valid if codec is clock master\n");
+			return -EINVAL;
+		}
+
 		/* 32KHz PLL Mode */
 		indiv_bits = DA7213_PLL_INDIV_9_TO_18_MHZ;
 		indiv = DA7213_PLL_INDIV_9_TO_18_MHZ_VAL;
+		source = DA7213_SYSCLK_PLL_32KHZ;
 		freq_ref = 3750000;
-		pll_ctrl |= DA7213_PLL_32K_MODE;
+
 	} else {
-		/* 5 - 54MHz MCLK */
 		if (da7213->mclk_rate < 5000000) {
-			goto pll_err;
+			dev_err(codec->dev,
+				"PLL input clock %d below valid range\n",
+				da7213->mclk_rate);
+			return -EINVAL;
 		} else if (da7213->mclk_rate <= 9000000) {
 			indiv_bits = DA7213_PLL_INDIV_5_TO_9_MHZ;
 			indiv = DA7213_PLL_INDIV_5_TO_9_MHZ_VAL;
@@ -1365,32 +1387,44 @@
 			indiv_bits = DA7213_PLL_INDIV_36_TO_54_MHZ;
 			indiv = DA7213_PLL_INDIV_36_TO_54_MHZ_VAL;
 		} else {
-			goto pll_err;
+			dev_err(codec->dev,
+				"PLL input clock %d above valid range\n",
+				da7213->mclk_rate);
+			return -EINVAL;
 		}
 		freq_ref = (da7213->mclk_rate / indiv);
 	}
 
-	pll_ctrl |= indiv_bits;
+	pll_ctrl = indiv_bits;
 
-	/* PLL Bypass mode */
-	if (source == DA7213_SYSCLK_MCLK) {
-		snd_soc_write(codec, DA7213_PLL_CTRL, pll_ctrl);
+	/* Configure PLL */
+	switch (source) {
+	case DA7213_SYSCLK_MCLK:
+		snd_soc_update_bits(codec, DA7213_PLL_CTRL,
+				    DA7213_PLL_INDIV_MASK |
+				    DA7213_PLL_MODE_MASK, pll_ctrl);
 		return 0;
+	case DA7213_SYSCLK_PLL:
+		break;
+	case DA7213_SYSCLK_PLL_SRM:
+		pll_ctrl |= DA7213_PLL_SRM_EN;
+		fout = DA7213_PLL_FREQ_OUT_94310400;
+		break;
+	case DA7213_SYSCLK_PLL_32KHZ:
+		if (da7213->mclk_rate != 32768) {
+			dev_err(codec->dev,
+				"32KHz mode only valid with 32KHz MCLK\n");
+			return -EINVAL;
 	}
 
-	/*
-	 * If Codec is slave and SRM enabled,
-	 * freq_out is (98304000 + 90316800)/2 = 94310400
-	 */
-	if (!da7213->master && da7213->srm_en) {
+		pll_ctrl |= DA7213_PLL_32K_MODE | DA7213_PLL_SRM_EN;
 		fout = DA7213_PLL_FREQ_OUT_94310400;
-		pll_ctrl |= DA7213_PLL_SRM_EN;
+		break;
+	default:
+		dev_err(codec->dev, "Invalid PLL config\n");
+		return -EINVAL;
 	}
 
-	/* Enable MCLK squarer if required */
-	if (da7213->mclk_squarer_en)
-		pll_ctrl |= DA7213_PLL_MCLK_SQR_EN;
-
 	/* Calculate dividers for PLL */
 	pll_integer = fout / freq_ref;
 	frac_div = (u64)(fout % freq_ref) * 8192ULL;
@@ -1405,14 +1439,19 @@
 
 	/* Enable PLL */
 	pll_ctrl |= DA7213_PLL_EN;
-	snd_soc_write(codec, DA7213_PLL_CTRL, pll_ctrl);
+	snd_soc_update_bits(codec, DA7213_PLL_CTRL,
+			    DA7213_PLL_INDIV_MASK | DA7213_PLL_MODE_MASK,
+			    pll_ctrl);
+
+	/* Assist 32KHz mode PLL lock */
+	if (source == DA7213_SYSCLK_PLL_32KHZ) {
+		snd_soc_write(codec, 0xF0, 0x8B);
+		snd_soc_write(codec, 0xF1, 0x03);
+		snd_soc_write(codec, 0xF1, 0x01);
+		snd_soc_write(codec, 0xF0, 0x00);
+	}
 
 	return 0;
-
-pll_err:
-	dev_err(codec_dai->dev, "Unsupported PLL input frequency %d\n",
-		da7213->mclk_rate);
-	return -EINVAL;
 }
 
 /* DAI operations */
@@ -1454,11 +1493,10 @@
 
 	switch (level) {
 	case SND_SOC_BIAS_ON:
-	case SND_SOC_BIAS_PREPARE:
 		break;
-	case SND_SOC_BIAS_STANDBY:
-		if (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF) {
-			/* MCLK */
+	case SND_SOC_BIAS_PREPARE:
+		/* Enable MCLK for transition to ON state */
+		if (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_STANDBY) {
 			if (da7213->mclk) {
 				ret = clk_prepare_enable(da7213->mclk);
 				if (ret) {
@@ -1467,21 +1505,24 @@
 					return ret;
 				}
 			}
-
+		}
+		break;
+	case SND_SOC_BIAS_STANDBY:
+		if (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF) {
 			/* Enable VMID reference & master bias */
 			snd_soc_update_bits(codec, DA7213_REFERENCES,
 					    DA7213_VMID_EN | DA7213_BIAS_EN,
 					    DA7213_VMID_EN | DA7213_BIAS_EN);
+		} else {
+			/* Remove MCLK */
+			if (da7213->mclk)
+				clk_disable_unprepare(da7213->mclk);
 		}
 		break;
 	case SND_SOC_BIAS_OFF:
 		/* Disable VMID reference & master bias */
 		snd_soc_update_bits(codec, DA7213_REFERENCES,
 				    DA7213_VMID_EN | DA7213_BIAS_EN, 0);
-
-		/* MCLK */
-		if (da7213->mclk)
-			clk_disable_unprepare(da7213->mclk);
 		break;
 	}
 	return 0;
@@ -1605,9 +1646,6 @@
 			    DA7213_ALC_CALIB_MODE_MAN, 0);
 	da7213->alc_calib_auto = true;
 
-	/* Default to using SRM for slave mode */
-	da7213->srm_en = true;
-
 	/* Default PC counter to free-running */
 	snd_soc_update_bits(codec, DA7213_PC_COUNT, DA7213_PC_FREERUN_MASK,
 			    DA7213_PC_FREERUN_MASK);
@@ -1740,13 +1778,14 @@
 	.probe			= da7213_probe,
 	.set_bias_level		= da7213_set_bias_level,
 
+	.component_driver = {
 	.controls		= da7213_snd_controls,
 	.num_controls		= ARRAY_SIZE(da7213_snd_controls),
-
 	.dapm_widgets		= da7213_dapm_widgets,
 	.num_dapm_widgets	= ARRAY_SIZE(da7213_dapm_widgets),
 	.dapm_routes		= da7213_audio_map,
 	.num_dapm_routes	= ARRAY_SIZE(da7213_audio_map),
+	},
 };
 
 static const struct regmap_config da7213_regmap_config = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/da7213.h linux-4.8-rc4.orig/sound/soc/codecs/da7213.h
--- linux-4.8-rc4.new/sound/soc/codecs/da7213.h	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/da7213.h	2016-09-04 01:14:31.700288254 +0000
@@ -172,6 +172,7 @@
 #define DA7213_PLL_32K_MODE					(0x1 << 5)
 #define DA7213_PLL_SRM_EN					(0x1 << 6)
 #define DA7213_PLL_EN						(0x1 << 7)
+#define DA7213_PLL_MODE_MASK					(0x7 << 5)
 
 /* DA7213_DAI_CLK_MODE = 0x28 */
 #define DA7213_DAI_BCLKS_PER_WCLK_32				(0x0 << 0)
@@ -499,8 +500,6 @@
 #define DA7213_ALC_AVG_ITERATIONS	5
 
 /* PLL related */
-#define DA7213_SYSCLK_MCLK			0
-#define DA7213_SYSCLK_PLL			1
 #define DA7213_PLL_FREQ_OUT_90316800		90316800
 #define DA7213_PLL_FREQ_OUT_98304000		98304000
 #define DA7213_PLL_FREQ_OUT_94310400		94310400
@@ -515,6 +514,13 @@
 	DA7213_CLKSRC_MCLK_SQR,
 };
 
+enum da7213_sys_clk {
+	DA7213_SYSCLK_MCLK = 0,
+	DA7213_SYSCLK_PLL,
+	DA7213_SYSCLK_PLL_SRM,
+	DA7213_SYSCLK_PLL_32KHZ
+};
+
 /* Codec private data */
 struct da7213_priv {
 	struct regmap *regmap;
@@ -522,8 +528,6 @@
 	unsigned int mclk_rate;
 	int clk_src;
 	bool master;
-	bool mclk_squarer_en;
-	bool srm_en;
 	bool alc_calib_auto;
 	bool alc_en;
 	struct da7213_platform_data *pdata;
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/da7218.c linux-4.8-rc4.orig/sound/soc/codecs/da7218.c
--- linux-4.8-rc4.new/sound/soc/codecs/da7218.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/da7218.c	2016-09-04 01:14:37.728069484 +0000
@@ -1819,7 +1819,7 @@
 	if (da7218->mclk_rate == freq)
 		return 0;
 
-	if (((freq < 2000000) && (freq != 32768)) || (freq > 54000000)) {
+	if ((freq < 2000000) || (freq > 54000000)) {
 		dev_err(codec_dai->dev, "Unsupported MCLK value %d\n",
 			freq);
 		return -EINVAL;
@@ -1866,11 +1866,8 @@
 	u32 freq_ref;
 	u64 frac_div;
 
-	/* Verify 32KHz, 2MHz - 54MHz MCLK provided, and set input divider */
-	if (da7218->mclk_rate == 32768) {
-		indiv_bits = DA7218_PLL_INDIV_9_TO_18_MHZ;
-		indiv = DA7218_PLL_INDIV_9_TO_18_MHZ_VAL;
-	} else if (da7218->mclk_rate < 2000000) {
+	/* Verify 2MHz - 54MHz MCLK provided, and set input divider */
+	if (da7218->mclk_rate < 2000000) {
 		dev_err(codec->dev, "PLL input clock %d below valid range\n",
 			da7218->mclk_rate);
 		return -EINVAL;
@@ -1911,9 +1908,6 @@
 	case DA7218_SYSCLK_PLL_SRM:
 		pll_ctrl |= DA7218_PLL_MODE_SRM;
 		break;
-	case DA7218_SYSCLK_PLL_32KHZ:
-		pll_ctrl |= DA7218_PLL_MODE_32KHZ;
-		break;
 	default:
 		dev_err(codec->dev, "Invalid PLL config\n");
 		return -EINVAL;
@@ -2589,20 +2583,22 @@
 
 	switch (level) {
 	case SND_SOC_BIAS_ON:
-	case SND_SOC_BIAS_PREPARE:
 		break;
-	case SND_SOC_BIAS_STANDBY:
-		if (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF) {
-			/* MCLK */
+	case SND_SOC_BIAS_PREPARE:
+		/* Enable MCLK for transition to ON state */
+		if (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_STANDBY) {
 			if (da7218->mclk) {
 				ret = clk_prepare_enable(da7218->mclk);
 				if (ret) {
-					dev_err(codec->dev,
-						"Failed to enable mclk\n");
+					dev_err(codec->dev, "Failed to enable mclk\n");
 					return ret;
 				}
 			}
+		}
 
+		break;
+	case SND_SOC_BIAS_STANDBY:
+		if (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF) {
 			/* Master bias */
 			snd_soc_update_bits(codec, DA7218_REFERENCES,
 					    DA7218_BIAS_EN_MASK,
@@ -2612,6 +2608,10 @@
 			snd_soc_update_bits(codec, DA7218_LDO_CTRL,
 					    DA7218_LDO_EN_MASK,
 					    DA7218_LDO_EN_MASK);
+		} else {
+			/* Remove MCLK */
+			if (da7218->mclk)
+				clk_disable_unprepare(da7218->mclk);
 		}
 		break;
 	case SND_SOC_BIAS_OFF:
@@ -2625,10 +2625,6 @@
 			snd_soc_update_bits(codec, DA7218_REFERENCES,
 					    DA7218_BIAS_EN_MASK, 0);
 		}
-
-		/* MCLK */
-		if (da7218->mclk)
-			clk_disable_unprepare(da7218->mclk);
 		break;
 	}
 
@@ -3045,13 +3041,14 @@
 	.resume			= da7218_resume,
 	.set_bias_level		= da7218_set_bias_level,
 
+	.component_driver = {
 	.controls		= da7218_snd_controls,
 	.num_controls		= ARRAY_SIZE(da7218_snd_controls),
-
 	.dapm_widgets		= da7218_dapm_widgets,
 	.num_dapm_widgets	= ARRAY_SIZE(da7218_dapm_widgets),
 	.dapm_routes		= da7218_audio_map,
 	.num_dapm_routes	= ARRAY_SIZE(da7218_audio_map),
+	},
 };
 
 
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/da7218.h linux-4.8-rc4.orig/sound/soc/codecs/da7218.h
--- linux-4.8-rc4.new/sound/soc/codecs/da7218.h	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/da7218.h	2016-09-04 01:14:37.728069484 +0000
@@ -888,7 +888,6 @@
 #define DA7218_PLL_MODE_BYPASS		(0x0 << 6)
 #define DA7218_PLL_MODE_NORMAL		(0x1 << 6)
 #define DA7218_PLL_MODE_SRM		(0x2 << 6)
-#define DA7218_PLL_MODE_32KHZ		(0x3 << 6)
 
 /* DA7218_PLL_FRAC_TOP = 0x92 */
 #define DA7218_PLL_FBDIV_FRAC_TOP_SHIFT	0
@@ -1371,7 +1370,6 @@
 	DA7218_SYSCLK_MCLK = 0,
 	DA7218_SYSCLK_PLL,
 	DA7218_SYSCLK_PLL_SRM,
-	DA7218_SYSCLK_PLL_32KHZ
 };
 
 enum da7218_dev_id {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/da7219-aad.c linux-4.8-rc4.orig/sound/soc/codecs/da7219-aad.c
--- linux-4.8-rc4.new/sound/soc/codecs/da7219-aad.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/da7219-aad.c	2016-09-04 01:14:31.712287819 +0000
@@ -13,6 +13,7 @@
 
 #include <linux/module.h>
 #include <linux/platform_device.h>
+#include <linux/clk.h>
 #include <linux/i2c.h>
 #include <linux/property.h>
 #include <linux/pm_wakeirq.h>
@@ -115,12 +116,23 @@
 
 	u16 tonegen_freq_hptest;
 	u8 accdet_cfg8;
-	int report = 0;
+	int report = 0, ret = 0;
 
 	/* Lock DAPM and any Kcontrols that are affected by this test */
 	snd_soc_dapm_mutex_lock(dapm);
 	mutex_lock(&da7219->lock);
 
+	/* Ensure MCLK is available for HP test procedure */
+	if (da7219->mclk) {
+		ret = clk_prepare_enable(da7219->mclk);
+		if (ret) {
+			dev_err(codec->dev, "Failed to enable mclk - %d\n", ret);
+			mutex_unlock(&da7219->lock);
+			snd_soc_dapm_mutex_unlock(dapm);
+			return;
+		}
+	}
+
 	/* Bypass cache so it saves current settings */
 	regcache_cache_bypass(da7219->regmap, true);
 
@@ -250,6 +262,10 @@
 	snd_soc_update_bits(codec, DA7219_HP_R_CTRL, DA7219_HP_R_AMP_OE_MASK,
 			    DA7219_HP_R_AMP_OE_MASK);
 
+	/* Remove MCLK, if previously enabled */
+	if (da7219->mclk)
+		clk_disable_unprepare(da7219->mclk);
+
 	mutex_unlock(&da7219->lock);
 	snd_soc_dapm_mutex_unlock(dapm);
 
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/da7219.c linux-4.8-rc4.orig/sound/soc/codecs/da7219.c
--- linux-4.8-rc4.new/sound/soc/codecs/da7219.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/da7219.c	2016-09-04 01:14:36.196125084 +0000
@@ -1508,11 +1508,10 @@
 
 	switch (level) {
 	case SND_SOC_BIAS_ON:
-	case SND_SOC_BIAS_PREPARE:
 		break;
-	case SND_SOC_BIAS_STANDBY:
-		if (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF) {
-			/* MCLK */
+	case SND_SOC_BIAS_PREPARE:
+		/* Enable MCLK for transition to ON state */
+		if (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_STANDBY) {
 			if (da7219->mclk) {
 				ret = clk_prepare_enable(da7219->mclk);
 				if (ret) {
@@ -1521,11 +1520,19 @@
 					return ret;
 				}
 			}
+		}
 
+		break;
+	case SND_SOC_BIAS_STANDBY:
+		if (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF) {
 			/* Master bias */
 			snd_soc_update_bits(codec, DA7219_REFERENCES,
 					    DA7219_BIAS_EN_MASK,
 					    DA7219_BIAS_EN_MASK);
+		} else {
+			/* Remove MCLK */
+			if (da7219->mclk)
+				clk_disable_unprepare(da7219->mclk);
 		}
 		break;
 	case SND_SOC_BIAS_OFF:
@@ -1534,9 +1541,6 @@
 			snd_soc_update_bits(codec, DA7219_REFERENCES,
 					    DA7219_BIAS_EN_MASK, 0);
 
-		/* MCLK */
-		if (da7219->mclk)
-			clk_disable_unprepare(da7219->mclk);
 		break;
 	}
 
@@ -1767,13 +1771,14 @@
 	.resume			= da7219_resume,
 	.set_bias_level		= da7219_set_bias_level,
 
+	.component_driver = {
 	.controls		= da7219_snd_controls,
 	.num_controls		= ARRAY_SIZE(da7219_snd_controls),
-
 	.dapm_widgets		= da7219_dapm_widgets,
 	.num_dapm_widgets	= ARRAY_SIZE(da7219_dapm_widgets),
 	.dapm_routes		= da7219_audio_map,
 	.num_dapm_routes	= ARRAY_SIZE(da7219_audio_map),
+	},
 };
 
 
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/da732x.c linux-4.8-rc4.orig/sound/soc/codecs/da732x.c
--- linux-4.8-rc4.new/sound/soc/codecs/da732x.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/da732x.c	2016-09-04 01:14:36.496114197 +0000
@@ -1501,12 +1501,14 @@
 
 static struct snd_soc_codec_driver soc_codec_dev_da732x = {
 	.set_bias_level		= da732x_set_bias_level,
+	.component_driver = {
 	.controls		= da732x_snd_controls,
 	.num_controls		= ARRAY_SIZE(da732x_snd_controls),
 	.dapm_widgets		= da732x_dapm_widgets,
 	.num_dapm_widgets	= ARRAY_SIZE(da732x_dapm_widgets),
 	.dapm_routes		= da732x_dapm_routes,
 	.num_dapm_routes	= ARRAY_SIZE(da732x_dapm_routes),
+	},
 	.set_pll		= da732x_set_dai_pll,
 };
 
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/da9055.c linux-4.8-rc4.orig/sound/soc/codecs/da9055.c
--- linux-4.8-rc4.new/sound/soc/codecs/da9055.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/da9055.c	2016-09-04 01:14:36.664108099 +0000
@@ -1455,13 +1455,14 @@
 	.probe			= da9055_probe,
 	.set_bias_level		= da9055_set_bias_level,
 
+	.component_driver = {
 	.controls		= da9055_snd_controls,
 	.num_controls		= ARRAY_SIZE(da9055_snd_controls),
-
 	.dapm_widgets		= da9055_dapm_widgets,
 	.num_dapm_widgets	= ARRAY_SIZE(da9055_dapm_widgets),
 	.dapm_routes		= da9055_audio_map,
 	.num_dapm_routes	= ARRAY_SIZE(da9055_audio_map),
+	},
 };
 
 static const struct regmap_config da9055_regmap_config = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/dmic.c linux-4.8-rc4.orig/sound/soc/codecs/dmic.c
--- linux-4.8-rc4.new/sound/soc/codecs/dmic.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/dmic.c	2016-09-04 01:14:36.720106067 +0000
@@ -51,10 +51,12 @@
 };
 
 static struct snd_soc_codec_driver soc_dmic = {
+	.component_driver = {
 	.dapm_widgets = dmic_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(dmic_dapm_widgets),
 	.dapm_routes = intercon,
 	.num_dapm_routes = ARRAY_SIZE(intercon),
+	},
 };
 
 static int dmic_dev_probe(struct platform_device *pdev)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/es8328.c linux-4.8-rc4.orig/sound/soc/codecs/es8328.c
--- linux-4.8-rc4.new/sound/soc/codecs/es8328.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/es8328.c	2016-09-04 01:14:32.728250945 +0000
@@ -823,12 +823,14 @@
 	.set_bias_level	  = es8328_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
 	.controls	  = es8328_snd_controls,
 	.num_controls	  = ARRAY_SIZE(es8328_snd_controls),
 	.dapm_widgets	  = es8328_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(es8328_dapm_widgets),
 	.dapm_routes	  = es8328_dapm_routes,
 	.num_dapm_routes  = ARRAY_SIZE(es8328_dapm_routes),
+	},
 };
 
 int es8328_probe(struct device *dev, struct regmap *regmap)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/gtm601.c linux-4.8-rc4.orig/sound/soc/codecs/gtm601.c
--- linux-4.8-rc4.new/sound/soc/codecs/gtm601.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/gtm601.c	2016-09-04 01:14:32.724251090 +0000
@@ -52,10 +52,12 @@
 };
 
 static const struct snd_soc_codec_driver soc_codec_dev_gtm601 = {
+	.component_driver = {
 	.dapm_widgets = gtm601_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(gtm601_dapm_widgets),
 	.dapm_routes = gtm601_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(gtm601_dapm_routes),
+	},
 };
 
 static int gtm601_platform_probe(struct platform_device *pdev)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/hdmi-codec.c linux-4.8-rc4.orig/sound/soc/codecs/hdmi-codec.c
--- linux-4.8-rc4.new/sound/soc/codecs/hdmi-codec.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/hdmi-codec.c	2016-09-04 01:14:36.764104470 +0000
@@ -24,6 +24,15 @@
 
 #include <drm/drm_crtc.h> /* This is only to get MAX_ELD_BYTES */
 
+struct hdmi_device {
+	struct device *dev;
+	struct list_head list;
+	int cnt;
+};
+#define pos_to_hdmi_device(pos)	container_of((pos), struct hdmi_device, list)
+LIST_HEAD(hdmi_device_list);
+
+#define DAI_NAME_SIZE 16
 struct hdmi_codec_priv {
 	struct hdmi_codec_pdata hcd;
 	struct snd_soc_dai_driver *daidrv;
@@ -320,7 +329,6 @@
 			 SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_S32_BE)
 
 static struct snd_soc_dai_driver hdmi_i2s_dai = {
-	.name = "i2s-hifi",
 	.id = DAI_ID_I2S,
 	.playback = {
 		.stream_name = "Playback",
@@ -334,7 +342,6 @@
 };
 
 static const struct snd_soc_dai_driver hdmi_spdif_dai = {
-	.name = "spdif-hifi",
 	.id = DAI_ID_SPDIF,
 	.playback = {
 		.stream_name = "Playback",
@@ -346,13 +353,37 @@
 	.ops = &hdmi_dai_ops,
 };
 
+static char hdmi_dai_name[][DAI_NAME_SIZE] = {
+	"hdmi-hifi.0",
+	"hdmi-hifi.1",
+	"hdmi-hifi.2",
+	"hdmi-hifi.3",
+};
+
+static int hdmi_of_xlate_dai_name(struct snd_soc_component *component,
+				  struct of_phandle_args *args,
+				  const char **dai_name)
+{
+	int id = args->args[0];
+
+	if (id < ARRAY_SIZE(hdmi_dai_name)) {
+		*dai_name = hdmi_dai_name[id];
+		return 0;
+	}
+
+	return -EAGAIN;
+}
+
 static struct snd_soc_codec_driver hdmi_codec = {
+	.component_driver = {
 	.controls = hdmi_controls,
 	.num_controls = ARRAY_SIZE(hdmi_controls),
 	.dapm_widgets = hdmi_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(hdmi_widgets),
 	.dapm_routes = hdmi_routes,
 	.num_dapm_routes = ARRAY_SIZE(hdmi_routes),
+		.of_xlate_dai_name	= hdmi_of_xlate_dai_name,
+	},
 };
 
 static int hdmi_codec_probe(struct platform_device *pdev)
@@ -360,6 +391,8 @@
 	struct hdmi_codec_pdata *hcd = pdev->dev.platform_data;
 	struct device *dev = &pdev->dev;
 	struct hdmi_codec_priv *hcp;
+	struct hdmi_device *hd;
+	struct list_head *pos;
 	int dai_count, i = 0;
 	int ret;
 
@@ -381,6 +414,31 @@
 	if (!hcp)
 		return -ENOMEM;
 
+	hd = NULL;
+	list_for_each(pos, &hdmi_device_list) {
+		struct hdmi_device *tmp = pos_to_hdmi_device(pos);
+
+		if (tmp->dev == dev->parent) {
+			hd = tmp;
+			break;
+		}
+	}
+
+	if (!hd) {
+		hd = devm_kzalloc(dev, sizeof(*hd), GFP_KERNEL);
+		if (!hd)
+			return -ENOMEM;
+
+		hd->dev = dev->parent;
+
+		list_add_tail(&hd->list, &hdmi_device_list);
+	}
+
+	if (hd->cnt >= ARRAY_SIZE(hdmi_dai_name)) {
+		dev_err(dev, "too many hdmi codec are deteced\n");
+		return -EINVAL;
+	}
+
 	hcp->hcd = *hcd;
 	mutex_init(&hcp->current_stream_lock);
 
@@ -393,11 +451,14 @@
 		hcp->daidrv[i] = hdmi_i2s_dai;
 		hcp->daidrv[i].playback.channels_max =
 			hcd->max_i2s_channels;
+		hcp->daidrv[i].name = hdmi_dai_name[hd->cnt++];
 		i++;
 	}
 
-	if (hcd->spdif)
+	if (hcd->spdif) {
 		hcp->daidrv[i] = hdmi_spdif_dai;
+		hcp->daidrv[i].name = hdmi_dai_name[hd->cnt++];
+	}
 
 	ret = snd_soc_register_codec(dev, &hdmi_codec, hcp->daidrv,
 				     dai_count);
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/inno_rk3036.c linux-4.8-rc4.orig/sound/soc/codecs/inno_rk3036.c
--- linux-4.8-rc4.new/sound/soc/codecs/inno_rk3036.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/inno_rk3036.c	2016-09-04 01:14:32.720251236 +0000
@@ -380,12 +380,14 @@
 	.probe			= rk3036_codec_probe,
 	.remove			= rk3036_codec_remove,
 	.set_bias_level		= rk3036_codec_set_bias_level,
+	.component_driver = {
 	.controls		= rk3036_codec_dapm_controls,
 	.num_controls		= ARRAY_SIZE(rk3036_codec_dapm_controls),
 	.dapm_routes		= rk3036_codec_dapm_routes,
 	.num_dapm_routes	= ARRAY_SIZE(rk3036_codec_dapm_routes),
 	.dapm_widgets		= rk3036_codec_dapm_widgets,
 	.num_dapm_widgets	= ARRAY_SIZE(rk3036_codec_dapm_widgets),
+	},
 };
 
 static const struct regmap_config rk3036_codec_regmap_config = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/isabelle.c linux-4.8-rc4.orig/sound/soc/codecs/isabelle.c
--- linux-4.8-rc4.new/sound/soc/codecs/isabelle.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/isabelle.c	2016-09-04 01:14:36.780103889 +0000
@@ -1089,12 +1089,14 @@
 
 static struct snd_soc_codec_driver soc_codec_dev_isabelle = {
 	.set_bias_level = isabelle_set_bias_level,
+	.component_driver = {
 	.controls = isabelle_snd_controls,
 	.num_controls = ARRAY_SIZE(isabelle_snd_controls),
 	.dapm_widgets = isabelle_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(isabelle_dapm_widgets),
 	.dapm_routes = isabelle_intercon,
 	.num_dapm_routes = ARRAY_SIZE(isabelle_intercon),
+	},
 	.idle_bias_off = true,
 };
 
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/jz4740.c linux-4.8-rc4.orig/sound/soc/codecs/jz4740.c
--- linux-4.8-rc4.new/sound/soc/codecs/jz4740.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/jz4740.c	2016-09-04 01:14:36.780103889 +0000
@@ -298,12 +298,14 @@
 	.set_bias_level = jz4740_codec_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
 	.controls = jz4740_codec_controls,
 	.num_controls = ARRAY_SIZE(jz4740_codec_controls),
 	.dapm_widgets = jz4740_codec_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(jz4740_codec_dapm_widgets),
 	.dapm_routes = jz4740_codec_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(jz4740_codec_dapm_routes),
+	},
 };
 
 static const struct regmap_config jz4740_codec_regmap_config = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/Kconfig linux-4.8-rc4.orig/sound/soc/codecs/Kconfig
--- linux-4.8-rc4.new/sound/soc/codecs/Kconfig	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/Kconfig	2016-09-04 01:14:51.627565022 +0000
@@ -92,6 +92,7 @@
 	select SND_SOC_MAX9877 if I2C
 	select SND_SOC_MC13783 if MFD_MC13XXX
 	select SND_SOC_ML26124 if I2C
+	select SND_SOC_NAU8810 if I2C
 	select SND_SOC_NAU8825 if I2C
 	select SND_SOC_HDMI_CODEC
 	select SND_SOC_PCM1681 if I2C
@@ -1064,6 +1065,10 @@
 config SND_SOC_ML26124
 	tristate
 
+config SND_SOC_NAU8810
+	tristate "Nuvoton Technology Corporation NAU88C10 CODEC"
+	depends on I2C
+
 config SND_SOC_NAU8825
 	tristate
 
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/l3.c linux-4.8-rc4.orig/sound/soc/codecs/l3.c
--- linux-4.8-rc4.new/sound/soc/codecs/l3.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/l3.c	2016-09-04 01:14:32.036276060 +0000
@@ -20,6 +20,8 @@
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/gpio.h>
 
 #include <sound/l3.h>
 
@@ -32,11 +34,11 @@
 	int i;
 
 	for (i = 0; i < 8; i++) {
-		adap->setclk(0);
+		adap->setclk(adap, 0);
 		udelay(adap->data_hold);
-		adap->setdat(byte & 1);
+		adap->setdat(adap, byte & 1);
 		udelay(adap->data_setup);
-		adap->setclk(1);
+		adap->setclk(adap, 1);
 		udelay(adap->clock_high);
 		byte >>= 1;
 	}
@@ -55,10 +57,10 @@
 	for (i = 0; i < len; i++) {
 		if (i) {
 			udelay(adap->mode_hold);
-			adap->setmode(0);
+			adap->setmode(adap, 0);
 			udelay(adap->mode);
 		}
-		adap->setmode(1);
+		adap->setmode(adap, 1);
 		udelay(adap->mode_setup);
 		sendbyte(adap, buf[i]);
 	}
@@ -66,26 +68,71 @@
 
 int l3_write(struct l3_pins *adap, u8 addr, u8 *data, int len)
 {
-	adap->setclk(1);
-	adap->setdat(1);
-	adap->setmode(1);
+	adap->setclk(adap, 1);
+	adap->setdat(adap, 1);
+	adap->setmode(adap, 1);
 	udelay(adap->mode);
 
-	adap->setmode(0);
+	adap->setmode(adap, 0);
 	udelay(adap->mode_setup);
 	sendbyte(adap, addr);
 	udelay(adap->mode_hold);
 
 	sendbytes(adap, data, len);
 
-	adap->setclk(1);
-	adap->setdat(1);
-	adap->setmode(0);
+	adap->setclk(adap, 1);
+	adap->setdat(adap, 1);
+	adap->setmode(adap, 0);
 
 	return len;
 }
 EXPORT_SYMBOL_GPL(l3_write);
 
+
+static void l3_set_clk(struct l3_pins *adap, int val)
+{
+	gpio_set_value(adap->gpio_clk, val);
+}
+
+static void l3_set_data(struct l3_pins *adap, int val)
+{
+	gpio_set_value(adap->gpio_data, val);
+}
+
+static void l3_set_mode(struct l3_pins *adap, int val)
+{
+	gpio_set_value(adap->gpio_mode, val);
+}
+
+int l3_set_gpio_ops(struct device *dev, struct l3_pins *adap)
+{
+	int ret;
+
+	if (!adap->use_gpios)
+		return -EINVAL;
+
+	ret = devm_gpio_request_one(dev, adap->gpio_data,
+				GPIOF_OUT_INIT_LOW, "l3_data");
+	if (ret < 0)
+		return ret;
+	adap->setdat = l3_set_data;
+
+	ret = devm_gpio_request_one(dev, adap->gpio_clk,
+				GPIOF_OUT_INIT_LOW, "l3_clk");
+	if (ret < 0)
+		return ret;
+	adap->setclk = l3_set_clk;
+
+	ret = devm_gpio_request_one(dev, adap->gpio_mode,
+				GPIOF_OUT_INIT_LOW, "l3_mode");
+	if (ret < 0)
+		return ret;
+	adap->setmode = l3_set_mode;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(l3_set_gpio_ops);
+
 MODULE_DESCRIPTION("L3 bit-banging driver");
 MODULE_AUTHOR("Christian Pellegrin <chripell@evolware.org>");
 MODULE_LICENSE("GPL");
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/lm49453.c linux-4.8-rc4.orig/sound/soc/codecs/lm49453.c
--- linux-4.8-rc4.new/sound/soc/codecs/lm49453.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/lm49453.c	2016-09-04 01:14:36.788103599 +0000
@@ -1391,12 +1391,14 @@
 
 static struct snd_soc_codec_driver soc_codec_dev_lm49453 = {
 	.set_bias_level = lm49453_set_bias_level,
+	.component_driver = {
 	.controls = lm49453_snd_controls,
 	.num_controls = ARRAY_SIZE(lm49453_snd_controls),
 	.dapm_widgets = lm49453_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(lm49453_dapm_widgets),
 	.dapm_routes = lm49453_audio_map,
 	.num_dapm_routes = ARRAY_SIZE(lm49453_audio_map),
+	},
 	.idle_bias_off = true,
 };
 
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/Makefile linux-4.8-rc4.orig/sound/soc/codecs/Makefile
--- linux-4.8-rc4.new/sound/soc/codecs/Makefile	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/Makefile	2016-09-04 01:14:51.631564877 +0000
@@ -86,6 +86,7 @@
 snd-soc-max9860-objs := max9860.o
 snd-soc-mc13783-objs := mc13783.o
 snd-soc-ml26124-objs := ml26124.o
+snd-soc-nau8810-objs := nau8810.o
 snd-soc-nau8825-objs := nau8825.o
 snd-soc-hdmi-codec-objs := hdmi-codec.o
 snd-soc-pcm1681-objs := pcm1681.o
@@ -307,6 +308,7 @@
 obj-$(CONFIG_SND_SOC_MAX9860)	+= snd-soc-max9860.o
 obj-$(CONFIG_SND_SOC_MC13783)	+= snd-soc-mc13783.o
 obj-$(CONFIG_SND_SOC_ML26124)	+= snd-soc-ml26124.o
+obj-$(CONFIG_SND_SOC_NAU8810)   += snd-soc-nau8810.o
 obj-$(CONFIG_SND_SOC_NAU8825)   += snd-soc-nau8825.o
 obj-$(CONFIG_SND_SOC_HDMI_CODEC)	+= snd-soc-hdmi-codec.o
 obj-$(CONFIG_SND_SOC_PCM1681)	+= snd-soc-pcm1681.o
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/max98088.c linux-4.8-rc4.orig/sound/soc/codecs/max98088.c
--- linux-4.8-rc4.new/sound/soc/codecs/max98088.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/max98088.c	2016-09-04 01:14:36.796103309 +0000
@@ -1704,12 +1704,14 @@
 	.set_bias_level = max98088_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
 	.controls = max98088_snd_controls,
 	.num_controls = ARRAY_SIZE(max98088_snd_controls),
 	.dapm_widgets = max98088_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(max98088_dapm_widgets),
 	.dapm_routes = max98088_audio_map,
 	.num_dapm_routes = ARRAY_SIZE(max98088_audio_map),
+	},
 };
 
 static int max98088_i2c_probe(struct i2c_client *i2c,
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/max98095.c linux-4.8-rc4.orig/sound/soc/codecs/max98095.c
--- linux-4.8-rc4.new/sound/soc/codecs/max98095.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/max98095.c	2016-09-04 01:14:36.804103018 +0000
@@ -2108,12 +2108,14 @@
 	.suspend = max98095_suspend,
 	.resume  = max98095_resume,
 	.set_bias_level = max98095_set_bias_level,
+	.component_driver = {
 	.controls = max98095_snd_controls,
 	.num_controls = ARRAY_SIZE(max98095_snd_controls),
 	.dapm_widgets	  = max98095_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(max98095_dapm_widgets),
 	.dapm_routes     = max98095_audio_map,
 	.num_dapm_routes = ARRAY_SIZE(max98095_audio_map),
+	},
 };
 
 static int max98095_i2c_probe(struct i2c_client *i2c,
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/max98357a.c linux-4.8-rc4.orig/sound/soc/codecs/max98357a.c
--- linux-4.8-rc4.new/sound/soc/codecs/max98357a.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/max98357a.c	2016-09-04 01:14:36.804103018 +0000
@@ -74,10 +74,12 @@
 
 static struct snd_soc_codec_driver max98357a_codec_driver = {
 	.probe			= max98357a_codec_probe,
+	.component_driver = {
 	.dapm_widgets		= max98357a_dapm_widgets,
 	.num_dapm_widgets	= ARRAY_SIZE(max98357a_dapm_widgets),
 	.dapm_routes		= max98357a_dapm_routes,
 	.num_dapm_routes	= ARRAY_SIZE(max98357a_dapm_routes),
+	},
 };
 
 static const struct snd_soc_dai_ops max98357a_dai_ops = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/max98371.c linux-4.8-rc4.orig/sound/soc/codecs/max98371.c
--- linux-4.8-rc4.new/sound/soc/codecs/max98371.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/max98371.c	2016-09-04 01:14:45.223797438 +0000
@@ -426,7 +426,6 @@
 static struct i2c_driver max98371_i2c_driver = {
 	.driver = {
 		.name = "max98371",
-		.owner = THIS_MODULE,
 		.pm = NULL,
 		.of_match_table = of_match_ptr(max98371_of_match),
 	},
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/max9850.c linux-4.8-rc4.orig/sound/soc/codecs/max9850.c
--- linux-4.8-rc4.new/sound/soc/codecs/max9850.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/max9850.c	2016-09-04 01:14:36.808102873 +0000
@@ -306,12 +306,14 @@
 	.set_bias_level = max9850_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
 	.controls = max9850_controls,
 	.num_controls = ARRAY_SIZE(max9850_controls),
 	.dapm_widgets = max9850_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(max9850_dapm_widgets),
 	.dapm_routes = max9850_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(max9850_dapm_routes),
+	},
 };
 
 static int max9850_i2c_probe(struct i2c_client *i2c,
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/max9860.c linux-4.8-rc4.orig/sound/soc/codecs/max9860.c
--- linux-4.8-rc4.new/sound/soc/codecs/max9860.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/max9860.c	2016-09-04 01:14:32.716251380 +0000
@@ -538,12 +538,14 @@
 	.set_bias_level = max9860_set_bias_level,
 	.idle_bias_off = true,
 
+	.component_driver = {
 	.controls = max9860_controls,
 	.num_controls = ARRAY_SIZE(max9860_controls),
 	.dapm_widgets = max9860_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(max9860_dapm_widgets),
 	.dapm_routes = max9860_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(max9860_dapm_routes),
+	},
 };
 
 #ifdef CONFIG_PM
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/max9867.c linux-4.8-rc4.orig/sound/soc/codecs/max9867.c
--- linux-4.8-rc4.new/sound/soc/codecs/max9867.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/max9867.c	2016-09-04 01:14:36.812102728 +0000
@@ -417,12 +417,14 @@
 
 static struct snd_soc_codec_driver max9867_codec = {
 	.probe = max9867_probe,
+	.component_driver = {
 	.controls = max9867_snd_controls,
 	.num_controls = ARRAY_SIZE(max9867_snd_controls),
 	.dapm_routes = max9867_audio_map,
 	.num_dapm_routes = ARRAY_SIZE(max9867_audio_map),
 	.dapm_widgets = max9867_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(max9867_dapm_widgets),
+	},
 };
 
 static bool max9867_volatile_register(struct device *dev, unsigned int reg)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/max98925.c linux-4.8-rc4.orig/sound/soc/codecs/max98925.c
--- linux-4.8-rc4.new/sound/soc/codecs/max98925.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/max98925.c	2016-09-04 01:14:36.816102583 +0000
@@ -540,12 +540,14 @@
 
 static const struct snd_soc_codec_driver soc_codec_dev_max98925 = {
 	.probe            = max98925_probe,
+	.component_driver = {
 	.controls = max98925_snd_controls,
 	.num_controls = ARRAY_SIZE(max98925_snd_controls),
 	.dapm_routes = max98925_audio_map,
 	.num_dapm_routes = ARRAY_SIZE(max98925_audio_map),
 	.dapm_widgets = max98925_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(max98925_dapm_widgets),
+	},
 };
 
 static const struct regmap_config max98925_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/max98926.c linux-4.8-rc4.orig/sound/soc/codecs/max98926.c
--- linux-4.8-rc4.new/sound/soc/codecs/max98926.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/max98926.c	2016-09-04 01:14:36.820102438 +0000
@@ -498,12 +498,14 @@
 
 static struct snd_soc_codec_driver soc_codec_dev_max98926 = {
 	.probe	= max98926_probe,
+	.component_driver = {
 	.controls = max98926_snd_controls,
 	.num_controls = ARRAY_SIZE(max98926_snd_controls),
 	.dapm_routes = max98926_audio_map,
 	.num_dapm_routes = ARRAY_SIZE(max98926_audio_map),
 	.dapm_widgets = max98926_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(max98926_dapm_widgets),
+	},
 };
 
 static const struct regmap_config max98926_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/mc13783.c linux-4.8-rc4.orig/sound/soc/codecs/mc13783.c
--- linux-4.8-rc4.new/sound/soc/codecs/mc13783.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/mc13783.c	2016-09-04 01:14:36.824102292 +0000
@@ -737,12 +737,14 @@
 	.probe		= mc13783_probe,
 	.remove		= mc13783_remove,
 	.get_regmap	= mc13783_get_regmap,
+	.component_driver = {
 	.controls	= mc13783_control_list,
 	.num_controls	= ARRAY_SIZE(mc13783_control_list),
 	.dapm_widgets	= mc13783_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(mc13783_dapm_widgets),
 	.dapm_routes	= mc13783_routes,
 	.num_dapm_routes = ARRAY_SIZE(mc13783_routes),
+	},
 };
 
 static int __init mc13783_codec_probe(struct platform_device *pdev)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/ml26124.c linux-4.8-rc4.orig/sound/soc/codecs/ml26124.c
--- linux-4.8-rc4.new/sound/soc/codecs/ml26124.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/ml26124.c	2016-09-04 01:14:36.828102147 +0000
@@ -541,12 +541,14 @@
 	.probe =	ml26124_probe,
 	.set_bias_level = ml26124_set_bias_level,
 	.suspend_bias_off = true,
+	.component_driver = {
+		.controls		= ml26124_snd_controls,
+		.num_controls		= ARRAY_SIZE(ml26124_snd_controls),
 	.dapm_widgets = ml26124_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(ml26124_dapm_widgets),
 	.dapm_routes = ml26124_intercon,
 	.num_dapm_routes = ARRAY_SIZE(ml26124_intercon),
-	.controls = ml26124_snd_controls,
-	.num_controls = ARRAY_SIZE(ml26124_snd_controls),
+	},
 };
 
 static const struct regmap_config ml26124_i2c_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/nau8825.c linux-4.8-rc4.orig/sound/soc/codecs/nau8825.c
--- linux-4.8-rc4.new/sound/soc/codecs/nau8825.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/nau8825.c	2016-09-04 01:14:36.844101567 +0000
@@ -2256,12 +2256,14 @@
 	.suspend = nau8825_suspend,
 	.resume = nau8825_resume,
 
+	.component_driver = {
 	.controls = nau8825_controls,
 	.num_controls = ARRAY_SIZE(nau8825_controls),
 	.dapm_widgets = nau8825_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(nau8825_dapm_widgets),
 	.dapm_routes = nau8825_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(nau8825_dapm_routes),
+	},
 };
 
 static void nau8825_reset_chip(struct regmap *regmap)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/pcm1681.c linux-4.8-rc4.orig/sound/soc/codecs/pcm1681.c
--- linux-4.8-rc4.new/sound/soc/codecs/pcm1681.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/pcm1681.c	2016-09-04 01:14:32.712251526 +0000
@@ -289,12 +289,14 @@
 };
 
 static struct snd_soc_codec_driver soc_codec_dev_pcm1681 = {
+	.component_driver = {
 	.controls		= pcm1681_controls,
 	.num_controls		= ARRAY_SIZE(pcm1681_controls),
 	.dapm_widgets		= pcm1681_dapm_widgets,
 	.num_dapm_widgets	= ARRAY_SIZE(pcm1681_dapm_widgets),
 	.dapm_routes		= pcm1681_dapm_routes,
 	.num_dapm_routes	= ARRAY_SIZE(pcm1681_dapm_routes),
+	},
 };
 
 static const struct i2c_device_id pcm1681_i2c_id[] = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/pcm179x.c linux-4.8-rc4.orig/sound/soc/codecs/pcm179x.c
--- linux-4.8-rc4.new/sound/soc/codecs/pcm179x.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/pcm179x.c	2016-09-04 01:14:32.704251816 +0000
@@ -206,12 +206,14 @@
 EXPORT_SYMBOL_GPL(pcm179x_regmap_config);
 
 static struct snd_soc_codec_driver soc_codec_dev_pcm179x = {
+	.component_driver = {
 	.controls		= pcm179x_controls,
 	.num_controls		= ARRAY_SIZE(pcm179x_controls),
 	.dapm_widgets		= pcm179x_dapm_widgets,
 	.num_dapm_widgets	= ARRAY_SIZE(pcm179x_dapm_widgets),
 	.dapm_routes		= pcm179x_dapm_routes,
 	.num_dapm_routes	= ARRAY_SIZE(pcm179x_dapm_routes),
+	},
 };
 
 int pcm179x_common_init(struct device *dev, struct regmap *regmap)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/pcm3008.c linux-4.8-rc4.orig/sound/soc/codecs/pcm3008.c
--- linux-4.8-rc4.new/sound/soc/codecs/pcm3008.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/pcm3008.c	2016-09-04 01:14:36.852101276 +0000
@@ -99,10 +99,12 @@
 };
 
 static struct snd_soc_codec_driver soc_codec_dev_pcm3008 = {
+	.component_driver = {
 	.dapm_widgets = pcm3008_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(pcm3008_dapm_widgets),
 	.dapm_routes = pcm3008_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(pcm3008_dapm_routes),
+	},
 };
 
 static int pcm3008_codec_probe(struct platform_device *pdev)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/pcm3168a.c linux-4.8-rc4.orig/sound/soc/codecs/pcm3168a.c
--- linux-4.8-rc4.new/sound/soc/codecs/pcm3168a.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/pcm3168a.c	2016-09-04 01:14:32.700251961 +0000
@@ -599,12 +599,14 @@
 
 static const struct snd_soc_codec_driver pcm3168a_driver = {
 	.idle_bias_off = true,
+	.component_driver = {
 	.controls = pcm3168a_snd_controls,
 	.num_controls = ARRAY_SIZE(pcm3168a_snd_controls),
 	.dapm_widgets = pcm3168a_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(pcm3168a_dapm_widgets),
 	.dapm_routes = pcm3168a_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(pcm3168a_dapm_routes)
+	},
 };
 
 int pcm3168a_probe(struct device *dev, struct regmap *regmap)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/pcm512x.c linux-4.8-rc4.orig/sound/soc/codecs/pcm512x.c
--- linux-4.8-rc4.new/sound/soc/codecs/pcm512x.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/pcm512x.c	2016-09-04 01:14:32.696252107 +0000
@@ -1348,12 +1348,14 @@
 	.set_bias_level = pcm512x_set_bias_level,
 	.idle_bias_off = true,
 
+	.component_driver = {
 	.controls = pcm512x_controls,
 	.num_controls = ARRAY_SIZE(pcm512x_controls),
 	.dapm_widgets = pcm512x_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(pcm512x_dapm_widgets),
 	.dapm_routes = pcm512x_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(pcm512x_dapm_routes),
+	},
 };
 
 static const struct regmap_range_cfg pcm512x_range = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/rt286.c linux-4.8-rc4.orig/sound/soc/codecs/rt286.c
--- linux-4.8-rc4.new/sound/soc/codecs/rt286.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/rt286.c	2016-09-04 01:14:36.872100550 +0000
@@ -1053,12 +1053,14 @@
 	.resume = rt286_resume,
 	.set_bias_level = rt286_set_bias_level,
 	.idle_bias_off = true,
+	.component_driver = {
 	.controls = rt286_snd_controls,
 	.num_controls = ARRAY_SIZE(rt286_snd_controls),
 	.dapm_widgets = rt286_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(rt286_dapm_widgets),
 	.dapm_routes = rt286_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(rt286_dapm_routes),
+	},
 };
 
 static const struct regmap_config rt286_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/rt298.c linux-4.8-rc4.orig/sound/soc/codecs/rt298.c
--- linux-4.8-rc4.new/sound/soc/codecs/rt298.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/rt298.c	2016-09-04 01:14:36.912099099 +0000
@@ -1095,12 +1095,14 @@
 	.resume = rt298_resume,
 	.set_bias_level = rt298_set_bias_level,
 	.idle_bias_off = true,
+	.component_driver = {
 	.controls = rt298_snd_controls,
 	.num_controls = ARRAY_SIZE(rt298_snd_controls),
 	.dapm_widgets = rt298_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(rt298_dapm_widgets),
 	.dapm_routes = rt298_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(rt298_dapm_routes),
+	},
 };
 
 static const struct regmap_config rt298_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/rt5514.c linux-4.8-rc4.orig/sound/soc/codecs/rt5514.c
--- linux-4.8-rc4.new/sound/soc/codecs/rt5514.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/rt5514.c	2016-09-04 01:14:36.944097937 +0000
@@ -1023,12 +1023,14 @@
 	.probe = rt5514_probe,
 	.idle_bias_off = true,
 	.set_bias_level = rt5514_set_bias_level,
+	.component_driver = {
 	.controls = rt5514_snd_controls,
 	.num_controls = ARRAY_SIZE(rt5514_snd_controls),
 	.dapm_widgets = rt5514_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(rt5514_dapm_widgets),
 	.dapm_routes = rt5514_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(rt5514_dapm_routes),
+	},
 };
 
 static const struct regmap_config rt5514_i2c_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/rt5616.c linux-4.8-rc4.orig/sound/soc/codecs/rt5616.c
--- linux-4.8-rc4.new/sound/soc/codecs/rt5616.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/rt5616.c	2016-09-04 01:14:32.688252397 +0000
@@ -1302,12 +1302,14 @@
 	.resume = rt5616_resume,
 	.set_bias_level = rt5616_set_bias_level,
 	.idle_bias_off = true,
+	.component_driver = {
 	.controls = rt5616_snd_controls,
 	.num_controls = ARRAY_SIZE(rt5616_snd_controls),
 	.dapm_widgets = rt5616_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(rt5616_dapm_widgets),
 	.dapm_routes = rt5616_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(rt5616_dapm_routes),
+	},
 };
 
 static const struct regmap_config rt5616_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/rt5631.c linux-4.8-rc4.orig/sound/soc/codecs/rt5631.c
--- linux-4.8-rc4.new/sound/soc/codecs/rt5631.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/rt5631.c	2016-09-04 01:14:32.680252687 +0000
@@ -1657,12 +1657,14 @@
 	.probe = rt5631_probe,
 	.set_bias_level = rt5631_set_bias_level,
 	.suspend_bias_off = true,
+	.component_driver = {
 	.controls = rt5631_snd_controls,
 	.num_controls = ARRAY_SIZE(rt5631_snd_controls),
 	.dapm_widgets = rt5631_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(rt5631_dapm_widgets),
 	.dapm_routes = rt5631_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(rt5631_dapm_routes),
+	},
 };
 
 static const struct i2c_device_id rt5631_i2c_id[] = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/rt5640.c linux-4.8-rc4.orig/sound/soc/codecs/rt5640.c
--- linux-4.8-rc4.new/sound/soc/codecs/rt5640.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/rt5640.c	2016-09-04 01:14:42.499896298 +0000
@@ -1870,6 +1870,9 @@
 	case RT5640_SCLK_S_PLL1:
 		reg_val |= RT5640_SCLK_SRC_PLL1;
 		break;
+	case RT5640_SCLK_S_RCCLK:
+		reg_val |= RT5640_SCLK_SRC_RCCLK;
+		break;
 	default:
 		dev_err(codec->dev, "Invalid clock id (%d)\n", clk_id);
 		return -EINVAL;
@@ -2261,12 +2264,14 @@
 	.resume = rt5640_resume,
 	.set_bias_level = rt5640_set_bias_level,
 	.idle_bias_off = true,
+	.component_driver = {
 	.controls = rt5640_snd_controls,
 	.num_controls = ARRAY_SIZE(rt5640_snd_controls),
 	.dapm_widgets = rt5640_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(rt5640_dapm_widgets),
 	.dapm_routes = rt5640_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(rt5640_dapm_routes),
+	},
 };
 
 static const struct regmap_config rt5640_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/rt5640.h linux-4.8-rc4.orig/sound/soc/codecs/rt5640.h
--- linux-4.8-rc4.new/sound/soc/codecs/rt5640.h	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/rt5640.h	2016-09-04 01:14:42.515895717 +0000
@@ -984,6 +984,7 @@
 #define RT5640_SCLK_SRC_SFT			14
 #define RT5640_SCLK_SRC_MCLK			(0x0 << 14)
 #define RT5640_SCLK_SRC_PLL1			(0x1 << 14)
+#define RT5640_SCLK_SRC_RCCLK			(0x2 << 14)
 #define RT5640_PLL1_SRC_MASK			(0x3 << 12)
 #define RT5640_PLL1_SRC_SFT			12
 #define RT5640_PLL1_SRC_MCLK			(0x0 << 12)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/rt5645.c linux-4.8-rc4.orig/sound/soc/codecs/rt5645.c
--- linux-4.8-rc4.new/sound/soc/codecs/rt5645.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/rt5645.c	2016-09-04 01:14:37.028094888 +0000
@@ -3484,12 +3484,14 @@
 	.resume = rt5645_resume,
 	.set_bias_level = rt5645_set_bias_level,
 	.idle_bias_off = true,
+	.component_driver = {
 	.controls = rt5645_snd_controls,
 	.num_controls = ARRAY_SIZE(rt5645_snd_controls),
 	.dapm_widgets = rt5645_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(rt5645_dapm_widgets),
 	.dapm_routes = rt5645_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(rt5645_dapm_routes),
+	},
 };
 
 static const struct regmap_config rt5645_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/rt5651.c linux-4.8-rc4.orig/sound/soc/codecs/rt5651.c
--- linux-4.8-rc4.new/sound/soc/codecs/rt5651.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/rt5651.c	2016-09-04 01:14:37.060093727 +0000
@@ -1712,12 +1712,14 @@
 	.resume = rt5651_resume,
 	.set_bias_level = rt5651_set_bias_level,
 	.idle_bias_off = true,
+	.component_driver = {
 	.controls = rt5651_snd_controls,
 	.num_controls = ARRAY_SIZE(rt5651_snd_controls),
 	.dapm_widgets = rt5651_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(rt5651_dapm_widgets),
 	.dapm_routes = rt5651_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(rt5651_dapm_routes),
+	},
 };
 
 static const struct regmap_config rt5651_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/rt5659.c linux-4.8-rc4.orig/sound/soc/codecs/rt5659.c
--- linux-4.8-rc4.new/sound/soc/codecs/rt5659.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/rt5659.c	2016-09-04 01:14:37.068093437 +0000
@@ -9,6 +9,7 @@
  * published by the Free Software Foundation.
  */
 
+#include <linux/clk.h>
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/init.h>
@@ -3565,7 +3566,9 @@
 static int rt5659_set_bias_level(struct snd_soc_codec *codec,
 			enum snd_soc_bias_level level)
 {
+	struct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);
 	struct rt5659_priv *rt5659 = snd_soc_codec_get_drvdata(codec);
+	int ret;
 
 	switch (level) {
 	case SND_SOC_BIAS_PREPARE:
@@ -3582,6 +3585,17 @@
 			RT5659_PWR_FV1 | RT5659_PWR_FV2);
 		break;
 
+	case SND_SOC_BIAS_STANDBY:
+		if (dapm->bias_level == SND_SOC_BIAS_OFF) {
+			ret = clk_prepare_enable(rt5659->mclk);
+			if (ret) {
+				dev_err(codec->dev,
+					"failed to enable MCLK: %d\n", ret);
+				return ret;
+			}
+		}
+		break;
+
 	case SND_SOC_BIAS_OFF:
 		regmap_update_bits(rt5659->regmap, RT5659_PWR_DIG_1,
 			RT5659_PWR_LDO, 0);
@@ -3591,6 +3605,7 @@
 			RT5659_PWR_MB | RT5659_PWR_VREF2);
 		regmap_update_bits(rt5659->regmap, RT5659_DIG_MISC,
 			RT5659_DIG_GATE_CTRL, 0);
+		clk_disable_unprepare(rt5659->mclk);
 		break;
 
 	default:
@@ -3722,12 +3737,14 @@
 	.resume = rt5659_resume,
 	.set_bias_level = rt5659_set_bias_level,
 	.idle_bias_off = true,
+	.component_driver = {
 	.controls = rt5659_snd_controls,
 	.num_controls = ARRAY_SIZE(rt5659_snd_controls),
 	.dapm_widgets = rt5659_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(rt5659_dapm_widgets),
 	.dapm_routes = rt5659_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(rt5659_dapm_routes),
+	},
 };
 
 
@@ -4020,6 +4037,15 @@
 
 	regmap_write(rt5659->regmap, RT5659_RESET, 0);
 
+	/* Check if MCLK provided */
+	rt5659->mclk = devm_clk_get(&i2c->dev, "mclk");
+	if (IS_ERR(rt5659->mclk)) {
+		if (PTR_ERR(rt5659->mclk) != -ENOENT)
+			return PTR_ERR(rt5659->mclk);
+		/* Otherwise mark the mclk pointer to NULL */
+		rt5659->mclk = NULL;
+	}
+
 	rt5659_calibrate(rt5659);
 
 	/* line in diff mode*/
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/rt5659.h linux-4.8-rc4.orig/sound/soc/codecs/rt5659.h
--- linux-4.8-rc4.new/sound/soc/codecs/rt5659.h	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/rt5659.h	2016-09-04 01:14:31.948279253 +0000
@@ -1796,6 +1796,7 @@
 	struct gpio_desc *gpiod_reset;
 	struct snd_soc_jack *hs_jack;
 	struct delayed_work jack_detect_work;
+	struct clk *mclk;
 
 	int sysclk;
 	int sysclk_src;
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/rt5670.c linux-4.8-rc4.orig/sound/soc/codecs/rt5670.c
--- linux-4.8-rc4.new/sound/soc/codecs/rt5670.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/rt5670.c	2016-09-04 01:14:37.108091985 +0000
@@ -2777,12 +2777,14 @@
 	.resume = rt5670_resume,
 	.set_bias_level = rt5670_set_bias_level,
 	.idle_bias_off = true,
+	.component_driver = {
 	.controls = rt5670_snd_controls,
 	.num_controls = ARRAY_SIZE(rt5670_snd_controls),
 	.dapm_widgets = rt5670_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(rt5670_dapm_widgets),
 	.dapm_routes = rt5670_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(rt5670_dapm_routes),
+	},
 };
 
 static const struct regmap_config rt5670_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/rt5677.c linux-4.8-rc4.orig/sound/soc/codecs/rt5677.c
--- linux-4.8-rc4.new/sound/soc/codecs/rt5677.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/rt5677.c	2016-09-04 01:14:37.152090389 +0000
@@ -4974,12 +4974,14 @@
 	.resume = rt5677_resume,
 	.set_bias_level = rt5677_set_bias_level,
 	.idle_bias_off = true,
+	.component_driver = {
 	.controls = rt5677_snd_controls,
 	.num_controls = ARRAY_SIZE(rt5677_snd_controls),
 	.dapm_widgets = rt5677_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(rt5677_dapm_widgets),
 	.dapm_routes = rt5677_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(rt5677_dapm_routes),
+	},
 };
 
 static const struct regmap_config rt5677_regmap_physical = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/sgtl5000.c linux-4.8-rc4.orig/sound/soc/codecs/sgtl5000.c
--- linux-4.8-rc4.new/sound/soc/codecs/sgtl5000.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/sgtl5000.c	2016-09-04 01:14:32.672252978 +0000
@@ -1151,12 +1151,14 @@
 	.remove = sgtl5000_remove,
 	.set_bias_level = sgtl5000_set_bias_level,
 	.suspend_bias_off = true,
+	.component_driver = {
 	.controls = sgtl5000_snd_controls,
 	.num_controls = ARRAY_SIZE(sgtl5000_snd_controls),
 	.dapm_widgets = sgtl5000_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(sgtl5000_dapm_widgets),
 	.dapm_routes = sgtl5000_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(sgtl5000_dapm_routes),
+	},
 };
 
 static const struct regmap_config sgtl5000_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/si476x.c linux-4.8-rc4.orig/sound/soc/codecs/si476x.c
--- linux-4.8-rc4.new/sound/soc/codecs/si476x.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/si476x.c	2016-09-04 01:14:37.188089082 +0000
@@ -238,10 +238,12 @@
 
 static struct snd_soc_codec_driver soc_codec_dev_si476x = {
 	.get_regmap = si476x_get_regmap,
+	.component_driver = {
 	.dapm_widgets = si476x_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(si476x_dapm_widgets),
 	.dapm_routes = si476x_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(si476x_dapm_routes),
+	},
 };
 
 static int si476x_platform_probe(struct platform_device *pdev)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/sn95031.c linux-4.8-rc4.orig/sound/soc/codecs/sn95031.c
--- linux-4.8-rc4.new/sound/soc/codecs/sn95031.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/sn95031.c	2016-09-04 01:14:37.220087921 +0000
@@ -888,12 +888,14 @@
 	.set_bias_level	= sn95031_set_vaud_bias,
 	.idle_bias_off	= true,
 
+	.component_driver = {
 	.controls	= sn95031_snd_controls,
 	.num_controls	= ARRAY_SIZE(sn95031_snd_controls),
 	.dapm_widgets	= sn95031_dapm_widgets,
 	.num_dapm_widgets	= ARRAY_SIZE(sn95031_dapm_widgets),
 	.dapm_routes	= sn95031_audio_map,
 	.num_dapm_routes	= ARRAY_SIZE(sn95031_audio_map),
+	},
 };
 
 static int sn95031_device_probe(struct platform_device *pdev)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/spdif_receiver.c linux-4.8-rc4.orig/sound/soc/codecs/spdif_receiver.c
--- linux-4.8-rc4.new/sound/soc/codecs/spdif_receiver.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/spdif_receiver.c	2016-09-04 01:14:32.668253122 +0000
@@ -38,10 +38,12 @@
 			SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE)
 
 static struct snd_soc_codec_driver soc_codec_spdif_dir = {
+	.component_driver = {
 	.dapm_widgets = dir_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(dir_widgets),
 	.dapm_routes = dir_routes,
 	.num_dapm_routes = ARRAY_SIZE(dir_routes),
+	},
 };
 
 static struct snd_soc_dai_driver dir_stub_dai = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/spdif_transmitter.c linux-4.8-rc4.orig/sound/soc/codecs/spdif_transmitter.c
--- linux-4.8-rc4.new/sound/soc/codecs/spdif_transmitter.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/spdif_transmitter.c	2016-09-04 01:14:32.664253268 +0000
@@ -38,10 +38,12 @@
 };
 
 static struct snd_soc_codec_driver soc_codec_spdif_dit = {
+	.component_driver = {
 	.dapm_widgets = dit_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(dit_widgets),
 	.dapm_routes = dit_routes,
 	.num_dapm_routes = ARRAY_SIZE(dit_routes),
+	},
 };
 
 static struct snd_soc_dai_driver dit_stub_dai = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/ssm2518.c linux-4.8-rc4.orig/sound/soc/codecs/ssm2518.c
--- linux-4.8-rc4.new/sound/soc/codecs/ssm2518.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/ssm2518.c	2016-09-04 01:14:37.256086614 +0000
@@ -715,12 +715,14 @@
 	.set_sysclk = ssm2518_set_sysclk,
 	.idle_bias_off = true,
 
+	.component_driver = {
 	.controls = ssm2518_snd_controls,
 	.num_controls = ARRAY_SIZE(ssm2518_snd_controls),
 	.dapm_widgets = ssm2518_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(ssm2518_dapm_widgets),
 	.dapm_routes = ssm2518_routes,
 	.num_dapm_routes = ARRAY_SIZE(ssm2518_routes),
+	},
 };
 
 static const struct regmap_config ssm2518_regmap_config = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/ssm2602.c linux-4.8-rc4.orig/sound/soc/codecs/ssm2602.c
--- linux-4.8-rc4.new/sound/soc/codecs/ssm2602.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/ssm2602.c	2016-09-04 01:14:32.660253413 +0000
@@ -597,12 +597,14 @@
 	.set_bias_level = ssm2602_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
 	.controls = ssm260x_snd_controls,
 	.num_controls = ARRAY_SIZE(ssm260x_snd_controls),
 	.dapm_widgets = ssm260x_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(ssm260x_dapm_widgets),
 	.dapm_routes = ssm260x_routes,
 	.num_dapm_routes = ARRAY_SIZE(ssm260x_routes),
+	},
 };
 
 static bool ssm2602_register_volatile(struct device *dev, unsigned int reg)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/ssm4567.c linux-4.8-rc4.orig/sound/soc/codecs/ssm4567.c
--- linux-4.8-rc4.new/sound/soc/codecs/ssm4567.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/ssm4567.c	2016-09-04 01:14:32.656253558 +0000
@@ -421,12 +421,14 @@
 	.set_bias_level = ssm4567_set_bias_level,
 	.idle_bias_off = true,
 
+	.component_driver = {
 	.controls = ssm4567_snd_controls,
 	.num_controls = ARRAY_SIZE(ssm4567_snd_controls),
 	.dapm_widgets = ssm4567_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(ssm4567_dapm_widgets),
 	.dapm_routes = ssm4567_routes,
 	.num_dapm_routes = ARRAY_SIZE(ssm4567_routes),
+	},
 };
 
 static const struct regmap_config ssm4567_regmap_config = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/sta32x.c linux-4.8-rc4.orig/sound/soc/codecs/sta32x.c
--- linux-4.8-rc4.new/sound/soc/codecs/sta32x.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/sta32x.c	2016-09-04 01:14:32.652253703 +0000
@@ -991,12 +991,14 @@
 	.remove =		sta32x_remove,
 	.set_bias_level =	sta32x_set_bias_level,
 	.suspend_bias_off =	true,
+	.component_driver = {
 	.controls =		sta32x_snd_controls,
 	.num_controls =		ARRAY_SIZE(sta32x_snd_controls),
 	.dapm_widgets =		sta32x_dapm_widgets,
 	.num_dapm_widgets =	ARRAY_SIZE(sta32x_dapm_widgets),
 	.dapm_routes =		sta32x_dapm_routes,
 	.num_dapm_routes =	ARRAY_SIZE(sta32x_dapm_routes),
+	},
 };
 
 static const struct regmap_config sta32x_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/sta350.c linux-4.8-rc4.orig/sound/soc/codecs/sta350.c
--- linux-4.8-rc4.new/sound/soc/codecs/sta350.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/sta350.c	2016-09-04 01:14:32.648253849 +0000
@@ -1057,12 +1057,14 @@
 	.remove =		sta350_remove,
 	.set_bias_level =	sta350_set_bias_level,
 	.suspend_bias_off =	true,
+	.component_driver = {
 	.controls =		sta350_snd_controls,
 	.num_controls =		ARRAY_SIZE(sta350_snd_controls),
 	.dapm_widgets =		sta350_dapm_widgets,
 	.num_dapm_widgets =	ARRAY_SIZE(sta350_dapm_widgets),
 	.dapm_routes =		sta350_dapm_routes,
 	.num_dapm_routes =	ARRAY_SIZE(sta350_dapm_routes),
+	},
 };
 
 static const struct regmap_config sta350_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/sta529.c linux-4.8-rc4.orig/sound/soc/codecs/sta529.c
--- linux-4.8-rc4.new/sound/soc/codecs/sta529.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/sta529.c	2016-09-04 01:14:37.264086324 +0000
@@ -317,8 +317,10 @@
 	.set_bias_level = sta529_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
 	.controls = sta529_snd_controls,
 	.num_controls = ARRAY_SIZE(sta529_snd_controls),
+	},
 };
 
 static const struct regmap_config sta529_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/stac9766.c linux-4.8-rc4.orig/sound/soc/codecs/stac9766.c
--- linux-4.8-rc4.new/sound/soc/codecs/stac9766.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/stac9766.c	2016-09-04 01:14:37.284085598 +0000
@@ -320,8 +320,10 @@
 }
 
 static struct snd_soc_codec_driver soc_codec_dev_stac9766 = {
+	.component_driver = {
 	.controls = stac9766_snd_ac97_controls,
 	.num_controls = ARRAY_SIZE(stac9766_snd_ac97_controls),
+	},
 	.write = stac9766_ac97_write,
 	.read = stac9766_ac97_read,
 	.set_bias_level = stac9766_set_bias_level,
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/sti-sas.c linux-4.8-rc4.orig/sound/soc/codecs/sti-sas.c
--- linux-4.8-rc4.new/sound/soc/codecs/sti-sas.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/sti-sas.c	2016-09-04 01:14:32.640254139 +0000
@@ -591,11 +591,11 @@
 	sti_sas_dai[STI_SAS_DAI_ANALOG_OUT].ops = drvdata->dev_data->dac_ops;
 
 	/* Set dapms*/
-	sti_sas_driver.dapm_widgets = drvdata->dev_data->dapm_widgets;
-	sti_sas_driver.num_dapm_widgets = drvdata->dev_data->num_dapm_widgets;
+	sti_sas_driver.component_driver.dapm_widgets = drvdata->dev_data->dapm_widgets;
+	sti_sas_driver.component_driver.num_dapm_widgets = drvdata->dev_data->num_dapm_widgets;
 
-	sti_sas_driver.dapm_routes = drvdata->dev_data->dapm_routes;
-	sti_sas_driver.num_dapm_routes = drvdata->dev_data->num_dapm_routes;
+	sti_sas_driver.component_driver.dapm_routes = drvdata->dev_data->dapm_routes;
+	sti_sas_driver.component_driver.num_dapm_routes = drvdata->dev_data->num_dapm_routes;
 
 	/* Store context */
 	dev_set_drvdata(&pdev->dev, drvdata);
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/tas2552.c linux-4.8-rc4.orig/sound/soc/codecs/tas2552.c
--- linux-4.8-rc4.new/sound/soc/codecs/tas2552.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/tas2552.c	2016-09-04 01:14:32.636254284 +0000
@@ -667,12 +667,14 @@
 	.resume = tas2552_resume,
 	.ignore_pmdown_time = true,
 
+	.component_driver = {
 	.controls = tas2552_snd_controls,
 	.num_controls = ARRAY_SIZE(tas2552_snd_controls),
 	.dapm_widgets = tas2552_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(tas2552_dapm_widgets),
 	.dapm_routes = tas2552_audio_map,
 	.num_dapm_routes = ARRAY_SIZE(tas2552_audio_map),
+	},
 };
 
 static const struct regmap_config tas2552_regmap_config = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/tas5086.c linux-4.8-rc4.orig/sound/soc/codecs/tas5086.c
--- linux-4.8-rc4.new/sound/soc/codecs/tas5086.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/tas5086.c	2016-09-04 01:14:53.807485906 +0000
@@ -387,7 +387,7 @@
 	val = index_in_array(tas5086_ratios, ARRAY_SIZE(tas5086_ratios),
 			     priv->mclk / priv->rate);
 	if (val < 0) {
-		dev_err(codec->dev, "Inavlid MCLK / Fs ratio\n");
+		dev_err(codec->dev, "Invalid MCLK / Fs ratio\n");
 		return -EINVAL;
 	}
 
@@ -890,12 +890,14 @@
 	.remove			= tas5086_remove,
 	.suspend		= tas5086_soc_suspend,
 	.resume			= tas5086_soc_resume,
+	.component_driver = {
 	.controls		= tas5086_controls,
 	.num_controls		= ARRAY_SIZE(tas5086_controls),
 	.dapm_widgets		= tas5086_dapm_widgets,
 	.num_dapm_widgets	= ARRAY_SIZE(tas5086_dapm_widgets),
 	.dapm_routes		= tas5086_dapm_routes,
 	.num_dapm_routes	= ARRAY_SIZE(tas5086_dapm_routes),
+	},
 };
 
 static const struct i2c_device_id tas5086_i2c_id[] = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/tas571x.c linux-4.8-rc4.orig/sound/soc/codecs/tas571x.c
--- linux-4.8-rc4.new/sound/soc/codecs/tas571x.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/tas571x.c	2016-09-04 01:14:32.628254574 +0000
@@ -658,10 +658,12 @@
 	.set_bias_level = tas571x_set_bias_level,
 	.idle_bias_off = true,
 
+	.component_driver = {
 	.dapm_widgets = tas571x_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(tas571x_dapm_widgets),
 	.dapm_routes = tas571x_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(tas571x_dapm_routes),
+	},
 };
 
 static struct snd_soc_dai_driver tas571x_dai = {
@@ -754,8 +756,8 @@
 
 
 	memcpy(&priv->codec_driver, &tas571x_codec, sizeof(priv->codec_driver));
-	priv->codec_driver.controls = priv->chip->controls;
-	priv->codec_driver.num_controls = priv->chip->num_controls;
+	priv->codec_driver.component_driver.controls = priv->chip->controls;
+	priv->codec_driver.component_driver.num_controls = priv->chip->num_controls;
 
 	if (priv->chip->vol_reg_size == 2) {
 		/*
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/tas5720.c linux-4.8-rc4.orig/sound/soc/codecs/tas5720.c
--- linux-4.8-rc4.new/sound/soc/codecs/tas5720.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/tas5720.c	2016-09-04 01:14:32.624254720 +0000
@@ -489,12 +489,14 @@
 	.suspend = tas5720_suspend,
 	.resume = tas5720_resume,
 
+	.component_driver = {
 	.controls = tas5720_snd_controls,
 	.num_controls = ARRAY_SIZE(tas5720_snd_controls),
 	.dapm_widgets = tas5720_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(tas5720_dapm_widgets),
 	.dapm_routes = tas5720_audio_map,
 	.num_dapm_routes = ARRAY_SIZE(tas5720_audio_map),
+	},
 };
 
 /* PCM rates supported by the TAS5720 driver */
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/tfa9879.c linux-4.8-rc4.orig/sound/soc/codecs/tfa9879.c
--- linux-4.8-rc4.new/sound/soc/codecs/tfa9879.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/tfa9879.c	2016-09-04 01:14:32.620254864 +0000
@@ -231,13 +231,14 @@
 };
 
 static const struct snd_soc_codec_driver tfa9879_codec = {
+	.component_driver = {
 	.controls = tfa9879_controls,
 	.num_controls = ARRAY_SIZE(tfa9879_controls),
-
 	.dapm_widgets = tfa9879_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(tfa9879_dapm_widgets),
 	.dapm_routes = tfa9879_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(tfa9879_dapm_routes),
+	},
 };
 
 static const struct regmap_config tfa9879_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/tlv320aic23.c linux-4.8-rc4.orig/sound/soc/codecs/tlv320aic23.c
--- linux-4.8-rc4.new/sound/soc/codecs/tlv320aic23.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/tlv320aic23.c	2016-09-04 01:14:32.616255010 +0000
@@ -583,12 +583,14 @@
 	.set_bias_level = tlv320aic23_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
 	.controls = tlv320aic23_snd_controls,
 	.num_controls = ARRAY_SIZE(tlv320aic23_snd_controls),
 	.dapm_widgets = tlv320aic23_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(tlv320aic23_dapm_widgets),
 	.dapm_routes = tlv320aic23_intercon,
 	.num_dapm_routes = ARRAY_SIZE(tlv320aic23_intercon),
+	},
 };
 
 int tlv320aic23_probe(struct device *dev, struct regmap *regmap)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/tlv320aic26.c linux-4.8-rc4.orig/sound/soc/codecs/tlv320aic26.c
--- linux-4.8-rc4.new/sound/soc/codecs/tlv320aic26.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/tlv320aic26.c	2016-09-04 01:14:37.288085452 +0000
@@ -321,12 +321,14 @@
 
 static struct snd_soc_codec_driver aic26_soc_codec_dev = {
 	.probe = aic26_probe,
+	.component_driver = {
 	.controls = aic26_snd_controls,
 	.num_controls = ARRAY_SIZE(aic26_snd_controls),
 	.dapm_widgets = tlv320aic26_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(tlv320aic26_dapm_widgets),
 	.dapm_routes = tlv320aic26_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(tlv320aic26_dapm_routes),
+	},
 };
 
 static const struct regmap_config aic26_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/tlv320aic31xx.c linux-4.8-rc4.orig/sound/soc/codecs/tlv320aic31xx.c
--- linux-4.8-rc4.new/sound/soc/codecs/tlv320aic31xx.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/tlv320aic31xx.c	2016-09-04 01:14:32.612255155 +0000
@@ -1114,12 +1114,14 @@
 	.set_bias_level		= aic31xx_set_bias_level,
 	.suspend_bias_off	= true,
 
+	.component_driver = {
 	.controls		= aic31xx_snd_controls,
 	.num_controls		= ARRAY_SIZE(aic31xx_snd_controls),
 	.dapm_widgets		= aic31xx_dapm_widgets,
 	.num_dapm_widgets	= ARRAY_SIZE(aic31xx_dapm_widgets),
 	.dapm_routes		= aic31xx_audio_map,
 	.num_dapm_routes	= ARRAY_SIZE(aic31xx_audio_map),
+	},
 };
 
 static const struct snd_soc_dai_ops aic31xx_dai_ops = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/tlv320aic32x4.c linux-4.8-rc4.orig/sound/soc/codecs/tlv320aic32x4.c
--- linux-4.8-rc4.new/sound/soc/codecs/tlv320aic32x4.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/tlv320aic32x4.c	2016-09-04 01:14:37.296085162 +0000
@@ -797,12 +797,14 @@
 	.set_bias_level = aic32x4_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
 	.controls = aic32x4_snd_controls,
 	.num_controls = ARRAY_SIZE(aic32x4_snd_controls),
 	.dapm_widgets = aic32x4_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(aic32x4_dapm_widgets),
 	.dapm_routes = aic32x4_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(aic32x4_dapm_routes),
+	},
 };
 
 static int aic32x4_parse_dt(struct aic32x4_priv *aic32x4,
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/tlv320aic3x.c linux-4.8-rc4.orig/sound/soc/codecs/tlv320aic3x.c
--- linux-4.8-rc4.new/sound/soc/codecs/tlv320aic3x.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/tlv320aic3x.c	2016-09-04 01:14:32.608255300 +0000
@@ -1670,12 +1670,14 @@
 	.idle_bias_off = true,
 	.probe = aic3x_probe,
 	.remove = aic3x_remove,
+	.component_driver = {
 	.controls = aic3x_snd_controls,
 	.num_controls = ARRAY_SIZE(aic3x_snd_controls),
 	.dapm_widgets = aic3x_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(aic3x_dapm_widgets),
 	.dapm_routes = intercon,
 	.num_dapm_routes = ARRAY_SIZE(intercon),
+	},
 };
 
 /*
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/tlv320dac33.c linux-4.8-rc4.orig/sound/soc/codecs/tlv320dac33.c
--- linux-4.8-rc4.new/sound/soc/codecs/tlv320dac33.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/tlv320dac33.c	2016-09-04 01:14:37.300085017 +0000
@@ -1453,12 +1453,14 @@
 	.probe = dac33_soc_probe,
 	.remove = dac33_soc_remove,
 
+	.component_driver = {
 	.controls = dac33_snd_controls,
 	.num_controls = ARRAY_SIZE(dac33_snd_controls),
 	.dapm_widgets = dac33_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(dac33_dapm_widgets),
 	.dapm_routes = audio_map,
 	.num_dapm_routes = ARRAY_SIZE(audio_map),
+	},
 };
 
 #define DAC33_RATES	(SNDRV_PCM_RATE_44100 | \
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/twl4030.c linux-4.8-rc4.orig/sound/soc/codecs/twl4030.c
--- linux-4.8-rc4.new/sound/soc/codecs/twl4030.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/twl4030.c	2016-09-04 01:14:37.312084581 +0000
@@ -2199,12 +2199,14 @@
 	.set_bias_level = twl4030_set_bias_level,
 	.idle_bias_off = true,
 
+	.component_driver = {
 	.controls = twl4030_snd_controls,
 	.num_controls = ARRAY_SIZE(twl4030_snd_controls),
 	.dapm_widgets = twl4030_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(twl4030_dapm_widgets),
 	.dapm_routes = intercon,
 	.num_dapm_routes = ARRAY_SIZE(intercon),
+	},
 };
 
 static int twl4030_codec_probe(struct platform_device *pdev)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/twl6040.c linux-4.8-rc4.orig/sound/soc/codecs/twl6040.c
--- linux-4.8-rc4.new/sound/soc/codecs/twl6040.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/twl6040.c	2016-09-04 01:14:37.316084437 +0000
@@ -1156,12 +1156,14 @@
 	.suspend_bias_off = true,
 	.ignore_pmdown_time = true,
 
+	.component_driver = {
 	.controls = twl6040_snd_controls,
 	.num_controls = ARRAY_SIZE(twl6040_snd_controls),
 	.dapm_widgets = twl6040_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(twl6040_dapm_widgets),
 	.dapm_routes = intercon,
 	.num_dapm_routes = ARRAY_SIZE(intercon),
+	},
 };
 
 static int twl6040_codec_probe(struct platform_device *pdev)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/uda134x.c linux-4.8-rc4.orig/sound/soc/codecs/uda134x.c
--- linux-4.8-rc4.new/sound/soc/codecs/uda134x.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/uda134x.c	2016-09-04 01:14:37.324084146 +0000
@@ -523,10 +523,12 @@
 	.set_bias_level = uda134x_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
 	.dapm_widgets = uda134x_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(uda134x_dapm_widgets),
 	.dapm_routes = uda134x_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(uda134x_dapm_routes),
+	},
 };
 
 static const struct regmap_config uda134x_regmap_config = {
@@ -544,6 +546,7 @@
 {
 	struct uda134x_platform_data *pd = pdev->dev.platform_data;
 	struct uda134x_priv *uda134x;
+	int ret;
 
 	if (!pd) {
 		dev_err(&pdev->dev, "Missing L3 bitbang function\n");
@@ -557,6 +560,12 @@
 	uda134x->pd = pd;
 	platform_set_drvdata(pdev, uda134x);
 
+	if (pd->l3.use_gpios) {
+		ret = l3_set_gpio_ops(&pdev->dev, &uda134x->pd->l3);
+		if (ret < 0)
+			return ret;
+	}
+
 	uda134x->regmap = devm_regmap_init(&pdev->dev, NULL, pd,
 		&uda134x_regmap_config);
 	if (IS_ERR(uda134x->regmap))
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/uda1380.c linux-4.8-rc4.orig/sound/soc/codecs/uda1380.c
--- linux-4.8-rc4.new/sound/soc/codecs/uda1380.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/uda1380.c	2016-09-04 01:14:37.364082695 +0000
@@ -765,12 +765,14 @@
 	.reg_cache_default = uda1380_reg,
 	.reg_cache_step = 1,
 
+	.component_driver = {
 	.controls = uda1380_snd_controls,
 	.num_controls = ARRAY_SIZE(uda1380_snd_controls),
 	.dapm_widgets = uda1380_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(uda1380_dapm_widgets),
 	.dapm_routes = uda1380_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(uda1380_dapm_routes),
+	},
 };
 
 #if IS_ENABLED(CONFIG_I2C)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wl1273.c linux-4.8-rc4.orig/sound/soc/codecs/wl1273.c
--- linux-4.8-rc4.new/sound/soc/codecs/wl1273.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wl1273.c	2016-09-04 01:14:37.420080662 +0000
@@ -484,12 +484,14 @@
 	.probe = wl1273_probe,
 	.remove = wl1273_remove,
 
+	.component_driver = {
 	.controls = wl1273_controls,
 	.num_controls = ARRAY_SIZE(wl1273_controls),
 	.dapm_widgets = wl1273_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wl1273_dapm_widgets),
 	.dapm_routes = wl1273_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(wl1273_dapm_routes),
+	},
 };
 
 static int wl1273_platform_probe(struct platform_device *pdev)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm0010.c linux-4.8-rc4.orig/sound/soc/codecs/wm0010.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm0010.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm0010.c	2016-09-04 01:14:37.440079936 +0000
@@ -795,10 +795,12 @@
 	.set_sysclk = wm0010_set_sysclk,
 	.idle_bias_off = true,
 
+	.component_driver = {
 	.dapm_widgets = wm0010_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm0010_dapm_widgets),
 	.dapm_routes = wm0010_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(wm0010_dapm_routes),
+	},
 };
 
 #define WM0010_RATES (SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm1250-ev1.c linux-4.8-rc4.orig/sound/soc/codecs/wm1250-ev1.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm1250-ev1.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm1250-ev1.c	2016-09-04 01:14:37.476078630 +0000
@@ -142,11 +142,12 @@
 };
 
 static struct snd_soc_codec_driver soc_codec_dev_wm1250_ev1 = {
+	.component_driver = {
 	.dapm_widgets = wm1250_ev1_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm1250_ev1_dapm_widgets),
 	.dapm_routes = wm1250_ev1_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(wm1250_ev1_dapm_routes),
-
+	},
 	.set_bias_level = wm1250_ev1_set_bias_level,
 	.idle_bias_off = true,
 };
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm2000.c linux-4.8-rc4.orig/sound/soc/codecs/wm2000.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm2000.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm2000.c	2016-09-04 01:14:37.500077759 +0000
@@ -805,12 +805,14 @@
 	.suspend = wm2000_suspend,
 	.resume = wm2000_resume,
 
+	.component_driver = {
+		.controls		= wm2000_controls,
+		.num_controls		= ARRAY_SIZE(wm2000_controls),
 	.dapm_widgets = wm2000_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm2000_dapm_widgets),
 	.dapm_routes = wm2000_audio_map,
 	.num_dapm_routes = ARRAY_SIZE(wm2000_audio_map),
-	.controls = wm2000_controls,
-	.num_controls = ARRAY_SIZE(wm2000_controls),
+	},
 };
 
 static int wm2000_i2c_probe(struct i2c_client *i2c,
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm2200.c linux-4.8-rc4.orig/sound/soc/codecs/wm2200.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm2200.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm2200.c	2016-09-04 01:14:37.536076452 +0000
@@ -2111,12 +2111,14 @@
 	.set_sysclk = wm2200_set_sysclk,
 	.set_pll = wm2200_set_fll,
 
+	.component_driver = {
 	.controls = wm2200_snd_controls,
 	.num_controls = ARRAY_SIZE(wm2200_snd_controls),
 	.dapm_widgets = wm2200_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm2200_dapm_widgets),
 	.dapm_routes = wm2200_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(wm2200_dapm_routes),
+	},
 };
 
 static irqreturn_t wm2200_irq(int irq, void *data)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm5100.c linux-4.8-rc4.orig/sound/soc/codecs/wm5100.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm5100.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm5100.c	2016-09-04 01:14:37.552075872 +0000
@@ -2390,12 +2390,14 @@
 	.idle_bias_off = 1,
 
 	.seq_notifier = wm5100_seq_notifier,
+	.component_driver = {
 	.controls = wm5100_snd_controls,
 	.num_controls = ARRAY_SIZE(wm5100_snd_controls),
 	.dapm_widgets = wm5100_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm5100_dapm_widgets),
 	.dapm_routes = wm5100_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(wm5100_dapm_routes),
+	},
 };
 
 static const struct regmap_config wm5100_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm5102.c linux-4.8-rc4.orig/sound/soc/codecs/wm5102.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm5102.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm5102.c	2016-09-04 01:14:41.203943332 +0000
@@ -1521,6 +1521,16 @@
 	{ "IN3L", NULL, "SYSCLK" },
 	{ "IN3R", NULL, "SYSCLK" },
 
+	{ "ASRC1L", NULL, "SYSCLK" },
+	{ "ASRC1R", NULL, "SYSCLK" },
+	{ "ASRC2L", NULL, "SYSCLK" },
+	{ "ASRC2R", NULL, "SYSCLK" },
+
+	{ "ASRC1L", NULL, "ASYNCCLK" },
+	{ "ASRC1R", NULL, "ASYNCCLK" },
+	{ "ASRC2L", NULL, "ASYNCCLK" },
+	{ "ASRC2R", NULL, "ASYNCCLK" },
+
 	{ "MICBIAS1", NULL, "MICVDD" },
 	{ "MICBIAS2", NULL, "MICVDD" },
 	{ "MICBIAS3", NULL, "MICVDD" },
@@ -2000,12 +2010,14 @@
 	.set_sysclk = arizona_set_sysclk,
 	.set_pll = wm5102_set_fll,
 
+	.component_driver = {
 	.controls = wm5102_snd_controls,
 	.num_controls = ARRAY_SIZE(wm5102_snd_controls),
 	.dapm_widgets = wm5102_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm5102_dapm_widgets),
 	.dapm_routes = wm5102_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(wm5102_dapm_routes),
+	},
 };
 
 static struct snd_compr_ops wm5102_compr_ops = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm5110.c linux-4.8-rc4.orig/sound/soc/codecs/wm5110.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm5110.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm5110.c	2016-09-04 01:14:41.207943187 +0000
@@ -1745,6 +1745,16 @@
 	{ "IN4L", NULL, "SYSCLK" },
 	{ "IN4R", NULL, "SYSCLK" },
 
+	{ "ASRC1L", NULL, "SYSCLK" },
+	{ "ASRC1R", NULL, "SYSCLK" },
+	{ "ASRC2L", NULL, "SYSCLK" },
+	{ "ASRC2R", NULL, "SYSCLK" },
+
+	{ "ASRC1L", NULL, "ASYNCCLK" },
+	{ "ASRC1R", NULL, "ASYNCCLK" },
+	{ "ASRC2L", NULL, "ASYNCCLK" },
+	{ "ASRC2R", NULL, "ASYNCCLK" },
+
 	{ "MICBIAS1", NULL, "MICVDD" },
 	{ "MICBIAS2", NULL, "MICVDD" },
 	{ "MICBIAS3", NULL, "MICVDD" },
@@ -2357,12 +2367,14 @@
 	.set_sysclk = arizona_set_sysclk,
 	.set_pll = wm5110_set_fll,
 
+	.component_driver = {
 	.controls = wm5110_snd_controls,
 	.num_controls = ARRAY_SIZE(wm5110_snd_controls),
 	.dapm_widgets = wm5110_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm5110_dapm_widgets),
 	.dapm_routes = wm5110_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(wm5110_dapm_routes),
+	},
 };
 
 static struct snd_compr_ops wm5110_compr_ops = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8350.c linux-4.8-rc4.orig/sound/soc/codecs/wm8350.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8350.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8350.c	2016-09-04 01:14:37.572075146 +0000
@@ -1594,12 +1594,14 @@
 	.set_bias_level = wm8350_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
 	.controls = wm8350_snd_controls,
 	.num_controls = ARRAY_SIZE(wm8350_snd_controls),
 	.dapm_widgets = wm8350_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8350_dapm_widgets),
 	.dapm_routes = wm8350_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(wm8350_dapm_routes),
+	},
 };
 
 static int wm8350_probe(struct platform_device *pdev)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8400.c linux-4.8-rc4.orig/sound/soc/codecs/wm8400.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8400.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8400.c	2016-09-04 01:14:37.584074710 +0000
@@ -1339,12 +1339,14 @@
 	.set_bias_level = wm8400_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
 	.controls = wm8400_snd_controls,
 	.num_controls = ARRAY_SIZE(wm8400_snd_controls),
 	.dapm_widgets = wm8400_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8400_dapm_widgets),
 	.dapm_routes = wm8400_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(wm8400_dapm_routes),
+	},
 };
 
 static int wm8400_probe(struct platform_device *pdev)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8510.c linux-4.8-rc4.orig/sound/soc/codecs/wm8510.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8510.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8510.c	2016-09-04 01:14:32.596255735 +0000
@@ -586,12 +586,14 @@
 	.set_bias_level = wm8510_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
 	.controls = wm8510_snd_controls,
 	.num_controls = ARRAY_SIZE(wm8510_snd_controls),
 	.dapm_widgets = wm8510_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8510_dapm_widgets),
 	.dapm_routes = wm8510_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(wm8510_dapm_routes),
+	},
 };
 
 static const struct of_device_id wm8510_of_match[] = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8523.c linux-4.8-rc4.orig/sound/soc/codecs/wm8523.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8523.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8523.c	2016-09-04 01:14:32.592255881 +0000
@@ -418,12 +418,14 @@
 	.set_bias_level = wm8523_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
 	.controls = wm8523_controls,
 	.num_controls = ARRAY_SIZE(wm8523_controls),
 	.dapm_widgets = wm8523_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8523_dapm_widgets),
 	.dapm_routes = wm8523_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(wm8523_dapm_routes),
+	},
 };
 
 static const struct of_device_id wm8523_of_match[] = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8580.c linux-4.8-rc4.orig/sound/soc/codecs/wm8580.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8580.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8580.c	2016-09-04 01:14:32.588256026 +0000
@@ -904,12 +904,14 @@
 	.remove =	wm8580_remove,
 	.set_bias_level = wm8580_set_bias_level,
 
+	.component_driver = {
 	.controls = wm8580_snd_controls,
 	.num_controls = ARRAY_SIZE(wm8580_snd_controls),
 	.dapm_widgets = wm8580_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8580_dapm_widgets),
 	.dapm_routes = wm8580_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(wm8580_dapm_routes),
+	},
 };
 
 static const struct of_device_id wm8580_of_match[] = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8711.c linux-4.8-rc4.orig/sound/soc/codecs/wm8711.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8711.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8711.c	2016-09-04 01:14:32.584256171 +0000
@@ -372,12 +372,14 @@
 	.set_bias_level = wm8711_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
 	.controls = wm8711_snd_controls,
 	.num_controls = ARRAY_SIZE(wm8711_snd_controls),
 	.dapm_widgets = wm8711_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8711_dapm_widgets),
 	.dapm_routes = wm8711_intercon,
 	.num_dapm_routes = ARRAY_SIZE(wm8711_intercon),
+	},
 };
 
 static const struct of_device_id wm8711_of_match[] = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8727.c linux-4.8-rc4.orig/sound/soc/codecs/wm8727.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8727.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8727.c	2016-09-04 01:14:37.584074710 +0000
@@ -54,10 +54,12 @@
 };
 
 static struct snd_soc_codec_driver soc_codec_dev_wm8727 = {
+	.component_driver = {
 	.dapm_widgets = wm8727_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8727_dapm_widgets),
 	.dapm_routes = wm8727_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(wm8727_dapm_routes),
+	},
 };
 
 static int wm8727_probe(struct platform_device *pdev)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8728.c linux-4.8-rc4.orig/sound/soc/codecs/wm8728.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8728.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8728.c	2016-09-04 01:14:32.580256316 +0000
@@ -215,12 +215,14 @@
 	.set_bias_level = wm8728_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
 	.controls = wm8728_snd_controls,
 	.num_controls = ARRAY_SIZE(wm8728_snd_controls),
 	.dapm_widgets = wm8728_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8728_dapm_widgets),
 	.dapm_routes = wm8728_intercon,
 	.num_dapm_routes = ARRAY_SIZE(wm8728_intercon),
+	},
 };
 
 static const struct of_device_id wm8728_of_match[] = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8731.c linux-4.8-rc4.orig/sound/soc/codecs/wm8731.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8731.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8731.c	2016-09-04 01:14:32.576256462 +0000
@@ -632,12 +632,14 @@
 	.set_bias_level = wm8731_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
+		.controls		= wm8731_snd_controls,
+		.num_controls		= ARRAY_SIZE(wm8731_snd_controls),
 	.dapm_widgets = wm8731_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8731_dapm_widgets),
 	.dapm_routes = wm8731_intercon,
 	.num_dapm_routes = ARRAY_SIZE(wm8731_intercon),
-	.controls =	wm8731_snd_controls,
-	.num_controls = ARRAY_SIZE(wm8731_snd_controls),
+	},
 };
 
 static const struct of_device_id wm8731_of_match[] = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8737.c linux-4.8-rc4.orig/sound/soc/codecs/wm8737.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8737.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8737.c	2016-09-04 01:14:32.572256606 +0000
@@ -578,12 +578,14 @@
 	.set_bias_level = wm8737_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
 	.controls = wm8737_snd_controls,
 	.num_controls = ARRAY_SIZE(wm8737_snd_controls),
 	.dapm_widgets = wm8737_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8737_dapm_widgets),
 	.dapm_routes = intercon,
 	.num_dapm_routes = ARRAY_SIZE(intercon),
+	},
 };
 
 static const struct of_device_id wm8737_of_match[] = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8741.c linux-4.8-rc4.orig/sound/soc/codecs/wm8741.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8741.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8741.c	2016-09-04 01:14:32.564256897 +0000
@@ -502,10 +502,12 @@
 	.remove =	wm8741_remove,
 	.resume =	wm8741_resume,
 
+	.component_driver = {
 	.dapm_widgets = wm8741_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8741_dapm_widgets),
 	.dapm_routes = wm8741_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(wm8741_dapm_routes),
+	},
 };
 
 static const struct of_device_id wm8741_of_match[] = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8750.c linux-4.8-rc4.orig/sound/soc/codecs/wm8750.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8750.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8750.c	2016-09-04 01:14:32.560257042 +0000
@@ -713,12 +713,14 @@
 	.set_bias_level = wm8750_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
 	.controls = wm8750_snd_controls,
 	.num_controls = ARRAY_SIZE(wm8750_snd_controls),
 	.dapm_widgets = wm8750_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8750_dapm_widgets),
 	.dapm_routes = wm8750_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(wm8750_dapm_routes),
+	},
 };
 
 static const struct of_device_id wm8750_of_match[] = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8753.c linux-4.8-rc4.orig/sound/soc/codecs/wm8753.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8753.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8753.c	2016-09-04 01:14:32.556257188 +0000
@@ -1484,12 +1484,14 @@
 	.set_bias_level = wm8753_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
 	.controls = wm8753_snd_controls,
 	.num_controls = ARRAY_SIZE(wm8753_snd_controls),
 	.dapm_widgets = wm8753_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8753_dapm_widgets),
 	.dapm_routes = wm8753_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(wm8753_dapm_routes),
+	},
 };
 
 static const struct of_device_id wm8753_of_match[] = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8770.c linux-4.8-rc4.orig/sound/soc/codecs/wm8770.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8770.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8770.c	2016-09-04 01:14:32.548257477 +0000
@@ -613,12 +613,14 @@
 	.set_bias_level = wm8770_set_bias_level,
 	.idle_bias_off = true,
 
+	.component_driver = {
 	.controls = wm8770_snd_controls,
 	.num_controls = ARRAY_SIZE(wm8770_snd_controls),
 	.dapm_widgets = wm8770_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8770_dapm_widgets),
 	.dapm_routes = wm8770_intercon,
 	.num_dapm_routes = ARRAY_SIZE(wm8770_intercon),
+	},
 };
 
 static const struct of_device_id wm8770_of_match[] = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8776.c linux-4.8-rc4.orig/sound/soc/codecs/wm8776.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8776.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8776.c	2016-09-04 01:14:32.544257623 +0000
@@ -430,12 +430,14 @@
 	.set_bias_level = wm8776_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
 	.controls = wm8776_snd_controls,
 	.num_controls = ARRAY_SIZE(wm8776_snd_controls),
 	.dapm_widgets = wm8776_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8776_dapm_widgets),
 	.dapm_routes = routes,
 	.num_dapm_routes = ARRAY_SIZE(routes),
+	},
 };
 
 static const struct of_device_id wm8776_of_match[] = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8782.c linux-4.8-rc4.orig/sound/soc/codecs/wm8782.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8782.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8782.c	2016-09-04 01:14:37.584074710 +0000
@@ -51,10 +51,12 @@
 };
 
 static struct snd_soc_codec_driver soc_codec_dev_wm8782 = {
+	.component_driver = {
 	.dapm_widgets = wm8782_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8782_dapm_widgets),
 	.dapm_routes = wm8782_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(wm8782_dapm_routes),
+	},
 };
 
 static int wm8782_probe(struct platform_device *pdev)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8804.c linux-4.8-rc4.orig/sound/soc/codecs/wm8804.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8804.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8804.c	2016-09-04 01:14:32.540257768 +0000
@@ -545,10 +545,12 @@
 static const struct snd_soc_codec_driver soc_codec_dev_wm8804 = {
 	.idle_bias_off = true,
 
+	.component_driver = {
 	.dapm_widgets = wm8804_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8804_dapm_widgets),
 	.dapm_routes = wm8804_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(wm8804_dapm_routes),
+	},
 };
 
 const struct regmap_config wm8804_regmap_config = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8900.c linux-4.8-rc4.orig/sound/soc/codecs/wm8900.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8900.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8900.c	2016-09-04 01:14:37.592074420 +0000
@@ -1214,12 +1214,14 @@
 	.resume =	wm8900_resume,
 	.set_bias_level = wm8900_set_bias_level,
 
+	.component_driver = {
 	.controls = wm8900_snd_controls,
 	.num_controls = ARRAY_SIZE(wm8900_snd_controls),
 	.dapm_widgets = wm8900_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8900_dapm_widgets),
 	.dapm_routes = wm8900_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(wm8900_dapm_routes),
+	},
 };
 
 static const struct regmap_config wm8900_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8903.c linux-4.8-rc4.orig/sound/soc/codecs/wm8903.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8903.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8903.c	2016-09-04 01:14:32.532258059 +0000
@@ -1880,12 +1880,14 @@
 	.seq_notifier = wm8903_seq_notifier,
 	.suspend_bias_off = true,
 
+	.component_driver = {
 	.controls = wm8903_snd_controls,
 	.num_controls = ARRAY_SIZE(wm8903_snd_controls),
 	.dapm_widgets = wm8903_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8903_dapm_widgets),
 	.dapm_routes = wm8903_intercon,
 	.num_dapm_routes = ARRAY_SIZE(wm8903_intercon),
+	},
 };
 
 static const struct regmap_config wm8903_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8940.c linux-4.8-rc4.orig/sound/soc/codecs/wm8940.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8940.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8940.c	2016-09-04 01:14:37.596074275 +0000
@@ -728,12 +728,14 @@
 	.set_bias_level = wm8940_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
 	.controls =     wm8940_snd_controls,
 	.num_controls = ARRAY_SIZE(wm8940_snd_controls),
 	.dapm_widgets = wm8940_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8940_dapm_widgets),
 	.dapm_routes =  wm8940_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(wm8940_dapm_routes),
+	},
 };
 
 static const struct regmap_config wm8940_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8955.c linux-4.8-rc4.orig/sound/soc/codecs/wm8955.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8955.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8955.c	2016-09-04 01:14:37.604073985 +0000
@@ -945,12 +945,14 @@
 	.set_bias_level = wm8955_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
 	.controls =	wm8955_snd_controls,
 	.num_controls = ARRAY_SIZE(wm8955_snd_controls),
 	.dapm_widgets = wm8955_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8955_dapm_widgets),
 	.dapm_routes =	wm8955_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(wm8955_dapm_routes),
+	},
 };
 
 static const struct regmap_config wm8955_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8961.c linux-4.8-rc4.orig/sound/soc/codecs/wm8961.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8961.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8961.c	2016-09-04 01:14:37.608073839 +0000
@@ -888,12 +888,14 @@
 	.set_bias_level = wm8961_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
 	.controls = wm8961_snd_controls,
 	.num_controls = ARRAY_SIZE(wm8961_snd_controls),
 	.dapm_widgets = wm8961_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8961_dapm_widgets),
 	.dapm_routes = audio_paths,
 	.num_dapm_routes = ARRAY_SIZE(audio_paths),
+	},
 };
 
 static const struct regmap_config wm8961_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8971.c linux-4.8-rc4.orig/sound/soc/codecs/wm8971.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8971.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8971.c	2016-09-04 01:14:37.612073694 +0000
@@ -654,12 +654,14 @@
 	.set_bias_level = wm8971_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
 	.controls = wm8971_snd_controls,
 	.num_controls = ARRAY_SIZE(wm8971_snd_controls),
 	.dapm_widgets = wm8971_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8971_dapm_widgets),
 	.dapm_routes = wm8971_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(wm8971_dapm_routes),
+	},
 };
 
 static const struct regmap_config wm8971_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8974.c linux-4.8-rc4.orig/sound/soc/codecs/wm8974.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8974.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8974.c	2016-09-04 01:14:32.528258204 +0000
@@ -681,12 +681,14 @@
 	.set_bias_level = wm8974_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
 	.controls = wm8974_snd_controls,
 	.num_controls = ARRAY_SIZE(wm8974_snd_controls),
 	.dapm_widgets = wm8974_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8974_dapm_widgets),
 	.dapm_routes = wm8974_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(wm8974_dapm_routes),
+	},
 };
 
 static int wm8974_i2c_probe(struct i2c_client *i2c,
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8978.c linux-4.8-rc4.orig/sound/soc/codecs/wm8978.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8978.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8978.c	2016-09-04 01:14:32.520258494 +0000
@@ -999,12 +999,14 @@
 	.resume =	wm8978_resume,
 	.set_bias_level = wm8978_set_bias_level,
 
+	.component_driver = {
 	.controls = wm8978_snd_controls,
 	.num_controls = ARRAY_SIZE(wm8978_snd_controls),
 	.dapm_widgets = wm8978_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8978_dapm_widgets),
 	.dapm_routes = wm8978_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(wm8978_dapm_routes),
+	},
 };
 
 static const struct regmap_config wm8978_regmap_config = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8983.c linux-4.8-rc4.orig/sound/soc/codecs/wm8983.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8983.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8983.c	2016-09-04 01:14:37.616073549 +0000
@@ -980,12 +980,14 @@
 	.probe = wm8983_probe,
 	.set_bias_level = wm8983_set_bias_level,
 	.suspend_bias_off = true,
+	.component_driver = {
 	.controls = wm8983_snd_controls,
 	.num_controls = ARRAY_SIZE(wm8983_snd_controls),
 	.dapm_widgets = wm8983_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8983_dapm_widgets),
 	.dapm_routes = wm8983_audio_map,
 	.num_dapm_routes = ARRAY_SIZE(wm8983_audio_map),
+	},
 };
 
 static const struct regmap_config wm8983_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8985.c linux-4.8-rc4.orig/sound/soc/codecs/wm8985.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8985.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8985.c	2016-09-04 01:14:32.236268801 +0000
@@ -1110,12 +1110,14 @@
 	.set_bias_level = wm8985_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
 	.controls = wm8985_common_snd_controls,
 	.num_controls = ARRAY_SIZE(wm8985_common_snd_controls),
 	.dapm_widgets = wm8985_common_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8985_common_dapm_widgets),
 	.dapm_routes = wm8985_common_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(wm8985_common_dapm_routes),
+	},
 };
 
 static const struct regmap_config wm8985_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8988.c linux-4.8-rc4.orig/sound/soc/codecs/wm8988.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8988.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8988.c	2016-09-04 01:14:37.620073404 +0000
@@ -817,12 +817,14 @@
 	.set_bias_level = wm8988_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
 	.controls = wm8988_snd_controls,
 	.num_controls = ARRAY_SIZE(wm8988_snd_controls),
 	.dapm_widgets = wm8988_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8988_dapm_widgets),
 	.dapm_routes = wm8988_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(wm8988_dapm_routes),
+	},
 };
 
 static const struct regmap_config wm8988_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8990.c linux-4.8-rc4.orig/sound/soc/codecs/wm8990.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8990.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8990.c	2016-09-04 01:14:37.628073114 +0000
@@ -1299,12 +1299,14 @@
 	.set_bias_level = wm8990_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
 	.controls =	wm8990_snd_controls,
 	.num_controls = ARRAY_SIZE(wm8990_snd_controls),
 	.dapm_widgets = wm8990_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8990_dapm_widgets),
 	.dapm_routes =	wm8990_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(wm8990_dapm_routes),
+	},
 };
 
 static const struct regmap_config wm8990_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8991.c linux-4.8-rc4.orig/sound/soc/codecs/wm8991.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8991.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8991.c	2016-09-04 01:14:37.632072968 +0000
@@ -1236,12 +1236,14 @@
 	.set_bias_level = wm8991_set_bias_level,
 	.suspend_bias_off = true,
 
+	.component_driver = {
 	.controls = wm8991_snd_controls,
 	.num_controls = ARRAY_SIZE(wm8991_snd_controls),
 	.dapm_widgets = wm8991_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8991_dapm_widgets),
 	.dapm_routes = wm8991_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(wm8991_dapm_routes),
+	},
 };
 
 static const struct regmap_config wm8991_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8995.c linux-4.8-rc4.orig/sound/soc/codecs/wm8995.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8995.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8995.c	2016-09-04 01:14:37.636072823 +0000
@@ -2192,12 +2192,14 @@
 	.set_bias_level = wm8995_set_bias_level,
 	.idle_bias_off = true,
 
+	.component_driver = {
 	.controls = wm8995_snd_controls,
 	.num_controls = ARRAY_SIZE(wm8995_snd_controls),
 	.dapm_widgets = wm8995_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8995_dapm_widgets),
 	.dapm_routes = wm8995_intercon,
 	.num_dapm_routes = ARRAY_SIZE(wm8995_intercon),
+	},
 };
 
 static const struct regmap_config wm8995_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8996.c linux-4.8-rc4.orig/sound/soc/codecs/wm8996.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8996.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8996.c	2016-09-04 01:14:37.652072243 +0000
@@ -2690,12 +2690,14 @@
 	.set_bias_level = wm8996_set_bias_level,
 	.idle_bias_off	= true,
 	.seq_notifier = wm8996_seq_notifier,
+	.component_driver = {
 	.controls = wm8996_snd_controls,
 	.num_controls = ARRAY_SIZE(wm8996_snd_controls),
 	.dapm_widgets = wm8996_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8996_dapm_widgets),
 	.dapm_routes = wm8996_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(wm8996_dapm_routes),
+	},
 	.set_pll = wm8996_set_fll,
 };
 
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8997.c linux-4.8-rc4.orig/sound/soc/codecs/wm8997.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8997.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8997.c	2016-09-04 01:14:37.664071807 +0000
@@ -1105,12 +1105,14 @@
 	.set_sysclk = arizona_set_sysclk,
 	.set_pll = wm8997_set_fll,
 
+	.component_driver = {
 	.controls = wm8997_snd_controls,
 	.num_controls = ARRAY_SIZE(wm8997_snd_controls),
 	.dapm_widgets = wm8997_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8997_dapm_widgets),
 	.dapm_routes = wm8997_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(wm8997_dapm_routes),
+	},
 };
 
 static int wm8997_probe(struct platform_device *pdev)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm8998.c linux-4.8-rc4.orig/sound/soc/codecs/wm8998.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm8998.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm8998.c	2016-09-04 01:14:41.211943042 +0000
@@ -966,6 +966,16 @@
 	{ "IN2A", NULL, "SYSCLK" },
 	{ "IN2B", NULL, "SYSCLK" },
 
+	{ "ASRC1L", NULL, "SYSCLK" },
+	{ "ASRC1R", NULL, "SYSCLK" },
+	{ "ASRC2L", NULL, "SYSCLK" },
+	{ "ASRC2R", NULL, "SYSCLK" },
+
+	{ "ASRC1L", NULL, "ASYNCCLK" },
+	{ "ASRC1R", NULL, "ASYNCCLK" },
+	{ "ASRC2L", NULL, "ASYNCCLK" },
+	{ "ASRC2R", NULL, "ASYNCCLK" },
+
 	{ "SPD1", NULL, "SYSCLK" },
 	{ "SPD1", NULL, "SPD1TX1" },
 	{ "SPD1", NULL, "SPD1TX2" },
@@ -1361,12 +1371,14 @@
 	.set_sysclk = arizona_set_sysclk,
 	.set_pll = wm8998_set_fll,
 
+	.component_driver = {
 	.controls = wm8998_snd_controls,
 	.num_controls = ARRAY_SIZE(wm8998_snd_controls),
 	.dapm_widgets = wm8998_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm8998_dapm_widgets),
 	.dapm_routes = wm8998_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(wm8998_dapm_routes),
+	},
 };
 
 static int wm8998_probe(struct platform_device *pdev)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm9081.c linux-4.8-rc4.orig/sound/soc/codecs/wm9081.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm9081.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm9081.c	2016-09-04 01:14:37.676071372 +0000
@@ -1282,12 +1282,14 @@
 
 	.idle_bias_off = true,
 
+	.component_driver = {
 	.controls         = wm9081_snd_controls,
 	.num_controls     = ARRAY_SIZE(wm9081_snd_controls),
 	.dapm_widgets	  = wm9081_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm9081_dapm_widgets),
 	.dapm_routes     = wm9081_audio_paths,
 	.num_dapm_routes = ARRAY_SIZE(wm9081_audio_paths),
+	},
 };
 
 static const struct regmap_config wm9081_regmap = {
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm9705.c linux-4.8-rc4.orig/sound/soc/codecs/wm9705.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm9705.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm9705.c	2016-09-04 01:14:37.676071372 +0000
@@ -364,12 +364,14 @@
 	.reg_cache_step = 2,
 	.reg_cache_default = wm9705_reg,
 
+	.component_driver = {
 	.controls = wm9705_snd_ac97_controls,
 	.num_controls = ARRAY_SIZE(wm9705_snd_ac97_controls),
 	.dapm_widgets = wm9705_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm9705_dapm_widgets),
 	.dapm_routes = wm9705_audio_map,
 	.num_dapm_routes = ARRAY_SIZE(wm9705_audio_map),
+	},
 };
 
 static int wm9705_probe(struct platform_device *pdev)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm9712.c linux-4.8-rc4.orig/sound/soc/codecs/wm9712.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm9712.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm9712.c	2016-09-04 01:14:37.680071226 +0000
@@ -682,12 +682,14 @@
 	.reg_cache_step = 2,
 	.reg_cache_default = wm9712_reg,
 
+	.component_driver = {
 	.controls = wm9712_snd_ac97_controls,
 	.num_controls = ARRAY_SIZE(wm9712_snd_ac97_controls),
 	.dapm_widgets = wm9712_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm9712_dapm_widgets),
 	.dapm_routes = wm9712_audio_map,
 	.num_dapm_routes = ARRAY_SIZE(wm9712_audio_map),
+	},
 };
 
 static int wm9712_probe(struct platform_device *pdev)
diff -uwr linux-4.8-rc4.new/sound/soc/codecs/wm9713.c linux-4.8-rc4.orig/sound/soc/codecs/wm9713.c
--- linux-4.8-rc4.new/sound/soc/codecs/wm9713.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/codecs/wm9713.c	2016-09-04 01:14:37.688070936 +0000
@@ -1242,12 +1242,14 @@
 	.resume = 	wm9713_soc_resume,
 	.set_bias_level = wm9713_set_bias_level,
 
+	.component_driver = {
 	.controls = wm9713_snd_ac97_controls,
 	.num_controls = ARRAY_SIZE(wm9713_snd_ac97_controls),
 	.dapm_widgets = wm9713_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm9713_dapm_widgets),
 	.dapm_routes = wm9713_audio_map,
 	.num_dapm_routes = ARRAY_SIZE(wm9713_audio_map),
+	},
 };
 
 static int wm9713_probe(struct platform_device *pdev)
diff -uwr linux-4.8-rc4.new/sound/soc/dwc/designware_i2s.c linux-4.8-rc4.orig/sound/soc/dwc/designware_i2s.c
--- linux-4.8-rc4.new/sound/soc/dwc/designware_i2s.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/dwc/designware_i2s.c	2016-09-04 01:14:31.728287237 +0000
@@ -577,7 +577,6 @@
 		dev->capability |= DWC_I2S_PLAY;
 		dev->play_dma_data.dt.addr = res->start + I2S_TXDMA;
 		dev->play_dma_data.dt.addr_width = bus_widths[idx];
-		dev->play_dma_data.dt.chan_name = "TX";
 		dev->play_dma_data.dt.fifo_size = fifo_depth *
 			(fifo_width[idx2]) >> 8;
 		dev->play_dma_data.dt.maxburst = 16;
@@ -588,7 +587,6 @@
 		dev->capability |= DWC_I2S_RECORD;
 		dev->capture_dma_data.dt.addr = res->start + I2S_RXDMA;
 		dev->capture_dma_data.dt.addr_width = bus_widths[idx];
-		dev->capture_dma_data.dt.chan_name = "RX";
 		dev->capture_dma_data.dt.fifo_size = fifo_depth *
 			(fifo_width[idx2] >> 8);
 		dev->capture_dma_data.dt.maxburst = 16;
diff -uwr linux-4.8-rc4.new/sound/soc/fsl/fsl_asrc.c linux-4.8-rc4.orig/sound/soc/fsl/fsl_asrc.c
--- linux-4.8-rc4.new/sound/soc/fsl/fsl_asrc.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/fsl/fsl_asrc.c	2016-09-04 01:14:50.091620767 +0000
@@ -879,7 +879,7 @@
 		}
 	}
 
-	if (of_device_is_compatible(pdev->dev.of_node, "fsl,imx35-asrc")) {
+	if (of_device_is_compatible(np, "fsl,imx35-asrc")) {
 		asrc_priv->channel_bits = 3;
 		clk_map[IN] = input_clk_map_imx35;
 		clk_map[OUT] = output_clk_map_imx35;
@@ -892,7 +892,7 @@
 	ret = fsl_asrc_init(asrc_priv);
 	if (ret) {
 		dev_err(&pdev->dev, "failed to init asrc %d\n", ret);
-		return -EINVAL;
+		return ret;
 	}
 
 	asrc_priv->channel_avail = 10;
@@ -901,14 +901,14 @@
 				   &asrc_priv->asrc_rate);
 	if (ret) {
 		dev_err(&pdev->dev, "failed to get output rate\n");
-		return -EINVAL;
+		return ret;
 	}
 
 	ret = of_property_read_u32(np, "fsl,asrc-width",
 				   &asrc_priv->asrc_width);
 	if (ret) {
 		dev_err(&pdev->dev, "failed to get output width\n");
-		return -EINVAL;
+		return ret;
 	}
 
 	if (asrc_priv->asrc_width != 16 && asrc_priv->asrc_width != 24) {
@@ -933,8 +933,6 @@
 		return ret;
 	}
 
-	dev_info(&pdev->dev, "driver registered\n");
-
 	return 0;
 }
 
diff -uwr linux-4.8-rc4.new/sound/soc/fsl/fsl_sai.c linux-4.8-rc4.orig/sound/soc/fsl/fsl_sai.c
--- linux-4.8-rc4.new/sound/soc/fsl/fsl_sai.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/fsl/fsl_sai.c	2016-09-04 01:14:45.255796276 +0000
@@ -801,8 +801,8 @@
 
 	sai->pdev = pdev;
 
-	if (of_device_is_compatible(pdev->dev.of_node, "fsl,imx6sx-sai") ||
-	    of_device_is_compatible(pdev->dev.of_node, "fsl,imx6ul-sai"))
+	if (of_device_is_compatible(np, "fsl,imx6sx-sai") ||
+	    of_device_is_compatible(np, "fsl,imx6ul-sai"))
 		sai->sai_on_imx = true;
 
 	sai->is_lsb_first = of_property_read_bool(np, "lsb-first");
@@ -883,7 +883,7 @@
 	}
 
 	if (of_find_property(np, "fsl,sai-mclk-direction-output", NULL) &&
-	    of_device_is_compatible(pdev->dev.of_node, "fsl,imx6ul-sai")) {
+	    of_device_is_compatible(np, "fsl,imx6ul-sai")) {
 		gpr = syscon_regmap_lookup_by_compatible("fsl,imx6ul-iomuxc-gpr");
 		if (IS_ERR(gpr)) {
 			dev_err(&pdev->dev, "cannot find iomuxc registers\n");
diff -uwr linux-4.8-rc4.new/sound/soc/generic/Kconfig linux-4.8-rc4.orig/sound/soc/generic/Kconfig
--- linux-4.8-rc4.new/sound/soc/generic/Kconfig	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/generic/Kconfig	2016-09-04 01:14:53.843484599 +0000
@@ -6,3 +6,10 @@
 	select SND_SIMPLE_CARD_UTILS
 	help
 	  This option enables generic simple sound card support
+
+config SND_SIMPLE_SCU_CARD
+	tristate "ASoC Simple SCU sound card support"
+	select SND_SIMPLE_CARD_UTILS
+	help
+	  This option enables generic simple SCU sound card support.
+	  It supports DPCM of multi CPU single Codec ststem.
diff -uwr linux-4.8-rc4.new/sound/soc/generic/Makefile linux-4.8-rc4.orig/sound/soc/generic/Makefile
--- linux-4.8-rc4.new/sound/soc/generic/Makefile	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/generic/Makefile	2016-09-04 01:14:53.843484599 +0000
@@ -1,5 +1,7 @@
 snd-soc-simple-card-utils-objs	:= simple-card-utils.o
 snd-soc-simple-card-objs	:= simple-card.o
+snd-soc-simple-scu-card-objs	:= simple-scu-card.o
 
 obj-$(CONFIG_SND_SIMPLE_CARD_UTILS)	+= snd-soc-simple-card-utils.o
 obj-$(CONFIG_SND_SIMPLE_CARD)		+= snd-soc-simple-card.o
+obj-$(CONFIG_SND_SIMPLE_SCU_CARD)	+= snd-soc-simple-scu-card.o
diff -uwr linux-4.8-rc4.new/sound/soc/generic/simple-card.c linux-4.8-rc4.orig/sound/soc/generic/simple-card.c
--- linux-4.8-rc4.new/sound/soc/generic/simple-card.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/generic/simple-card.c	2016-09-04 01:14:38.224051483 +0000
@@ -44,6 +44,8 @@
 #define simple_priv_to_link(priv, i) ((priv)->snd_card.dai_link + i)
 #define simple_priv_to_props(priv, i) ((priv)->dai_props + i)
 
+#define DAI	"sound-dai"
+#define CELL	"#sound-dai-cells"
 #define PREFIX	"simple-audio-card,"
 
 #define asoc_simple_card_init_hp(card, sjack, prefix)\
@@ -177,51 +179,19 @@
 	.hw_params = asoc_simple_card_hw_params,
 };
 
-static int __asoc_simple_card_dai_init(struct snd_soc_dai *dai,
-				       struct asoc_simple_dai *set)
-{
-	int ret;
-
-	if (set->sysclk) {
-		ret = snd_soc_dai_set_sysclk(dai, 0, set->sysclk, 0);
-		if (ret && ret != -ENOTSUPP) {
-			dev_err(dai->dev, "simple-card: set_sysclk error\n");
-			goto err;
-		}
-	}
-
-	if (set->slots) {
-		ret = snd_soc_dai_set_tdm_slot(dai,
-					       set->tx_slot_mask,
-					       set->rx_slot_mask,
-						set->slots,
-						set->slot_width);
-		if (ret && ret != -ENOTSUPP) {
-			dev_err(dai->dev, "simple-card: set_tdm_slot error\n");
-			goto err;
-		}
-	}
-
-	ret = 0;
-
-err:
-	return ret;
-}
-
 static int asoc_simple_card_dai_init(struct snd_soc_pcm_runtime *rtd)
 {
 	struct simple_card_data *priv =	snd_soc_card_get_drvdata(rtd->card);
 	struct snd_soc_dai *codec = rtd->codec_dai;
 	struct snd_soc_dai *cpu = rtd->cpu_dai;
-	struct simple_dai_props *dai_props;
+	struct simple_dai_props *dai_props = &priv->dai_props[rtd->num];
 	int ret;
 
-	dai_props = &priv->dai_props[rtd->num];
-	ret = __asoc_simple_card_dai_init(codec, &dai_props->codec_dai);
+	ret = asoc_simple_card_init_dai(codec, &dai_props->codec_dai);
 	if (ret < 0)
 		return ret;
 
-	ret = __asoc_simple_card_dai_init(cpu, &dai_props->cpu_dai);
+	ret = asoc_simple_card_init_dai(cpu, &dai_props->cpu_dai);
 	if (ret < 0)
 		return ret;
 
@@ -236,78 +206,6 @@
 	return 0;
 }
 
-static int
-asoc_simple_card_sub_parse_of(struct device_node *np,
-			      struct asoc_simple_dai *dai,
-			      struct device_node **p_node,
-			      const char **name,
-			      int *args_count)
-{
-	struct of_phandle_args args;
-	struct clk *clk;
-	u32 val;
-	int ret;
-
-	if (!np)
-		return 0;
-
-	/*
-	 * Get node via "sound-dai = <&phandle port>"
-	 * it will be used as xxx_of_node on soc_bind_dai_link()
-	 */
-	ret = of_parse_phandle_with_args(np, "sound-dai",
-					 "#sound-dai-cells", 0, &args);
-	if (ret)
-		return ret;
-
-	*p_node = args.np;
-
-	if (args_count)
-		*args_count = args.args_count;
-
-	/* Get dai->name */
-	if (name) {
-		ret = snd_soc_of_get_dai_name(np, name);
-		if (ret < 0)
-			return ret;
-	}
-
-	if (!dai)
-		return 0;
-
-	/* Parse TDM slot */
-	ret = snd_soc_of_parse_tdm_slot(np, &dai->tx_slot_mask,
-					&dai->rx_slot_mask,
-					&dai->slots, &dai->slot_width);
-	if (ret)
-		return ret;
-
-	/*
-	 * Parse dai->sysclk come from "clocks = <&xxx>"
-	 * (if system has common clock)
-	 *  or "system-clock-frequency = <xxx>"
-	 *  or device's module clock.
-	 */
-	if (of_property_read_bool(np, "clocks")) {
-		clk = of_clk_get(np, 0);
-		if (IS_ERR(clk)) {
-			ret = PTR_ERR(clk);
-			return ret;
-		}
-
-		dai->sysclk = clk_get_rate(clk);
-		dai->clk = clk;
-	} else if (!of_property_read_u32(np, "system-clock-frequency", &val)) {
-		dai->sysclk = val;
-	} else {
-		clk = of_clk_get(args.np, 0);
-		if (!IS_ERR(clk))
-			dai->sysclk = clk_get_rate(clk);
-	}
-
-	return 0;
-}
-
 static int asoc_simple_card_dai_link_of(struct device_node *node,
 					struct simple_card_data *priv,
 					int idx,
@@ -316,12 +214,14 @@
 	struct device *dev = simple_priv_to_dev(priv);
 	struct snd_soc_dai_link *dai_link = simple_priv_to_link(priv, idx);
 	struct simple_dai_props *dai_props = simple_priv_to_props(priv, idx);
+	struct asoc_simple_dai *cpu_dai = &dai_props->cpu_dai;
+	struct asoc_simple_dai *codec_dai = &dai_props->codec_dai;
 	struct device_node *cpu = NULL;
 	struct device_node *plat = NULL;
 	struct device_node *codec = NULL;
 	char prop[128];
 	char *prefix = "";
-	int ret, cpu_args;
+	int ret, single_cpu;
 	u32 val;
 
 	/* For single DAI link & old style of DT node */
@@ -351,33 +251,44 @@
 	if (!of_property_read_u32(node, "mclk-fs", &val))
 		dai_props->mclk_fs = val;
 
-	ret = asoc_simple_card_sub_parse_of(cpu, &dai_props->cpu_dai,
-					    &dai_link->cpu_of_node,
-					    &dai_link->cpu_dai_name,
-					    &cpu_args);
+	ret = asoc_simple_card_parse_cpu(cpu, dai_link,
+					 DAI, CELL, &single_cpu);
 	if (ret < 0)
 		goto dai_link_of_err;
 
-	ret = asoc_simple_card_sub_parse_of(codec, &dai_props->codec_dai,
-					    &dai_link->codec_of_node,
-					    &dai_link->codec_dai_name, NULL);
+	ret = asoc_simple_card_parse_codec(codec, dai_link, DAI, CELL);
 	if (ret < 0)
 		goto dai_link_of_err;
 
-	ret = asoc_simple_card_sub_parse_of(plat, NULL,
-					    &dai_link->platform_of_node,
-					    NULL, NULL);
+	ret = asoc_simple_card_parse_platform(plat, dai_link, DAI, CELL);
 	if (ret < 0)
 		goto dai_link_of_err;
 
-	if (!dai_link->cpu_dai_name || !dai_link->codec_dai_name) {
-		ret = -EINVAL;
+	ret = snd_soc_of_parse_tdm_slot(cpu,	&cpu_dai->tx_slot_mask,
+						&cpu_dai->rx_slot_mask,
+						&cpu_dai->slots,
+						&cpu_dai->slot_width);
+	if (ret < 0)
 		goto dai_link_of_err;
-	}
 
-	/* Assumes platform == cpu */
-	if (!dai_link->platform_of_node)
-		dai_link->platform_of_node = dai_link->cpu_of_node;
+	ret = snd_soc_of_parse_tdm_slot(codec,	&codec_dai->tx_slot_mask,
+						&codec_dai->rx_slot_mask,
+						&codec_dai->slots,
+						&codec_dai->slot_width);
+	if (ret < 0)
+		goto dai_link_of_err;
+
+	ret = asoc_simple_card_parse_clk_cpu(cpu, dai_link, cpu_dai);
+	if (ret < 0)
+		goto dai_link_of_err;
+
+	ret = asoc_simple_card_parse_clk_codec(codec, dai_link, codec_dai);
+	if (ret < 0)
+		goto dai_link_of_err;
+
+	ret = asoc_simple_card_canonicalize_dailink(dai_link);
+	if (ret < 0)
+		goto dai_link_of_err;
 
 	ret = asoc_simple_card_set_dailink_name(dev, dai_link,
 						"%s-%s",
@@ -398,17 +309,7 @@
 		dai_link->codec_dai_name,
 		dai_props->codec_dai.sysclk);
 
-	/*
-	 * In soc_bind_dai_link() will check cpu name after
-	 * of_node matching if dai_link has cpu_dai_name.
-	 * but, it will never match if name was created by
-	 * fmt_single_name() remove cpu_dai_name if cpu_args
-	 * was 0. See:
-	 *	fmt_single_name()
-	 *	fmt_multiple_name()
-	 */
-	if (!cpu_args)
-		dai_link->cpu_dai_name = NULL;
+	asoc_simple_card_canonicalize_cpu(dai_link, single_cpu);
 
 dai_link_of_err:
 	of_node_put(cpu);
@@ -477,21 +378,6 @@
 	return 0;
 }
 
-/* Decrease the reference count of the device nodes */
-static int asoc_simple_card_unref(struct snd_soc_card *card)
-{
-	struct snd_soc_dai_link *dai_link;
-	int num_links;
-
-	for (num_links = 0, dai_link = card->dai_link;
-	     num_links < card->num_links;
-	     num_links++, dai_link++) {
-		of_node_put(dai_link->cpu_of_node);
-		of_node_put(dai_link->codec_of_node);
-	}
-	return 0;
-}
-
 static int asoc_simple_card_probe(struct platform_device *pdev)
 {
 	struct simple_card_data *priv;
@@ -577,7 +463,7 @@
 		return ret;
 
 err:
-	asoc_simple_card_unref(&priv->snd_card);
+	asoc_simple_card_clean_reference(&priv->snd_card);
 	return ret;
 }
 
@@ -589,7 +475,7 @@
 	asoc_simple_card_remove_jack(&priv->hp_jack);
 	asoc_simple_card_remove_jack(&priv->mic_jack);
 
-	return asoc_simple_card_unref(card);
+	return asoc_simple_card_clean_reference(card);
 }
 
 static const struct of_device_id asoc_simple_of_match[] = {
diff -uwr linux-4.8-rc4.new/sound/soc/generic/simple-card-utils.c linux-4.8-rc4.orig/sound/soc/generic/simple-card-utils.c
--- linux-4.8-rc4.new/sound/soc/generic/simple-card-utils.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/generic/simple-card-utils.c	2016-09-04 01:14:38.220051629 +0000
@@ -7,6 +7,7 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
+#include <linux/clk.h>
 #include <linux/module.h>
 #include <linux/of.h>
 #include <sound/simple_card_utils.h>
@@ -97,6 +98,146 @@
 }
 EXPORT_SYMBOL_GPL(asoc_simple_card_parse_card_name);
 
+int asoc_simple_card_parse_clk(struct device_node *node,
+			       struct device_node *dai_of_node,
+			       struct asoc_simple_dai *simple_dai)
+{
+	struct clk *clk;
+	u32 val;
+
+	/*
+	 * Parse dai->sysclk come from "clocks = <&xxx>"
+	 * (if system has common clock)
+	 *  or "system-clock-frequency = <xxx>"
+	 *  or device's module clock.
+	 */
+	clk = of_clk_get(node, 0);
+	if (!IS_ERR(clk)) {
+		simple_dai->sysclk = clk_get_rate(clk);
+		simple_dai->clk = clk;
+	} else if (!of_property_read_u32(node, "system-clock-frequency", &val)) {
+		simple_dai->sysclk = val;
+	} else {
+		clk = of_clk_get(dai_of_node, 0);
+		if (!IS_ERR(clk))
+			simple_dai->sysclk = clk_get_rate(clk);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(asoc_simple_card_parse_clk);
+
+int asoc_simple_card_parse_dai(struct device_node *node,
+				    struct device_node **dai_of_node,
+				    const char **dai_name,
+				    const char *list_name,
+				    const char *cells_name,
+				    int *is_single_link)
+{
+	struct of_phandle_args args;
+	int ret;
+
+	if (!node)
+		return 0;
+
+	/*
+	 * Get node via "sound-dai = <&phandle port>"
+	 * it will be used as xxx_of_node on soc_bind_dai_link()
+	 */
+	ret = of_parse_phandle_with_args(node, list_name, cells_name, 0, &args);
+	if (ret)
+		return ret;
+
+	/* Get dai->name */
+	if (dai_name) {
+		ret = snd_soc_of_get_dai_name(node, dai_name);
+		if (ret < 0)
+			return ret;
+	}
+
+	*dai_of_node = args.np;
+
+	if (is_single_link)
+		*is_single_link = !args.args_count;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(asoc_simple_card_parse_dai);
+
+int asoc_simple_card_init_dai(struct snd_soc_dai *dai,
+			      struct asoc_simple_dai *simple_dai)
+{
+	int ret;
+
+	if (simple_dai->sysclk) {
+		ret = snd_soc_dai_set_sysclk(dai, 0, simple_dai->sysclk, 0);
+		if (ret && ret != -ENOTSUPP) {
+			dev_err(dai->dev, "simple-card: set_sysclk error\n");
+			return ret;
+		}
+	}
+
+	if (simple_dai->slots) {
+		ret = snd_soc_dai_set_tdm_slot(dai,
+					       simple_dai->tx_slot_mask,
+					       simple_dai->rx_slot_mask,
+					       simple_dai->slots,
+					       simple_dai->slot_width);
+		if (ret && ret != -ENOTSUPP) {
+			dev_err(dai->dev, "simple-card: set_tdm_slot error\n");
+			return ret;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(asoc_simple_card_init_dai);
+
+int asoc_simple_card_canonicalize_dailink(struct snd_soc_dai_link *dai_link)
+{
+	if (!dai_link->cpu_dai_name || !dai_link->codec_dai_name)
+		return -EINVAL;
+
+	/* Assumes platform == cpu */
+	if (!dai_link->platform_of_node)
+		dai_link->platform_of_node = dai_link->cpu_of_node;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(asoc_simple_card_canonicalize_dailink);
+
+void asoc_simple_card_canonicalize_cpu(struct snd_soc_dai_link *dai_link,
+				       int is_single_links)
+{
+	/*
+	 * In soc_bind_dai_link() will check cpu name after
+	 * of_node matching if dai_link has cpu_dai_name.
+	 * but, it will never match if name was created by
+	 * fmt_single_name() remove cpu_dai_name if cpu_args
+	 * was 0. See:
+	 *	fmt_single_name()
+	 *	fmt_multiple_name()
+	 */
+	if (is_single_links)
+		dai_link->cpu_dai_name = NULL;
+}
+EXPORT_SYMBOL_GPL(asoc_simple_card_canonicalize_cpu);
+
+int asoc_simple_card_clean_reference(struct snd_soc_card *card)
+{
+	struct snd_soc_dai_link *dai_link;
+	int num_links;
+
+	for (num_links = 0, dai_link = card->dai_link;
+	     num_links < card->num_links;
+	     num_links++, dai_link++) {
+		of_node_put(dai_link->cpu_of_node);
+		of_node_put(dai_link->codec_of_node);
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(asoc_simple_card_clean_reference);
+
 /* Module information */
 MODULE_AUTHOR("Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>");
 MODULE_DESCRIPTION("ALSA SoC Simple Card Utils");
diff -uwr linux-4.8-rc4.new/sound/soc/img/pistachio-internal-dac.c linux-4.8-rc4.orig/sound/soc/img/pistachio-internal-dac.c
--- linux-4.8-rc4.new/sound/soc/img/pistachio-internal-dac.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/img/pistachio-internal-dac.c	2016-09-04 01:14:32.132272575 +0000
@@ -134,12 +134,14 @@
 static const struct snd_soc_codec_driver pistachio_internal_dac_driver = {
 	.probe = pistachio_internal_dac_codec_probe,
 	.idle_bias_off = true,
+	.component_driver = {
 	.controls = pistachio_internal_dac_snd_controls,
 	.num_controls = ARRAY_SIZE(pistachio_internal_dac_snd_controls),
 	.dapm_widgets = pistachio_internal_dac_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(pistachio_internal_dac_widgets),
 	.dapm_routes = pistachio_internal_dac_routes,
 	.num_dapm_routes = ARRAY_SIZE(pistachio_internal_dac_routes),
+	},
 };
 
 static int pistachio_internal_dac_probe(struct platform_device *pdev)
diff -uwr linux-4.8-rc4.new/sound/soc/intel/atom/sst/sst_acpi.c linux-4.8-rc4.orig/sound/soc/intel/atom/sst/sst_acpi.c
--- linux-4.8-rc4.new/sound/soc/intel/atom/sst/sst_acpi.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/intel/atom/sst/sst_acpi.c	2016-09-04 01:14:45.239796857 +0000
@@ -39,6 +39,8 @@
 #include <acpi/platform/aclinux.h>
 #include <acpi/actypes.h>
 #include <acpi/acpi_bus.h>
+#include <asm/cpu_device_id.h>
+#include <asm/iosf_mbi.h>
 #include "../sst-mfld-platform.h"
 #include "../../common/sst-dsp.h"
 #include "../../common/sst-acpi.h"
@@ -113,6 +115,28 @@
 	.acpi_ipc_irq_index = 5,
 };
 
+/* BYTCR has different BIOS from BYT */
+static const struct sst_res_info bytcr_res_info = {
+	.shim_offset = 0x140000,
+	.shim_size = 0x000100,
+	.shim_phy_addr = SST_BYT_SHIM_PHY_ADDR,
+	.ssp0_offset = 0xa0000,
+	.ssp0_size = 0x1000,
+	.dma0_offset = 0x98000,
+	.dma0_size = 0x4000,
+	.dma1_offset = 0x9c000,
+	.dma1_size = 0x4000,
+	.iram_offset = 0x0c0000,
+	.iram_size = 0x14000,
+	.dram_offset = 0x100000,
+	.dram_size = 0x28000,
+	.mbox_offset = 0x144000,
+	.mbox_size = 0x1000,
+	.acpi_lpe_res_index = 0,
+	.acpi_ddr_index = 2,
+	.acpi_ipc_irq_index = 0
+};
+
 static struct sst_platform_info byt_rvp_platform_data = {
 	.probe_data = &byt_fwparse_info,
 	.ipc_info = &byt_ipc_info,
@@ -215,6 +239,47 @@
 	return 0;
 }
 
+
+static int is_byt_cr(struct device *dev, bool *bytcr)
+{
+	int status = 0;
+
+	if (IS_ENABLED(CONFIG_IOSF_MBI)) {
+		static const struct x86_cpu_id cpu_ids[] = {
+			{ X86_VENDOR_INTEL, 6, 55 }, /* Valleyview, Bay Trail */
+			{}
+		};
+		int status;
+		u32 bios_status;
+
+		if (!x86_match_cpu(cpu_ids) || !iosf_mbi_available()) {
+			/* bail silently */
+			return status;
+		}
+
+		status = iosf_mbi_read(BT_MBI_UNIT_PMC, /* 0x04 PUNIT */
+				       MBI_REG_READ, /* 0x10 */
+				       0x006, /* BIOS_CONFIG */
+				       &bios_status);
+
+		if (status) {
+			dev_err(dev, "could not read PUNIT BIOS_CONFIG\n");
+		} else {
+			/* bits 26:27 mirror PMIC options */
+			bios_status = (bios_status >> 26) & 3;
+
+			if ((bios_status == 1) || (bios_status == 3))
+				*bytcr = true;
+			else
+				dev_info(dev, "BYT-CR not detected\n");
+		}
+	} else {
+		dev_info(dev, "IOSF_MBI not enabled, no BYT-CR detection\n");
+	}
+	return status;
+}
+
+
 static int sst_acpi_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -226,6 +291,7 @@
 	struct platform_device *plat_dev;
 	struct sst_platform_info *pdata;
 	unsigned int dev_id;
+	bool bytcr = false;
 
 	id = acpi_match_device(dev->driver->acpi_match_table, dev);
 	if (!id)
@@ -251,6 +317,18 @@
 
 	dev_dbg(dev, "ACPI device id: %x\n", dev_id);
 
+	ret = sst_alloc_drv_context(&ctx, dev, dev_id);
+	if (ret < 0)
+		return ret;
+
+	ret = is_byt_cr(dev, &bytcr);
+	if (!((ret < 0) || (bytcr == false))) {
+		dev_info(dev, "Detected Baytrail-CR platform\n");
+
+		/* override resource info */
+		byt_rvp_platform_data.res_info = &bytcr_res_info;
+	}
+
 	plat_dev = platform_device_register_data(dev, pdata->platform, -1,
 						NULL, 0);
 	if (IS_ERR(plat_dev)) {
@@ -271,10 +349,6 @@
 		return PTR_ERR(mdev);
 	}
 
-	ret = sst_alloc_drv_context(&ctx, dev, dev_id);
-	if (ret < 0)
-		return ret;
-
 	/* Fill sst platform data */
 	ctx->pdata = pdata;
 	strcpy(ctx->firmware_name, mach->fw_filename);
diff -uwr linux-4.8-rc4.new/sound/soc/intel/atom/sst/sst.c linux-4.8-rc4.orig/sound/soc/intel/atom/sst/sst.c
--- linux-4.8-rc4.new/sound/soc/intel/atom/sst/sst.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/intel/atom/sst/sst.c	2016-09-04 01:14:45.259796131 +0000
@@ -190,7 +190,8 @@
 
 	default:
 		dev_err(sst->dev,
-			"SST Driver capablities missing for dev_id: %x", sst->dev_id);
+			"SST Driver capabilities missing for dev_id: %x",
+			sst->dev_id);
 		return -EINVAL;
 	};
 }
diff -uwr linux-4.8-rc4.new/sound/soc/intel/atom/sst-atom-controls.c linux-4.8-rc4.orig/sound/soc/intel/atom/sst-atom-controls.c
--- linux-4.8-rc4.new/sound/soc/intel/atom/sst-atom-controls.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/intel/atom/sst-atom-controls.c	2016-09-04 01:14:42.563893975 +0000
@@ -534,6 +534,7 @@
 
 /* Look up table to convert MIXER SW bit regs to SWM inputs */
 static const uint swm_mixer_input_ids[SST_SWM_INPUT_COUNT] = {
+	[SST_IP_MODEM]		= SST_SWM_IN_MODEM,
 	[SST_IP_CODEC0]		= SST_SWM_IN_CODEC0,
 	[SST_IP_CODEC1]		= SST_SWM_IN_CODEC1,
 	[SST_IP_LOOP0]		= SST_SWM_IN_SPROT_LOOP,
@@ -674,6 +675,7 @@
 /* SBA mixers - 16 inputs */
 #define SST_SBA_DECLARE_MIX_CONTROLS(kctl_name)							\
 	static const struct snd_kcontrol_new kctl_name[] = {					\
+		SOC_DAPM_SINGLE("modem_in Switch", SND_SOC_NOPM, SST_IP_MODEM, 1, 0),		\
 		SOC_DAPM_SINGLE("codec_in0 Switch", SND_SOC_NOPM, SST_IP_CODEC0, 1, 0),		\
 		SOC_DAPM_SINGLE("codec_in1 Switch", SND_SOC_NOPM, SST_IP_CODEC1, 1, 0),		\
 		SOC_DAPM_SINGLE("sprot_loop_in Switch", SND_SOC_NOPM, SST_IP_LOOP0, 1, 0),	\
@@ -684,6 +686,7 @@
 	}
 
 #define SST_SBA_MIXER_GRAPH_MAP(mix_name)			\
+	{ mix_name, "modem_in Switch",	"modem_in" },		\
 	{ mix_name, "codec_in0 Switch",	"codec_in0" },		\
 	{ mix_name, "codec_in1 Switch",	"codec_in1" },		\
 	{ mix_name, "sprot_loop_in Switch",	"sprot_loop_in" },	\
@@ -713,6 +716,7 @@
 SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_voip_controls);
 SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_codec0_controls);
 SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_codec1_controls);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_modem_controls);
 
 /*
  * sst_handle_vb_timer - Start/Stop the DSP scheduler
@@ -931,17 +935,26 @@
 int send_ssp_cmd(struct snd_soc_dai *dai, const char *id, bool enable)
 {
 	struct sst_data *drv = snd_soc_dai_get_drvdata(dai);
-	const struct sst_ssp_config *config;
+	int ssp_id;
 
 	dev_info(dai->dev, "Enter: enable=%d port_name=%s\n", enable, id);
 
+	if (strcmp(id, "ssp0-port") == 0)
+		ssp_id = SSP_MODEM;
+	else if (strcmp(id, "ssp2-port") == 0)
+		ssp_id = SSP_CODEC;
+	else {
+		dev_dbg(dai->dev, "port %s is not supported\n", id);
+		return -1;
+	}
+
 	SST_FILL_DEFAULT_DESTINATION(drv->ssp_cmd.header.dst);
 	drv->ssp_cmd.header.command_id = SBA_HW_SET_SSP;
 	drv->ssp_cmd.header.length = sizeof(struct sst_cmd_sba_hw_set_ssp)
 				- sizeof(struct sst_dsp_header);
 
-	config = &sst_ssp_configs;
-	dev_dbg(dai->dev, "ssp_id: %u\n", config->ssp_id);
+	drv->ssp_cmd.selection = ssp_id;
+	dev_dbg(dai->dev, "ssp_id: %u\n", ssp_id);
 
 	if (enable)
 		drv->ssp_cmd.switch_state = SST_SWITCH_ON;
@@ -1047,8 +1060,10 @@
 }
 
 static const struct snd_soc_dapm_widget sst_dapm_widgets[] = {
+	SST_AIF_IN("modem_in", sst_set_be_modules),
 	SST_AIF_IN("codec_in0", sst_set_be_modules),
 	SST_AIF_IN("codec_in1", sst_set_be_modules),
+	SST_AIF_OUT("modem_out", sst_set_be_modules),
 	SST_AIF_OUT("codec_out0", sst_set_be_modules),
 	SST_AIF_OUT("codec_out1", sst_set_be_modules),
 
@@ -1103,6 +1118,9 @@
 		      sst_mix_codec0_controls, sst_swm_mixer_event),
 	SST_SWM_MIXER("codec_out1 mix 0", SND_SOC_NOPM, SST_TASK_SBA, SST_SWM_OUT_CODEC1,
 		      sst_mix_codec1_controls, sst_swm_mixer_event),
+	SST_SWM_MIXER("modem_out mix 0", SND_SOC_NOPM, SST_TASK_SBA, SST_SWM_OUT_MODEM,
+		      sst_mix_modem_controls, sst_swm_mixer_event),
+
 };
 
 static const struct snd_soc_dapm_route intercon[] = {
@@ -1148,6 +1166,9 @@
 	SST_SBA_MIXER_GRAPH_MAP("codec_out0 mix 0"),
 	{"codec_out1", NULL, "codec_out1 mix 0"},
 	SST_SBA_MIXER_GRAPH_MAP("codec_out1 mix 0"),
+	{"modem_out", NULL, "modem_out mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("modem_out mix 0"),
+
 
 };
 static const char * const slot_names[] = {
@@ -1217,6 +1238,9 @@
 	SST_GAIN("media_loop2_out", SST_PATH_INDEX_MEDIA_LOOP2_OUT, SST_TASK_SBA, 0, &sst_gains[13]),
 	SST_GAIN("sprot_loop_out", SST_PATH_INDEX_SPROT_LOOP_OUT, SST_TASK_SBA, 0, &sst_gains[14]),
 	SST_VOLUME("media0_in", SST_PATH_INDEX_MEDIA0_IN, SST_TASK_MMX, 0, &sst_gains[15]),
+	SST_GAIN("modem_in", SST_PATH_INDEX_MODEM_IN, SST_TASK_SBA, 0, &sst_gains[16]),
+	SST_GAIN("modem_out", SST_PATH_INDEX_MODEM_OUT, SST_TASK_SBA, 0, &sst_gains[17]),
+
 };
 
 #define SST_GAIN_NUM_CONTROLS 3
diff -uwr linux-4.8-rc4.new/sound/soc/intel/atom/sst-atom-controls.h linux-4.8-rc4.orig/sound/soc/intel/atom/sst-atom-controls.h
--- linux-4.8-rc4.new/sound/soc/intel/atom/sst-atom-controls.h	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/intel/atom/sst-atom-controls.h	2016-09-04 01:14:42.559894120 +0000
@@ -35,6 +35,8 @@
 /* define a bit for each mixer input */
 #define SST_MIX_IP(x)		(x)
 
+#define SST_IP_MODEM		SST_MIX_IP(0)
+#define SST_IP_BT		SST_MIX_IP(1)
 #define SST_IP_CODEC0		SST_MIX_IP(2)
 #define SST_IP_CODEC1		SST_MIX_IP(3)
 #define SST_IP_LOOP0		SST_MIX_IP(4)
@@ -63,6 +65,7 @@
  * Audio DSP Path Ids. Specified by the audio DSP FW
  */
 enum sst_path_index {
+	SST_PATH_INDEX_MODEM_OUT                = (0x00 << SST_PATH_ID_SHIFT),
 	SST_PATH_INDEX_CODEC_OUT0               = (0x02 << SST_PATH_ID_SHIFT),
 	SST_PATH_INDEX_CODEC_OUT1               = (0x03 << SST_PATH_ID_SHIFT),
 
@@ -80,6 +83,7 @@
 
 
 	/* Start of input paths */
+	SST_PATH_INDEX_MODEM_IN                 = (0x80 << SST_PATH_ID_SHIFT),
 	SST_PATH_INDEX_CODEC_IN0                = (0x82 << SST_PATH_ID_SHIFT),
 	SST_PATH_INDEX_CODEC_IN1                = (0x83 << SST_PATH_ID_SHIFT),
 
@@ -105,6 +109,7 @@
  * path IDs
  */
 enum sst_swm_inputs {
+	SST_SWM_IN_MODEM	= (SST_PATH_INDEX_MODEM_IN	  | SST_DEFAULT_CELL_NBR),
 	SST_SWM_IN_CODEC0	= (SST_PATH_INDEX_CODEC_IN0	  | SST_DEFAULT_CELL_NBR),
 	SST_SWM_IN_CODEC1	= (SST_PATH_INDEX_CODEC_IN1	  | SST_DEFAULT_CELL_NBR),
 	SST_SWM_IN_SPROT_LOOP	= (SST_PATH_INDEX_SPROT_LOOP_IN	  | SST_DEFAULT_CELL_NBR),
@@ -124,6 +129,7 @@
  * path IDs
  */
 enum sst_swm_outputs {
+	SST_SWM_OUT_MODEM	= (SST_PATH_INDEX_MODEM_OUT	  | SST_DEFAULT_CELL_NBR),
 	SST_SWM_OUT_CODEC0	= (SST_PATH_INDEX_CODEC_OUT0	  | SST_DEFAULT_CELL_NBR),
 	SST_SWM_OUT_CODEC1	= (SST_PATH_INDEX_CODEC_OUT1	  | SST_DEFAULT_CELL_NBR),
 	SST_SWM_OUT_SPROT_LOOP	= (SST_PATH_INDEX_SPROT_LOOP_OUT  | SST_DEFAULT_CELL_NBR),
diff -uwr linux-4.8-rc4.new/sound/soc/intel/boards/bytcr_rt5640.c linux-4.8-rc4.orig/sound/soc/intel/boards/bytcr_rt5640.c
--- linux-4.8-rc4.new/sound/soc/intel/boards/bytcr_rt5640.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/intel/boards/bytcr_rt5640.c	2016-09-04 01:22:35.974712227 +0000
@@ -24,6 +24,9 @@
 #include <linux/device.h>
 #include <linux/dmi.h>
 #include <linux/slab.h>
+#include <asm/cpu_device_id.h>
+#include <asm/platform_sst_audio.h>
+#include <linux/clk.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/soc.h>
@@ -31,42 +34,153 @@
 #include "../../codecs/rt5640.h"
 #include "../atom/sst-atom-controls.h"
 #include "../common/sst-acpi.h"
+#include "../common/sst-dsp.h"
 
 enum {
 	BYT_RT5640_DMIC1_MAP,
 	BYT_RT5640_DMIC2_MAP,
 	BYT_RT5640_IN1_MAP,
+	BYT_RT5640_IN3_MAP,
 };
 
 #define BYT_RT5640_MAP(quirk)	((quirk) & 0xff)
 #define BYT_RT5640_DMIC_EN	BIT(16)
+#define BYT_RT5640_MONO_SPEAKER BIT(17)
+#define BYT_RT5640_DIFF_MIC     BIT(18) /* defaut is single-ended */
+#define BYT_RT5640_SSP2_AIF2     BIT(19) /* default is using AIF1  */
+#define BYT_RT5640_SSP0_AIF1     BIT(20)
+#define BYT_RT5640_SSP0_AIF2     BIT(21)
+#define BYT_RT5640_MCLK_EN	BIT(22)
+#define BYT_RT5640_MCLK_25MHZ	BIT(23)
+
+struct byt_rt5640_private {
+	struct clk *mclk;
+};
 
 static unsigned long byt_rt5640_quirk = BYT_RT5640_DMIC1_MAP |
-					BYT_RT5640_DMIC_EN;
+					BYT_RT5640_DMIC_EN |
+					BYT_RT5640_MCLK_EN;
+
+static void log_quirks(struct device *dev)
+{
+	if (BYT_RT5640_MAP(byt_rt5640_quirk) == BYT_RT5640_DMIC1_MAP)
+		dev_info(dev, "quirk DMIC1_MAP enabled");
+	if (BYT_RT5640_MAP(byt_rt5640_quirk) == BYT_RT5640_DMIC2_MAP)
+		dev_info(dev, "quirk DMIC2_MAP enabled");
+	if (BYT_RT5640_MAP(byt_rt5640_quirk) == BYT_RT5640_IN1_MAP)
+		dev_info(dev, "quirk IN1_MAP enabled");
+	if (BYT_RT5640_MAP(byt_rt5640_quirk) == BYT_RT5640_IN3_MAP)
+		dev_info(dev, "quirk IN3_MAP enabled");
+	if (byt_rt5640_quirk & BYT_RT5640_DMIC_EN)
+		dev_info(dev, "quirk DMIC enabled");
+	if (byt_rt5640_quirk & BYT_RT5640_MONO_SPEAKER)
+		dev_info(dev, "quirk MONO_SPEAKER enabled");
+	if (byt_rt5640_quirk & BYT_RT5640_DIFF_MIC)
+		dev_info(dev, "quirk DIFF_MIC enabled");
+	if (byt_rt5640_quirk & BYT_RT5640_SSP2_AIF2)
+		dev_info(dev, "quirk SSP2_AIF2 enabled");
+	if (byt_rt5640_quirk & BYT_RT5640_SSP0_AIF1)
+		dev_info(dev, "quirk SSP0_AIF1 enabled");
+	if (byt_rt5640_quirk & BYT_RT5640_SSP0_AIF2)
+		dev_info(dev, "quirk SSP0_AIF2 enabled");
+	if (byt_rt5640_quirk & BYT_RT5640_MCLK_EN)
+		dev_info(dev, "quirk MCLK_EN enabled");
+	if (byt_rt5640_quirk & BYT_RT5640_MCLK_25MHZ)
+		dev_info(dev, "quirk MCLK_25MHZ enabled");
+}
+
+
+#define BYT_CODEC_DAI1	"rt5640-aif1"
+#define BYT_CODEC_DAI2	"rt5640-aif2"
+
+static inline struct snd_soc_dai *byt_get_codec_dai(struct snd_soc_card *card)
+{
+	struct snd_soc_pcm_runtime *rtd;
+
+	list_for_each_entry(rtd, &card->rtd_list, list) {
+		if (!strncmp(rtd->codec_dai->name, BYT_CODEC_DAI1,
+			     strlen(BYT_CODEC_DAI1)))
+			return rtd->codec_dai;
+		if (!strncmp(rtd->codec_dai->name, BYT_CODEC_DAI2,
+				strlen(BYT_CODEC_DAI2)))
+			return rtd->codec_dai;
+
+	}
+	return NULL;
+}
+
+static int platform_clock_control(struct snd_soc_dapm_widget *w,
+				  struct snd_kcontrol *k, int  event)
+{
+	struct snd_soc_dapm_context *dapm = w->dapm;
+	struct snd_soc_card *card = dapm->card;
+	struct snd_soc_dai *codec_dai;
+	struct byt_rt5640_private *priv = snd_soc_card_get_drvdata(card);
+	int ret;
+
+	codec_dai = byt_get_codec_dai(card);
+	if (!codec_dai) {
+		dev_err(card->dev,
+			"Codec dai not found; Unable to set platform clock\n");
+		return -EIO;
+	}
+
+	if (SND_SOC_DAPM_EVENT_ON(event)) {
+		if ((byt_rt5640_quirk & BYT_RT5640_MCLK_EN) && priv->mclk) {
+			ret = clk_prepare_enable(priv->mclk);
+			if (ret < 0) {
+				dev_err(card->dev,
+					"could not configure MCLK state");
+				return ret;
+			}
+		}
+		ret = snd_soc_dai_set_sysclk(codec_dai, RT5640_SCLK_S_PLL1,
+					     48000 * 512,
+					     SND_SOC_CLOCK_IN);
+	} else {
+		/*
+		 * Set codec clock source to internal clock before
+		 * turning off the platform clock. Codec needs clock
+		 * for Jack detection and button press
+		 */
+		ret = snd_soc_dai_set_sysclk(codec_dai, RT5640_SCLK_S_RCCLK,
+					     0,
+					     SND_SOC_CLOCK_IN);
+		if (!ret) {
+			if ((byt_rt5640_quirk & BYT_RT5640_MCLK_EN) && priv->mclk)
+				clk_disable_unprepare(priv->mclk);
+		}
+	}
+
+	if (ret < 0) {
+		dev_err(card->dev, "can't set codec sysclk: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
 
 static const struct snd_soc_dapm_widget byt_rt5640_widgets[] = {
 	SND_SOC_DAPM_HP("Headphone", NULL),
 	SND_SOC_DAPM_MIC("Headset Mic", NULL),
 	SND_SOC_DAPM_MIC("Internal Mic", NULL),
 	SND_SOC_DAPM_SPK("Speaker", NULL),
+	SND_SOC_DAPM_SUPPLY("Platform Clock", SND_SOC_NOPM, 0, 0,
+			    platform_clock_control, SND_SOC_DAPM_PRE_PMU |
+			    SND_SOC_DAPM_POST_PMD),
+
 };
 
 static const struct snd_soc_dapm_route byt_rt5640_audio_map[] = {
-	{"AIF1 Playback", NULL, "ssp2 Tx"},
-	{"ssp2 Tx", NULL, "codec_out0"},
-	{"ssp2 Tx", NULL, "codec_out1"},
-	{"codec_in0", NULL, "ssp2 Rx"},
-	{"codec_in1", NULL, "ssp2 Rx"},
-	{"ssp2 Rx", NULL, "AIF1 Capture"},
+	{"Headphone", NULL, "Platform Clock"},
+	{"Headset Mic", NULL, "Platform Clock"},
+	{"Internal Mic", NULL, "Platform Clock"},
+	{"Speaker", NULL, "Platform Clock"},
 
 	{"Headset Mic", NULL, "MICBIAS1"},
 	{"IN2P", NULL, "Headset Mic"},
 	{"Headphone", NULL, "HPOL"},
 	{"Headphone", NULL, "HPOR"},
-	{"Speaker", NULL, "SPOLP"},
-	{"Speaker", NULL, "SPOLN"},
-	{"Speaker", NULL, "SPORP"},
-	{"Speaker", NULL, "SPORN"},
 };
 
 static const struct snd_soc_dapm_route byt_rt5640_intmic_dmic1_map[] = {
@@ -82,6 +196,59 @@
 	{"IN1P", NULL, "Internal Mic"},
 };
 
+static const struct snd_soc_dapm_route byt_rt5640_intmic_in3_map[] = {
+	{"Internal Mic", NULL, "MICBIAS1"},
+	{"IN3P", NULL, "Internal Mic"},
+};
+
+static const struct snd_soc_dapm_route byt_rt5640_ssp2_aif1_map[] = {
+	{"ssp2 Tx", NULL, "codec_out0"},
+	{"ssp2 Tx", NULL, "codec_out1"},
+	{"codec_in0", NULL, "ssp2 Rx"},
+	{"codec_in1", NULL, "ssp2 Rx"},
+
+	{"AIF1 Playback", NULL, "ssp2 Tx"},
+	{"ssp2 Rx", NULL, "AIF1 Capture"},
+};
+
+static const struct snd_soc_dapm_route byt_rt5640_ssp2_aif2_map[] = {
+	{"ssp2 Tx", NULL, "codec_out0"},
+	{"ssp2 Tx", NULL, "codec_out1"},
+	{"codec_in0", NULL, "ssp2 Rx"},
+	{"codec_in1", NULL, "ssp2 Rx"},
+
+	{"AIF2 Playback", NULL, "ssp2 Tx"},
+	{"ssp2 Rx", NULL, "AIF2 Capture"},
+};
+
+static const struct snd_soc_dapm_route byt_rt5640_ssp0_aif1_map[] = {
+	{"ssp0 Tx", NULL, "modem_out"},
+	{"modem_in", NULL, "ssp0 Rx"},
+
+	{"AIF1 Playback", NULL, "ssp0 Tx"},
+	{"ssp0 Rx", NULL, "AIF1 Capture"},
+};
+
+static const struct snd_soc_dapm_route byt_rt5640_ssp0_aif2_map[] = {
+	{"ssp0 Tx", NULL, "modem_out"},
+	{"modem_in", NULL, "ssp0 Rx"},
+
+	{"AIF2 Playback", NULL, "ssp0 Tx"},
+	{"ssp0 Rx", NULL, "AIF2 Capture"},
+};
+
+static const struct snd_soc_dapm_route byt_rt5640_stereo_spk_map[] = {
+	{"Speaker", NULL, "SPOLP"},
+	{"Speaker", NULL, "SPOLN"},
+	{"Speaker", NULL, "SPORP"},
+	{"Speaker", NULL, "SPORN"},
+};
+
+static const struct snd_soc_dapm_route byt_rt5640_mono_spk_map[] = {
+	{"Speaker", NULL, "SPOLP"},
+	{"Speaker", NULL, "SPOLN"},
+};
+
 static const struct snd_kcontrol_new byt_rt5640_controls[] = {
 	SOC_DAPM_PIN_SWITCH("Headphone"),
 	SOC_DAPM_PIN_SWITCH("Headset Mic"),
@@ -96,19 +263,46 @@
 	struct snd_soc_dai *codec_dai = rtd->codec_dai;
 	int ret;
 
-	snd_soc_dai_set_bclk_ratio(codec_dai, 50);
-
 	ret = snd_soc_dai_set_sysclk(codec_dai, RT5640_SCLK_S_PLL1,
 				     params_rate(params) * 512,
 				     SND_SOC_CLOCK_IN);
+
 	if (ret < 0) {
 		dev_err(rtd->dev, "can't set codec clock %d\n", ret);
 		return ret;
 	}
 
-	ret = snd_soc_dai_set_pll(codec_dai, 0, RT5640_PLL1_S_BCLK1,
+	if (!(byt_rt5640_quirk & BYT_RT5640_MCLK_EN)) {
+		/* use bitclock as PLL input */
+		if ((byt_rt5640_quirk & BYT_RT5640_SSP0_AIF1) ||
+			(byt_rt5640_quirk & BYT_RT5640_SSP0_AIF2)) {
+
+			/* 2x16 bit slots on SSP0 */
+			ret = snd_soc_dai_set_pll(codec_dai, 0,
+						RT5640_PLL1_S_BCLK1,
+						params_rate(params) * 32,
+						params_rate(params) * 512);
+		} else {
+			/* 2x15 bit slots on SSP2 */
+			ret = snd_soc_dai_set_pll(codec_dai, 0,
+						RT5640_PLL1_S_BCLK1,
 				  params_rate(params) * 50,
 				  params_rate(params) * 512);
+		}
+	} else {
+		if (byt_rt5640_quirk & BYT_RT5640_MCLK_25MHZ) {
+			ret = snd_soc_dai_set_pll(codec_dai, 0,
+						RT5640_PLL1_S_MCLK,
+						25000000,
+						params_rate(params) * 512);
+		} else {
+			ret = snd_soc_dai_set_pll(codec_dai, 0,
+						RT5640_PLL1_S_MCLK,
+						19200000,
+						params_rate(params) * 512);
+		}
+	}
+
 	if (ret < 0) {
 		dev_err(rtd->dev, "can't set codec pll: %d\n", ret);
 		return ret;
@@ -127,27 +321,73 @@
 	{
 		.callback = byt_rt5640_quirk_cb,
 		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK COMPUTER INC."),
-			DMI_MATCH(DMI_PRODUCT_NAME, "T100TA"),
+			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ASUSTeK COMPUTER INC."),
+			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "T100TA"),
+		},
+		.driver_data = (unsigned long *)(BYT_RT5640_IN1_MAP |
+						 BYT_RT5640_MCLK_EN),
+	},
+	{
+		.callback = byt_rt5640_quirk_cb,
+		.matches = {
+			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ASUSTeK COMPUTER INC."),
+			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "T100TAF"),
 		},
-		.driver_data = (unsigned long *)BYT_RT5640_IN1_MAP,
+		.driver_data = (unsigned long *)(BYT_RT5640_IN1_MAP |
+						 BYT_RT5640_MONO_SPEAKER |
+						 BYT_RT5640_DIFF_MIC |
+						 BYT_RT5640_SSP0_AIF2 |
+						 BYT_RT5640_MCLK_EN
+						 ),
 	},
 	{
 		.callback = byt_rt5640_quirk_cb,
 		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "DellInc."),
-			DMI_MATCH(DMI_PRODUCT_NAME, "Venue 8 Pro 5830"),
+			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "DellInc."),
+			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "Venue 8 Pro 5830"),
 		},
 		.driver_data = (unsigned long *)(BYT_RT5640_DMIC2_MAP |
+						 BYT_RT5640_DMIC_EN |
+						 BYT_RT5640_MCLK_EN),
+	},
+	{
+		.callback = byt_rt5640_quirk_cb,
+		.matches = {
+			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
+			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "HP ElitePad 1000 G2"),
+		},
+		.driver_data = (unsigned long *)(BYT_RT5640_IN1_MAP |
+						 BYT_RT5640_MCLK_EN),
+	},
+	{
+		.callback = byt_rt5640_quirk_cb,
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Circuitco"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Minnowboard Max B3 PLATFORM"),
+		},
+		.driver_data = (unsigned long *)(BYT_RT5640_DMIC1_MAP |
 						 BYT_RT5640_DMIC_EN),
 	},
 	{
 		.callback = byt_rt5640_quirk_cb,
 		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
-			DMI_MATCH(DMI_PRODUCT_NAME, "HP ElitePad 1000 G2"),
+			DMI_MATCH(DMI_BOARD_VENDOR, "TECLAST"),
+			DMI_MATCH(DMI_BOARD_NAME, "tPAD"),
 		},
-		.driver_data = (unsigned long *)BYT_RT5640_IN1_MAP,
+		.driver_data = (unsigned long *)(BYT_RT5640_IN3_MAP |
+						BYT_RT5640_MCLK_EN |
+						BYT_RT5640_SSP0_AIF1),
+	},
+	{
+		.callback = byt_rt5640_quirk_cb,
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Acer"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Aspire SW5-012"),
+		},
+		.driver_data = (unsigned long *)(BYT_RT5640_IN1_MAP |
+						 BYT_RT5640_MCLK_EN |
+						 BYT_RT5640_SSP0_AIF1),
+
 	},
 	{}
 };
@@ -158,13 +398,18 @@
 	struct snd_soc_codec *codec = runtime->codec;
 	struct snd_soc_card *card = runtime->card;
 	const struct snd_soc_dapm_route *custom_map;
+	struct byt_rt5640_private *priv = snd_soc_card_get_drvdata(card);
 	int num_routes;
 
 	card->dapm.idle_bias_off = true;
 
 	rt5640_sel_asrc_clk_src(codec,
 				RT5640_DA_STEREO_FILTER |
-				RT5640_AD_STEREO_FILTER,
+				RT5640_DA_MONO_L_FILTER	|
+				RT5640_DA_MONO_R_FILTER	|
+				RT5640_AD_STEREO_FILTER	|
+				RT5640_AD_MONO_L_FILTER	|
+				RT5640_AD_MONO_R_FILTER,
 				RT5640_CLK_SEL_ASRC);
 
 	ret = snd_soc_add_card_controls(card, byt_rt5640_controls,
@@ -179,6 +424,10 @@
 		custom_map = byt_rt5640_intmic_in1_map;
 		num_routes = ARRAY_SIZE(byt_rt5640_intmic_in1_map);
 		break;
+	case BYT_RT5640_IN3_MAP:
+		custom_map = byt_rt5640_intmic_in3_map;
+		num_routes = ARRAY_SIZE(byt_rt5640_intmic_in3_map);
+		break;
 	case BYT_RT5640_DMIC2_MAP:
 		custom_map = byt_rt5640_intmic_dmic2_map;
 		num_routes = ARRAY_SIZE(byt_rt5640_intmic_dmic2_map);
@@ -192,6 +441,43 @@
 	if (ret)
 		return ret;
 
+	if (byt_rt5640_quirk & BYT_RT5640_SSP2_AIF2) {
+		ret = snd_soc_dapm_add_routes(&card->dapm,
+					byt_rt5640_ssp2_aif2_map,
+					ARRAY_SIZE(byt_rt5640_ssp2_aif2_map));
+	} else if (byt_rt5640_quirk & BYT_RT5640_SSP0_AIF1) {
+		ret = snd_soc_dapm_add_routes(&card->dapm,
+					byt_rt5640_ssp0_aif1_map,
+					ARRAY_SIZE(byt_rt5640_ssp0_aif1_map));
+	} else if (byt_rt5640_quirk & BYT_RT5640_SSP0_AIF2) {
+		ret = snd_soc_dapm_add_routes(&card->dapm,
+					byt_rt5640_ssp0_aif2_map,
+					ARRAY_SIZE(byt_rt5640_ssp0_aif2_map));
+	} else {
+		ret = snd_soc_dapm_add_routes(&card->dapm,
+					byt_rt5640_ssp2_aif1_map,
+					ARRAY_SIZE(byt_rt5640_ssp2_aif1_map));
+	}
+	if (ret)
+		return ret;
+
+	if (byt_rt5640_quirk & BYT_RT5640_MONO_SPEAKER) {
+		ret = snd_soc_dapm_add_routes(&card->dapm,
+					byt_rt5640_mono_spk_map,
+					ARRAY_SIZE(byt_rt5640_mono_spk_map));
+	} else {
+		ret = snd_soc_dapm_add_routes(&card->dapm,
+					byt_rt5640_stereo_spk_map,
+					ARRAY_SIZE(byt_rt5640_stereo_spk_map));
+	}
+	if (ret)
+		return ret;
+
+	if (byt_rt5640_quirk & BYT_RT5640_DIFF_MIC) {
+		snd_soc_update_bits(codec,  RT5640_IN1_IN2, RT5640_IN_DF1,
+				    RT5640_IN_DF1);
+	}
+
 	if (byt_rt5640_quirk & BYT_RT5640_DMIC_EN) {
 		ret = rt5640_dmic_enable(codec, 0, 0);
 		if (ret)
@@ -201,6 +487,30 @@
 	snd_soc_dapm_ignore_suspend(&card->dapm, "Headphone");
 	snd_soc_dapm_ignore_suspend(&card->dapm, "Speaker");
 
+	if ((byt_rt5640_quirk & BYT_RT5640_MCLK_EN) && priv->mclk) {
+		/*
+		 * The firmware might enable the clock at
+		 * boot (this information may or may not
+		 * be reflected in the enable clock register).
+		 * To change the rate we must disable the clock
+		 * first to cover these cases. Due to common
+		 * clock framework restrictions that do not allow
+		 * to disable a clock that has not been enabled,
+		 * we need to enable the clock first.
+		 */
+		ret = clk_prepare_enable(priv->mclk);
+		if (!ret)
+			clk_disable_unprepare(priv->mclk);
+
+		if (byt_rt5640_quirk & BYT_RT5640_MCLK_25MHZ)
+			ret = clk_set_rate(priv->mclk, 25000000);
+		else
+			ret = clk_set_rate(priv->mclk, 19200000);
+
+		if (ret)
+			dev_err(card->dev, "unable to set MCLK rate\n");
+	}
+
 	return ret;
 }
 
@@ -221,10 +531,39 @@
 						SNDRV_PCM_HW_PARAM_CHANNELS);
 	int ret;
 
-	/* The DSP will covert the FE rate to 48k, stereo, 24bits */
+	/* The DSP will covert the FE rate to 48k, stereo */
 	rate->min = rate->max = 48000;
 	channels->min = channels->max = 2;
 
+	if ((byt_rt5640_quirk & BYT_RT5640_SSP0_AIF1) ||
+		(byt_rt5640_quirk & BYT_RT5640_SSP0_AIF2)) {
+
+		/* set SSP0 to 16-bit */
+		params_set_format(params, SNDRV_PCM_FORMAT_S16_LE);
+
+		/*
+		 * Default mode for SSP configuration is TDM 4 slot, override config
+		 * with explicit setting to I2S 2ch 16-bit. The word length is set with
+		 * dai_set_tdm_slot() since there is no other API exposed
+		 */
+		ret = snd_soc_dai_set_fmt(rtd->cpu_dai,
+					SND_SOC_DAIFMT_I2S     |
+					SND_SOC_DAIFMT_NB_IF   |
+					SND_SOC_DAIFMT_CBS_CFS
+			);
+		if (ret < 0) {
+			dev_err(rtd->dev, "can't set format to I2S, err %d\n", ret);
+			return ret;
+		}
+
+		ret = snd_soc_dai_set_tdm_slot(rtd->cpu_dai, 0x3, 0x3, 2, 16);
+		if (ret < 0) {
+			dev_err(rtd->dev, "can't set I2S config, err %d\n", ret);
+			return ret;
+		}
+
+	} else {
+
 	/* set SSP2 to 24-bit */
 	params_set_format(params, SNDRV_PCM_FORMAT_S24_LE);
 
@@ -248,7 +587,7 @@
 		dev_err(rtd->dev, "can't set I2S config, err %d\n", ret);
 		return ret;
 	}
-
+	}
 	return 0;
 }
 
@@ -305,10 +644,10 @@
 	{
 		.name = "SSP2-Codec",
 		.id = 1,
-		.cpu_dai_name = "ssp2-port",
+		.cpu_dai_name = "ssp2-port", /* overwritten for ssp0 routing */
 		.platform_name = "sst-mfld-platform",
 		.no_pcm = 1,
-		.codec_dai_name = "rt5640-aif1",
+		.codec_dai_name = "rt5640-aif1", /* changed w/ quirk */
 		.codec_name = "i2c-10EC5640:00", /* overwritten with HID */
 		.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF
 						| SND_SOC_DAIFMT_CBS_CFS,
@@ -335,6 +674,21 @@
 };
 
 static char byt_rt5640_codec_name[16]; /* i2c-<HID>:00 with HID being 8 chars */
+static char byt_rt5640_codec_aif_name[12]; /*  = "rt5640-aif[1|2]" */
+static char byt_rt5640_cpu_dai_name[10]; /*  = "ssp[0|2]-port" */
+
+static bool is_valleyview(void)
+{
+	static const struct x86_cpu_id cpu_ids[] = {
+		{ X86_VENDOR_INTEL, 6, 55 }, /* Valleyview, Bay Trail */
+		{}
+	};
+
+	if (!x86_match_cpu(cpu_ids))
+		return false;
+	return true;
+}
+
 
 static int snd_byt_rt5640_mc_probe(struct platform_device *pdev)
 {
@@ -343,10 +697,16 @@
 	const char *i2c_name = NULL;
 	int i;
 	int dai_index;
+	struct byt_rt5640_private *priv;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_ATOMIC);
+	if (!priv)
+		return -ENOMEM;
 
 	/* register the soc card */
 	byt_rt5640_card.dev = &pdev->dev;
 	mach = byt_rt5640_card.dev->platform_data;
+	snd_soc_card_set_drvdata(&byt_rt5640_card, priv);
 
 	/* fix index of codec dai */
 	dai_index = MERR_DPCM_COMPR + 1;
@@ -366,8 +726,57 @@
 		byt_rt5640_dais[dai_index].codec_name = byt_rt5640_codec_name;
 	}
 
+	/*
+	 * swap SSP0 if bytcr is detected
+	 * (will be overridden if DMI quirk is detected)
+	 */
+	if (is_valleyview()) {
+		struct sst_platform_info *p_info = mach->pdata;
+		const struct sst_res_info *res_info = p_info->res_info;
+
+		/* TODO: use CHAN package info from BIOS to detect AIF1/AIF2 */
+		if (res_info->acpi_ipc_irq_index == 0) {
+			byt_rt5640_quirk |= BYT_RT5640_SSP0_AIF2;
+		}
+	}
+
 	/* check quirks before creating card */
 	dmi_check_system(byt_rt5640_quirk_table);
+	log_quirks(&pdev->dev);
+
+	if ((byt_rt5640_quirk & BYT_RT5640_SSP2_AIF2) ||
+	    (byt_rt5640_quirk & BYT_RT5640_SSP0_AIF2)) {
+
+		/* fixup codec aif name */
+		snprintf(byt_rt5640_codec_aif_name,
+			sizeof(byt_rt5640_codec_aif_name),
+			"%s", "rt5640-aif2");
+
+		byt_rt5640_dais[dai_index].codec_dai_name =
+			byt_rt5640_codec_aif_name;
+	}
+
+	if ((byt_rt5640_quirk & BYT_RT5640_SSP0_AIF1) ||
+	    (byt_rt5640_quirk & BYT_RT5640_SSP0_AIF2)) {
+
+		/* fixup cpu dai name name */
+		snprintf(byt_rt5640_cpu_dai_name,
+			sizeof(byt_rt5640_cpu_dai_name),
+			"%s", "ssp0-port");
+
+		byt_rt5640_dais[dai_index].cpu_dai_name =
+			byt_rt5640_cpu_dai_name;
+	}
+
+	if ((byt_rt5640_quirk & BYT_RT5640_MCLK_EN) && (is_valleyview())) {
+		priv->mclk = devm_clk_get(&pdev->dev, "pmc_plt_clk_3");
+		if (IS_ERR(priv->mclk)) {
+			dev_err(&pdev->dev,
+				"Failed to get MCLK from pmc_plt_clk_3: %ld\n",
+				PTR_ERR(priv->mclk));
+			return PTR_ERR(priv->mclk);
+		}
+	}
 
 	ret_val = devm_snd_soc_register_card(&pdev->dev, &byt_rt5640_card);
 
diff -uwr linux-4.8-rc4.new/sound/soc/intel/skylake/bxt-sst.c linux-4.8-rc4.orig/sound/soc/intel/skylake/bxt-sst.c
--- linux-4.8-rc4.new/sound/soc/intel/skylake/bxt-sst.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/intel/skylake/bxt-sst.c	2016-09-04 01:14:31.832283463 +0000
@@ -23,6 +23,7 @@
 #include "../common/sst-dsp.h"
 #include "../common/sst-dsp-priv.h"
 #include "skl-sst-ipc.h"
+#include "skl-tplg-interface.h"
 
 #define BXT_BASEFW_TIMEOUT	3000
 #define BXT_INIT_TIMEOUT	500
@@ -40,11 +41,73 @@
 #define BXT_INSTANCE_ID 0
 #define BXT_BASE_FW_MODULE_ID 0
 
+#define BXT_ADSP_FW_BIN_HDR_OFFSET 0x2000
+
 static unsigned int bxt_get_errorcode(struct sst_dsp *ctx)
 {
 	 return sst_dsp_shim_read(ctx, BXT_ADSP_ERROR_CODE);
 }
 
+static int
+bxt_load_library(struct sst_dsp *ctx, struct skl_dfw_manifest *minfo)
+{
+	struct snd_dma_buffer dmab;
+	struct skl_sst *skl = ctx->thread_context;
+	const struct firmware *fw = NULL;
+	struct firmware stripped_fw;
+	int ret = 0, i, dma_id, stream_tag;
+
+	/* library indices start from 1 to N. 0 represents base FW */
+	for (i = 1; i < minfo->lib_count; i++) {
+		ret = request_firmware(&fw, minfo->lib[i].name, ctx->dev);
+		if (ret < 0) {
+			dev_err(ctx->dev, "Request lib %s failed:%d\n",
+					minfo->lib[i].name, ret);
+			return ret;
+		}
+
+		if (skl->is_first_boot) {
+			ret = snd_skl_parse_uuids(ctx, fw,
+					BXT_ADSP_FW_BIN_HDR_OFFSET, i);
+			if (ret < 0)
+				goto load_library_failed;
+		}
+
+		stripped_fw.data = fw->data;
+		stripped_fw.size = fw->size;
+		skl_dsp_strip_extended_manifest(&stripped_fw);
+
+		stream_tag = ctx->dsp_ops.prepare(ctx->dev, 0x40,
+					stripped_fw.size, &dmab);
+		if (stream_tag <= 0) {
+			dev_err(ctx->dev, "Lib prepare DMA err: %x\n",
+					stream_tag);
+			ret = stream_tag;
+			goto load_library_failed;
+		}
+
+		dma_id = stream_tag - 1;
+		memcpy(dmab.area, stripped_fw.data, stripped_fw.size);
+
+		ctx->dsp_ops.trigger(ctx->dev, true, stream_tag);
+		ret = skl_sst_ipc_load_library(&skl->ipc, dma_id, i);
+		if (ret < 0)
+			dev_err(ctx->dev, "IPC Load Lib for %s fail: %d\n",
+					minfo->lib[i].name, ret);
+
+		ctx->dsp_ops.trigger(ctx->dev, false, stream_tag);
+		ctx->dsp_ops.cleanup(ctx->dev, &dmab, stream_tag);
+		release_firmware(fw);
+		fw = NULL;
+	}
+
+	return ret;
+
+load_library_failed:
+	release_firmware(fw);
+	return ret;
+}
+
 /*
  * First boot sequence has some extra steps. Core 0 waits for power
  * status on core 1, so power up core 1 also momentarily, keep it in
@@ -157,8 +220,6 @@
 	return ret;
 }
 
-#define BXT_ADSP_FW_BIN_HDR_OFFSET 0x2000
-
 static int bxt_load_base_firmware(struct sst_dsp *ctx)
 {
 	struct firmware stripped_fw;
@@ -175,9 +236,12 @@
 	if (ctx->fw == NULL)
 		goto sst_load_base_firmware_failed;
 
-	ret = snd_skl_parse_uuids(ctx, BXT_ADSP_FW_BIN_HDR_OFFSET);
+	/* prase uuids on first boot */
+	if (skl->is_first_boot) {
+		ret = snd_skl_parse_uuids(ctx, ctx->fw, BXT_ADSP_FW_BIN_HDR_OFFSET, 0);
 	if (ret < 0)
 		goto sst_load_base_firmware_failed;
+	}
 
 	stripped_fw.data = ctx->fw->data;
 	stripped_fw.size = ctx->fw->size;
@@ -230,15 +294,26 @@
 	int ret;
 	struct skl_ipc_dxstate_info dx;
 	unsigned int core_mask = SKL_DSP_CORE_MASK(core_id);
+	struct skl_dfw_manifest *minfo = &skl->manifest;
 
 	if (skl->fw_loaded == false) {
 		skl->boot_complete = false;
 		ret = bxt_load_base_firmware(ctx);
-		if (ret < 0)
+		if (ret < 0) {
 			dev_err(ctx->dev, "reload fw failed: %d\n", ret);
 		return ret;
 	}
 
+		if (minfo->lib_count > 1) {
+			ret = bxt_load_library(ctx, minfo);
+			if (ret < 0) {
+				dev_err(ctx->dev, "reload libs failed: %d\n", ret);
+				return ret;
+			}
+		}
+		return ret;
+	}
+
 	/* If core 0 is being turned on, turn on core 1 as well */
 	if (core_id == SKL_DSP_CORE0_ID)
 		ret = skl_dsp_core_power_up(ctx, core_mask |
@@ -341,6 +416,7 @@
 	.set_state_D3 = bxt_set_dsp_D3,
 	.load_fw = bxt_load_base_firmware,
 	.get_fw_errcode = bxt_get_errorcode,
+	.load_library = bxt_load_library,
 };
 
 static struct sst_ops skl_ops = {
@@ -397,6 +473,19 @@
 	skl->cores.count = 2;
 	skl->boot_complete = false;
 	init_waitqueue_head(&skl->boot_wait);
+	skl->is_first_boot = true;
+
+	if (dsp)
+		*dsp = skl;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(bxt_sst_dsp_init);
+
+int bxt_sst_init_fw(struct device *dev, struct skl_sst *ctx)
+{
+	int ret;
+	struct sst_dsp *sst = ctx->dsp;
 
 	ret = sst->fw_ops.load_fw(sst);
 	if (ret < 0) {
@@ -406,13 +495,18 @@
 
 	skl_dsp_init_core_state(sst);
 
-	if (dsp)
-		*dsp = skl;
+	if (ctx->manifest.lib_count > 1) {
+		ret = sst->fw_ops.load_library(sst, &ctx->manifest);
+		if (ret < 0) {
+			dev_err(dev, "Load Library failed : %x", ret);
+			return ret;
+		}
+	}
+	ctx->is_first_boot = false;
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(bxt_sst_dsp_init);
-
+EXPORT_SYMBOL_GPL(bxt_sst_init_fw);
 
 void bxt_sst_dsp_cleanup(struct device *dev, struct skl_sst *ctx)
 {
diff -uwr linux-4.8-rc4.new/sound/soc/intel/skylake/skl.h linux-4.8-rc4.orig/sound/soc/intel/skylake/skl.h
--- linux-4.8-rc4.new/sound/soc/intel/skylake/skl.h	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/intel/skylake/skl.h	2016-09-04 01:14:31.788285060 +0000
@@ -105,6 +105,7 @@
 			int irq, const char *fw_name,
 			struct skl_dsp_loader_ops loader_ops,
 			struct skl_sst **skl_sst);
+	int (*init_fw)(struct device *dev, struct skl_sst *ctx);
 	void (*cleanup)(struct device *dev, struct skl_sst *ctx);
 };
 
@@ -123,4 +124,5 @@
 int skl_suspend_dsp(struct skl *skl);
 int skl_resume_dsp(struct skl *skl);
 void skl_cleanup_resources(struct skl *skl);
+const struct skl_dsp_ops *skl_get_dsp_ops(int pci_id);
 #endif /* __SOUND_SOC_SKL_H */
diff -uwr linux-4.8-rc4.new/sound/soc/intel/skylake/skl-messages.c linux-4.8-rc4.orig/sound/soc/intel/skylake/skl-messages.c
--- linux-4.8-rc4.new/sound/soc/intel/skylake/skl-messages.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/intel/skylake/skl-messages.c	2016-09-04 01:14:31.840283173 +0000
@@ -203,32 +203,35 @@
 		.id = 0x9d70,
 		.loader_ops = skl_get_loader_ops,
 		.init = skl_sst_dsp_init,
+		.init_fw = skl_sst_init_fw,
 		.cleanup = skl_sst_dsp_cleanup
 	},
 	{
 		.id = 0x9d71,
 		.loader_ops = skl_get_loader_ops,
 		.init = skl_sst_dsp_init,
+		.init_fw = skl_sst_init_fw,
 		.cleanup = skl_sst_dsp_cleanup
 	},
 	{
 		.id = 0x5a98,
 		.loader_ops = bxt_get_loader_ops,
 		.init = bxt_sst_dsp_init,
+		.init_fw = bxt_sst_init_fw,
 		.cleanup = bxt_sst_dsp_cleanup
 	},
 };
 
-static int skl_get_dsp_ops(int pci_id)
+const struct skl_dsp_ops *skl_get_dsp_ops(int pci_id)
 {
 	int i;
 
 	for (i = 0; i < ARRAY_SIZE(dsp_ops); i++) {
 		if (dsp_ops[i].id == pci_id)
-			return i;
+			return &dsp_ops[i];
 	}
 
-	return -EINVAL;
+	return NULL;
 }
 
 int skl_init_dsp(struct skl *skl)
@@ -238,7 +241,8 @@
 	struct hdac_bus *bus = ebus_to_hbus(ebus);
 	struct skl_dsp_loader_ops loader_ops;
 	int irq = bus->irq;
-	int ret, index;
+	const struct skl_dsp_ops *ops;
+	int ret;
 
 	/* enable ppcap interrupt */
 	snd_hdac_ext_bus_ppcap_enable(&skl->ebus, true);
@@ -251,18 +255,18 @@
 		return -ENXIO;
 	}
 
-	index  = skl_get_dsp_ops(skl->pci->device);
-	if (index  < 0)
-		return -EINVAL;
+	ops = skl_get_dsp_ops(skl->pci->device);
+	if (!ops)
+		return -EIO;
 
-	loader_ops = dsp_ops[index].loader_ops();
-	ret = dsp_ops[index].init(bus->dev, mmio_base, irq,
-			skl->fw_name, loader_ops, &skl->skl_sst);
+	loader_ops = ops->loader_ops();
+	ret = ops->init(bus->dev, mmio_base, irq,
+				skl->fw_name, loader_ops,
+				&skl->skl_sst);
 
 	if (ret < 0)
 		return ret;
 
-	skl_dsp_enable_notification(skl->skl_sst, false);
 	dev_dbg(bus->dev, "dsp registration status=%d\n", ret);
 
 	return ret;
@@ -273,16 +277,16 @@
 	struct hdac_ext_bus *ebus = &skl->ebus;
 	struct hdac_bus *bus = ebus_to_hbus(ebus);
 	struct skl_sst *ctx = skl->skl_sst;
-	int index;
+	const struct skl_dsp_ops *ops;
 
 	/* disable  ppcap interrupt */
 	snd_hdac_ext_bus_ppcap_int_enable(&skl->ebus, false);
 
-	index = skl_get_dsp_ops(skl->pci->device);
-	if (index  < 0)
+	ops = skl_get_dsp_ops(skl->pci->device);
+	if (!ops)
 		return -EIO;
 
-	dsp_ops[index].cleanup(bus->dev, ctx);
+	ops->cleanup(bus->dev, ctx);
 
 	if (ctx->dsp->addr.lpe)
 		iounmap(ctx->dsp->addr.lpe);
@@ -323,6 +327,10 @@
 	snd_hdac_ext_bus_ppcap_enable(&skl->ebus, true);
 	snd_hdac_ext_bus_ppcap_int_enable(&skl->ebus, true);
 
+	/* check if DSP 1st boot is done */
+	if (skl->skl_sst->is_first_boot == true)
+		return 0;
+
 	ret = skl_dsp_wake(ctx->dsp);
 	if (ret < 0)
 		return ret;
@@ -862,6 +870,7 @@
 	msg.ppl_instance_id = mconfig->pipe->ppl_id;
 	msg.param_data_size = module_config_size;
 	msg.core_id = mconfig->core_id;
+	msg.domain = mconfig->domain;
 
 	ret = skl_ipc_init_instance(&ctx->ipc, &msg, param_data);
 	if (ret < 0) {
diff -uwr linux-4.8-rc4.new/sound/soc/intel/skylake/skl-pcm.c linux-4.8-rc4.orig/sound/soc/intel/skylake/skl-pcm.c
--- linux-4.8-rc4.new/sound/soc/intel/skylake/skl-pcm.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/intel/skylake/skl-pcm.c	2016-09-04 01:14:38.140054532 +0000
@@ -1138,12 +1138,40 @@
 	return retval;
 }
 
+static int skl_populate_modules(struct skl *skl)
+{
+	struct skl_pipeline *p;
+	struct skl_pipe_module *m;
+	struct snd_soc_dapm_widget *w;
+	struct skl_module_cfg *mconfig;
+	int ret;
+
+	list_for_each_entry(p, &skl->ppl_list, node) {
+		list_for_each_entry(m, &p->pipe->w_list, node) {
+
+			w = m->w;
+			mconfig = w->priv;
+
+			ret = snd_skl_get_module_info(skl->skl_sst, mconfig);
+			if (ret < 0) {
+				dev_err(skl->skl_sst->dev,
+					"query module info failed:%d\n", ret);
+				goto err;
+			}
+		}
+	}
+err:
+	return ret;
+}
+
 static int skl_platform_soc_probe(struct snd_soc_platform *platform)
 {
 	struct hdac_ext_bus *ebus = dev_get_drvdata(platform->dev);
 	struct skl *skl = ebus_to_skl(ebus);
+	const struct skl_dsp_ops *ops;
 	int ret;
 
+	pm_runtime_get_sync(platform->dev);
 	if (ebus->ppcap) {
 		ret = skl_tplg_init(platform, ebus);
 		if (ret < 0) {
@@ -1151,7 +1179,26 @@
 			return ret;
 		}
 		skl->platform = platform;
+
+		/* load the firmwares, since all is set */
+		ops = skl_get_dsp_ops(skl->pci->device);
+		if (!ops)
+			return -EIO;
+
+		if (skl->skl_sst->is_first_boot == false) {
+			dev_err(platform->dev, "DSP reports first boot done!!!\n");
+			return -EIO;
+		}
+
+		ret = ops->init_fw(platform->dev, skl->skl_sst);
+		if (ret < 0) {
+			dev_err(platform->dev, "Failed to boot first fw: %d\n", ret);
+			return ret;
+		}
+		skl_populate_modules(skl);
 	}
+	pm_runtime_mark_last_busy(platform->dev);
+	pm_runtime_put_autosuspend(platform->dev);
 
 	return 0;
 }
diff -uwr linux-4.8-rc4.new/sound/soc/intel/skylake/skl-sst.c linux-4.8-rc4.orig/sound/soc/intel/skylake/skl-sst.c
--- linux-4.8-rc4.new/sound/soc/intel/skylake/skl-sst.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/intel/skylake/skl-sst.c	2016-09-04 01:14:31.816284043 +0000
@@ -88,14 +88,16 @@
 		}
 	}
 
-	ret = snd_skl_parse_uuids(ctx, SKL_ADSP_FW_BIN_HDR_OFFSET);
+	/* prase uuids on first boot */
+	if (skl->is_first_boot) {
+		ret = snd_skl_parse_uuids(ctx, ctx->fw, SKL_ADSP_FW_BIN_HDR_OFFSET, 0);
 	if (ret < 0) {
-		dev_err(ctx->dev,
-				"UUID parsing err: %d\n", ret);
+			dev_err(ctx->dev, "UUID parsing err: %d\n", ret);
 		release_firmware(ctx->fw);
 		skl_dsp_disable_core(ctx, SKL_DSP_CORE0_MASK);
 		return ret;
 	}
+	}
 
 	/* check for extended manifest */
 	stripped_fw.data = ctx->fw->data;
@@ -484,25 +486,32 @@
 		return ret;
 
 	skl->cores.count = 2;
+	skl->is_first_boot = true;
+
+	if (dsp)
+		*dsp = skl;
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(skl_sst_dsp_init);
+
+int skl_sst_init_fw(struct device *dev, struct skl_sst *ctx)
+{
+	int ret;
+	struct sst_dsp *sst = ctx->dsp;
 
 	ret = sst->fw_ops.load_fw(sst);
 	if (ret < 0) {
 		dev_err(dev, "Load base fw failed : %d", ret);
-		goto cleanup;
+		return ret;
 	}
 
 	skl_dsp_init_core_state(sst);
+	ctx->is_first_boot = false;
 
-	if (dsp)
-		*dsp = skl;
-
-	return ret;
-
-cleanup:
-	skl_sst_dsp_cleanup(dev, skl);
-	return ret;
+	return 0;
 }
-EXPORT_SYMBOL_GPL(skl_sst_dsp_init);
+EXPORT_SYMBOL_GPL(skl_sst_init_fw);
 
 void skl_sst_dsp_cleanup(struct device *dev, struct skl_sst *ctx)
 {
diff -uwr linux-4.8-rc4.new/sound/soc/intel/skylake/skl-sst-dsp.h linux-4.8-rc4.orig/sound/soc/intel/skylake/skl-sst-dsp.h
--- linux-4.8-rc4.new/sound/soc/intel/skylake/skl-sst-dsp.h	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/intel/skylake/skl-sst-dsp.h	2016-09-04 01:14:38.120055258 +0000
@@ -20,6 +20,7 @@
 #include <sound/memalloc.h>
 #include "skl-sst-cldma.h"
 #include "skl-tplg-interface.h"
+#include "skl-topology.h"
 
 struct sst_dsp;
 struct skl_sst;
@@ -133,6 +134,8 @@
 struct skl_dsp_fw_ops {
 	int (*load_fw)(struct sst_dsp  *ctx);
 	/* FW module parser/loader */
+	int (*load_library)(struct sst_dsp *ctx,
+		struct skl_dfw_manifest *minfo);
 	int (*parse_fw)(struct sst_dsp *ctx);
 	int (*set_state_D0)(struct sst_dsp *ctx, unsigned int core_id);
 	int (*set_state_D3)(struct sst_dsp *ctx, unsigned int core_id);
@@ -203,12 +206,15 @@
 int bxt_sst_dsp_init(struct device *dev, void __iomem *mmio_base, int irq,
 		const char *fw_name, struct skl_dsp_loader_ops dsp_ops,
 		struct skl_sst **dsp);
+int skl_sst_init_fw(struct device *dev, struct skl_sst *ctx);
+int bxt_sst_init_fw(struct device *dev, struct skl_sst *ctx);
 void skl_sst_dsp_cleanup(struct device *dev, struct skl_sst *ctx);
 void bxt_sst_dsp_cleanup(struct device *dev, struct skl_sst *ctx);
 
-int snd_skl_get_module_info(struct skl_sst *ctx, u8 *uuid,
-		struct skl_dfw_module *dfw_config);
-int snd_skl_parse_uuids(struct sst_dsp *ctx, unsigned int offset);
+int snd_skl_get_module_info(struct skl_sst *ctx,
+				struct skl_module_cfg *mconfig);
+int snd_skl_parse_uuids(struct sst_dsp *ctx, const struct firmware *fw,
+				unsigned int offset, int index);
 void skl_freeup_uuid_list(struct skl_sst *ctx);
 
 int skl_dsp_strip_extended_manifest(struct firmware *fw);
diff -uwr linux-4.8-rc4.new/sound/soc/intel/skylake/skl-sst-ipc.c linux-4.8-rc4.orig/sound/soc/intel/skylake/skl-sst-ipc.c
--- linux-4.8-rc4.new/sound/soc/intel/skylake/skl-sst-ipc.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/intel/skylake/skl-sst-ipc.c	2016-09-04 01:14:31.840283173 +0000
@@ -114,6 +114,11 @@
 #define IPC_CORE_ID(x)			(((x) & IPC_CORE_ID_MASK) \
 					<< IPC_CORE_ID_SHIFT)
 
+#define IPC_DOMAIN_SHIFT                28
+#define IPC_DOMAIN_MASK                 0x1
+#define IPC_DOMAIN(x)                   (((x) & IPC_DOMAIN_MASK) \
+					<< IPC_DOMAIN_SHIFT)
+
 /* Bind/Unbind message extension register */
 #define IPC_DST_MOD_ID_SHIFT		0
 #define IPC_DST_MOD_ID(x)		(((x) & IPC_MOD_ID_MASK) \
@@ -190,6 +195,7 @@
 	IPC_GLB_GET_PPL_CONTEXT_SIZE = 21,
 	IPC_GLB_SAVE_PPL = 22,
 	IPC_GLB_RESTORE_PPL = 23,
+	IPC_GLB_LOAD_LIBRARY = 24,
 	IPC_GLB_NOTIFY = 26,
 	IPC_GLB_MAX_IPC_MSG_NUMBER = 31 /* Maximum message number */
 };
@@ -704,6 +710,7 @@
 	header.extension = IPC_CORE_ID(msg->core_id);
 	header.extension |= IPC_PPL_INSTANCE_ID(msg->ppl_instance_id);
 	header.extension |= IPC_PARAM_BLOCK_SIZE(param_block_size);
+	header.extension |= IPC_DOMAIN(msg->domain);
 
 	dev_dbg(ipc->dev, "In %s primary =%x ext=%x\n", __func__,
 			 header.primary, header.extension);
@@ -902,3 +909,25 @@
 	return ret;
 }
 EXPORT_SYMBOL_GPL(skl_ipc_get_large_config);
+
+int skl_sst_ipc_load_library(struct sst_generic_ipc *ipc,
+				u8 dma_id, u8 table_id)
+{
+	struct skl_ipc_header header = {0};
+	u64 *ipc_header = (u64 *)(&header);
+	int ret = 0;
+
+	header.primary = IPC_MSG_TARGET(IPC_FW_GEN_MSG);
+	header.primary |= IPC_MSG_DIR(IPC_MSG_REQUEST);
+	header.primary |= IPC_GLB_TYPE(IPC_GLB_LOAD_LIBRARY);
+	header.primary |= IPC_MOD_INSTANCE_ID(table_id);
+	header.primary |= IPC_MOD_ID(dma_id);
+
+	ret = sst_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0, NULL, 0);
+
+	if (ret < 0)
+		dev_err(ipc->dev, "ipc: load lib failed\n");
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(skl_sst_ipc_load_library);
diff -uwr linux-4.8-rc4.new/sound/soc/intel/skylake/skl-sst-ipc.h linux-4.8-rc4.orig/sound/soc/intel/skylake/skl-sst-ipc.h
--- linux-4.8-rc4.new/sound/soc/intel/skylake/skl-sst-ipc.h	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/intel/skylake/skl-sst-ipc.h	2016-09-04 01:14:31.840283173 +0000
@@ -75,8 +75,14 @@
 	/* Is firmware loaded */
 	bool fw_loaded;
 
+	/* first boot ? */
+	bool is_first_boot;
+
 	/* multi-core */
 	struct skl_dsp_cores cores;
+
+	/* tplg manifest */
+	struct skl_dfw_manifest manifest;
 };
 
 struct skl_ipc_init_instance_msg {
@@ -85,6 +91,7 @@
 	u16 param_data_size;
 	u8 ppl_instance_id;
 	u8 core_id;
+	u8 domain;
 };
 
 struct skl_ipc_bind_unbind_msg {
@@ -145,6 +152,9 @@
 int skl_ipc_get_large_config(struct sst_generic_ipc *ipc,
 		struct skl_ipc_large_config_msg *msg, u32 *param);
 
+int skl_sst_ipc_load_library(struct sst_generic_ipc *ipc,
+			u8 dma_id, u8 table_id);
+
 void skl_ipc_int_enable(struct sst_dsp *dsp);
 void skl_ipc_op_int_enable(struct sst_dsp *ctx);
 void skl_ipc_op_int_disable(struct sst_dsp *ctx);
diff -uwr linux-4.8-rc4.new/sound/soc/intel/skylake/skl-sst-utils.c linux-4.8-rc4.orig/sound/soc/intel/skylake/skl-sst-utils.c
--- linux-4.8-rc4.new/sound/soc/intel/skylake/skl-sst-utils.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/intel/skylake/skl-sst-utils.c	2016-09-04 01:14:51.659563861 +0000
@@ -28,11 +28,6 @@
 /* FW Extended Manifest Header id = $AE1 */
 #define SKL_EXT_MANIFEST_HEADER_MAGIC   0x31454124
 
-struct skl_dfw_module_mod {
-	char name[100];
-	struct skl_dfw_module skl_dfw_mod;
-};
-
 struct UUID {
 	u8 id[16];
 };
@@ -145,7 +140,8 @@
  * Parse the firmware binary to get the UUID, module id
  * and loadable flags
  */
-int snd_skl_parse_uuids(struct sst_dsp *ctx, unsigned int offset)
+int snd_skl_parse_uuids(struct sst_dsp *ctx, const struct firmware *fw,
+			unsigned int offset, int index)
 {
 	struct adsp_fw_hdr *adsp_hdr;
 	struct adsp_module_entry *mod_entry;
@@ -158,8 +154,8 @@
 	unsigned int safe_file;
 
 	/* Get the FW pointer to derive ADSP header */
-	stripped_fw.data = ctx->fw->data;
-	stripped_fw.size = ctx->fw->size;
+	stripped_fw.data = fw->data;
+	stripped_fw.size = fw->size;
 
 	skl_dsp_strip_extended_manifest(&stripped_fw);
 
@@ -210,7 +206,7 @@
 		uuid_bin = (uuid_le *)mod_entry->uuid.id;
 		memcpy(&module->uuid, uuid_bin, sizeof(module->uuid));
 
-		module->id = i;
+		module->id = (i | (index << 12));
 		module->is_loadable = mod_entry->type.load_type;
 
 		list_add_tail(&module->list, &skl->uuid_list);
diff -uwr linux-4.8-rc4.new/sound/soc/intel/skylake/skl-topology.c linux-4.8-rc4.orig/sound/soc/intel/skylake/skl-topology.c
--- linux-4.8-rc4.new/sound/soc/intel/skylake/skl-topology.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/intel/skylake/skl-topology.c	2016-09-04 01:14:53.807485906 +0000
@@ -21,6 +21,7 @@
 #include <linux/firmware.h>
 #include <sound/soc.h>
 #include <sound/soc-topology.h>
+#include <uapi/sound/snd_sst_tokens.h>
 #include "skl-sst-dsp.h"
 #include "skl-sst-ipc.h"
 #include "skl-topology.h"
@@ -32,6 +33,8 @@
 #define SKL_CH_FIXUP_MASK		(1 << 0)
 #define SKL_RATE_FIXUP_MASK		(1 << 1)
 #define SKL_FMT_FIXUP_MASK		(1 << 2)
+#define SKL_IN_DIR_BIT_MASK		BIT(0)
+#define SKL_PIN_COUNT_MASK		GENMASK(7, 4)
 
 /*
  * SKL DSP driver modelling uses only few DAPM widgets so for rest we will
@@ -473,6 +476,14 @@
 		w = w_module->w;
 		mconfig = w->priv;
 
+		/* check if module ids are populated */
+		if (mconfig->id.module_id < 0) {
+			dev_err(skl->skl_sst->dev,
+					"module %pUL id not populated\n",
+					(uuid_le *)mconfig->guid);
+			return -EIO;
+		}
+
 		/* check resource available */
 		if (!skl_is_pipe_mcps_avail(skl, mconfig))
 			return -ENOMEM;
@@ -1460,85 +1471,570 @@
 					skl_tplg_tlv_control_set},
 };
 
-/*
- * The topology binary passes the pin info for a module so initialize the pin
- * info passed into module instance
- */
-static void skl_fill_module_pin_info(struct skl_dfw_module_pin *dfw_pin,
-						struct skl_module_pin *m_pin,
-						bool is_dynamic, int max_pin)
+static int skl_tplg_fill_pipe_tkn(struct device *dev,
+			struct skl_pipe *pipe, u32 tkn,
+			u32 tkn_val)
 {
-	int i;
 
-	for (i = 0; i < max_pin; i++) {
-		m_pin[i].id.module_id = dfw_pin[i].module_id;
-		m_pin[i].id.instance_id = dfw_pin[i].instance_id;
-		m_pin[i].in_use = false;
-		m_pin[i].is_dynamic = is_dynamic;
-		m_pin[i].pin_state = SKL_PIN_UNBIND;
+	switch (tkn) {
+	case SKL_TKN_U32_PIPE_CONN_TYPE:
+		pipe->conn_type = tkn_val;
+		break;
+
+	case SKL_TKN_U32_PIPE_PRIORITY:
+		pipe->pipe_priority = tkn_val;
+		break;
+
+	case SKL_TKN_U32_PIPE_MEM_PGS:
+		pipe->memory_pages = tkn_val;
+		break;
+
+	default:
+		dev_err(dev, "Token not handled %d\n", tkn);
+		return -EINVAL;
 	}
+
+	return 0;
 }
 
 /*
- * Add pipeline from topology binary into driver pipeline list
- *
- * If already added we return that instance
- * Otherwise we create a new instance and add into driver list
+ * Add pipeline by parsing the relevant tokens
+ * Return an existing pipe if the pipe already exists.
  */
-static struct skl_pipe *skl_tplg_add_pipe(struct device *dev,
-			struct skl *skl, struct skl_dfw_pipe *dfw_pipe)
+static int skl_tplg_add_pipe(struct device *dev,
+		struct skl_module_cfg *mconfig, struct skl *skl,
+		struct snd_soc_tplg_vendor_value_elem *tkn_elem)
 {
 	struct skl_pipeline *ppl;
 	struct skl_pipe *pipe;
 	struct skl_pipe_params *params;
 
 	list_for_each_entry(ppl, &skl->ppl_list, node) {
-		if (ppl->pipe->ppl_id == dfw_pipe->pipe_id)
-			return ppl->pipe;
+		if (ppl->pipe->ppl_id == tkn_elem->value) {
+			mconfig->pipe = ppl->pipe;
+			return EEXIST;
+		}
 	}
 
 	ppl = devm_kzalloc(dev, sizeof(*ppl), GFP_KERNEL);
 	if (!ppl)
-		return NULL;
+		return -ENOMEM;
 
 	pipe = devm_kzalloc(dev, sizeof(*pipe), GFP_KERNEL);
 	if (!pipe)
-		return NULL;
+		return -ENOMEM;
 
 	params = devm_kzalloc(dev, sizeof(*params), GFP_KERNEL);
 	if (!params)
-		return NULL;
+		return -ENOMEM;
 
-	pipe->ppl_id = dfw_pipe->pipe_id;
-	pipe->memory_pages = dfw_pipe->memory_pages;
-	pipe->pipe_priority = dfw_pipe->pipe_priority;
-	pipe->conn_type = dfw_pipe->conn_type;
-	pipe->state = SKL_PIPE_INVALID;
 	pipe->p_params = params;
+	pipe->ppl_id = tkn_elem->value;
 	INIT_LIST_HEAD(&pipe->w_list);
 
 	ppl->pipe = pipe;
 	list_add(&ppl->node, &skl->ppl_list);
 
-	return ppl->pipe;
+	mconfig->pipe = pipe;
+	mconfig->pipe->state = SKL_PIPE_INVALID;
+
+	return 0;
+}
+
+static int skl_tplg_fill_pin(struct device *dev, u32 tkn,
+			struct skl_module_pin *m_pin,
+			int pin_index, u32 value)
+{
+	switch (tkn) {
+	case SKL_TKN_U32_PIN_MOD_ID:
+		m_pin[pin_index].id.module_id = value;
+		break;
+
+	case SKL_TKN_U32_PIN_INST_ID:
+		m_pin[pin_index].id.instance_id = value;
+		break;
+
+	default:
+		dev_err(dev, "%d Not a pin token\n", value);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*
+ * Parse for pin config specific tokens to fill up the
+ * module private data
+ */
+static int skl_tplg_fill_pins_info(struct device *dev,
+		struct skl_module_cfg *mconfig,
+		struct snd_soc_tplg_vendor_value_elem *tkn_elem,
+		int dir, int pin_count)
+{
+	int ret;
+	struct skl_module_pin *m_pin;
+
+	switch (dir) {
+	case SKL_DIR_IN:
+		m_pin = mconfig->m_in_pin;
+		break;
+
+	case SKL_DIR_OUT:
+		m_pin = mconfig->m_out_pin;
+		break;
+
+	default:
+		dev_err(dev, "Invalid direction value");
+		return -EINVAL;
+	}
+
+	ret = skl_tplg_fill_pin(dev, tkn_elem->token,
+			m_pin, pin_count, tkn_elem->value);
+
+	if (ret < 0)
+		return ret;
+
+	m_pin[pin_count].in_use = false;
+	m_pin[pin_count].pin_state = SKL_PIN_UNBIND;
+
+	return 0;
+}
+
+/*
+ * Fill up input/output module config format based
+ * on the direction
+ */
+static int skl_tplg_fill_fmt(struct device *dev,
+		struct skl_module_cfg *mconfig,	u32 tkn,
+		u32 value, u32 dir, u32 pin_count)
+{
+	struct skl_module_fmt *dst_fmt;
+
+	switch (dir) {
+	case SKL_DIR_IN:
+		dst_fmt = mconfig->in_fmt;
+		dst_fmt += pin_count;
+		break;
+
+	case SKL_DIR_OUT:
+		dst_fmt = mconfig->out_fmt;
+		dst_fmt += pin_count;
+		break;
+
+	default:
+		dev_err(dev, "Invalid direction value");
+		return -EINVAL;
+	}
+
+	switch (tkn) {
+	case SKL_TKN_U32_FMT_CH:
+		dst_fmt->channels  = value;
+		break;
+
+	case SKL_TKN_U32_FMT_FREQ:
+		dst_fmt->s_freq = value;
+		break;
+
+	case SKL_TKN_U32_FMT_BIT_DEPTH:
+		dst_fmt->bit_depth = value;
+		break;
+
+	case SKL_TKN_U32_FMT_SAMPLE_SIZE:
+		dst_fmt->valid_bit_depth = value;
+		break;
+
+	case SKL_TKN_U32_FMT_CH_CONFIG:
+		dst_fmt->ch_cfg = value;
+		break;
+
+	case SKL_TKN_U32_FMT_INTERLEAVE:
+		dst_fmt->interleaving_style = value;
+		break;
+
+	case SKL_TKN_U32_FMT_SAMPLE_TYPE:
+		dst_fmt->sample_type = value;
+		break;
+
+	case SKL_TKN_U32_FMT_CH_MAP:
+		dst_fmt->ch_map = value;
+		break;
+
+	default:
+		dev_err(dev, "Invalid token %d", tkn);
+		return -EINVAL;
 }
 
-static void skl_tplg_fill_fmt(struct skl_module_fmt *dst_fmt,
-				struct skl_dfw_module_fmt *src_fmt,
-				int pins)
+	return 0;
+}
+
+static int skl_tplg_get_uuid(struct device *dev, struct skl_module_cfg *mconfig,
+	      struct snd_soc_tplg_vendor_uuid_elem *uuid_tkn)
+{
+	if (uuid_tkn->token == SKL_TKN_UUID)
+		memcpy(&mconfig->guid, &uuid_tkn->uuid, 16);
+	else {
+		dev_err(dev, "Not an UUID token tkn %d", uuid_tkn->token);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void skl_tplg_fill_pin_dynamic_val(
+		struct skl_module_pin *mpin, u32 pin_count, u32 value)
 {
 	int i;
 
-	for (i = 0; i < pins; i++) {
-		dst_fmt[i].channels  = src_fmt[i].channels;
-		dst_fmt[i].s_freq = src_fmt[i].freq;
-		dst_fmt[i].bit_depth = src_fmt[i].bit_depth;
-		dst_fmt[i].valid_bit_depth = src_fmt[i].valid_bit_depth;
-		dst_fmt[i].ch_cfg = src_fmt[i].ch_cfg;
-		dst_fmt[i].ch_map = src_fmt[i].ch_map;
-		dst_fmt[i].interleaving_style = src_fmt[i].interleaving_style;
-		dst_fmt[i].sample_type = src_fmt[i].sample_type;
+	for (i = 0; i < pin_count; i++)
+		mpin[i].is_dynamic = value;
 	}
+
+/*
+ * Parse tokens to fill up the module private data
+ */
+static int skl_tplg_get_token(struct device *dev,
+		struct snd_soc_tplg_vendor_value_elem *tkn_elem,
+		struct skl *skl, struct skl_module_cfg *mconfig)
+{
+	int tkn_count = 0;
+	int ret;
+	static int is_pipe_exists;
+	static int pin_index, dir;
+
+	if (tkn_elem->token > SKL_TKN_MAX)
+		return -EINVAL;
+
+	switch (tkn_elem->token) {
+	case SKL_TKN_U8_IN_QUEUE_COUNT:
+		mconfig->max_in_queue = tkn_elem->value;
+		mconfig->m_in_pin = devm_kzalloc(dev, mconfig->max_in_queue *
+					sizeof(*mconfig->m_in_pin),
+					GFP_KERNEL);
+		if (!mconfig->m_in_pin)
+			return -ENOMEM;
+
+		break;
+
+	case SKL_TKN_U8_OUT_QUEUE_COUNT:
+		mconfig->max_out_queue = tkn_elem->value;
+		mconfig->m_out_pin = devm_kzalloc(dev, mconfig->max_out_queue *
+					sizeof(*mconfig->m_out_pin),
+					GFP_KERNEL);
+
+		if (!mconfig->m_out_pin)
+			return -ENOMEM;
+
+		break;
+
+	case SKL_TKN_U8_DYN_IN_PIN:
+		if (!mconfig->m_in_pin)
+			return -ENOMEM;
+
+		skl_tplg_fill_pin_dynamic_val(mconfig->m_in_pin,
+			mconfig->max_in_queue, tkn_elem->value);
+
+		break;
+
+	case SKL_TKN_U8_DYN_OUT_PIN:
+		if (!mconfig->m_out_pin)
+			return -ENOMEM;
+
+		skl_tplg_fill_pin_dynamic_val(mconfig->m_out_pin,
+			mconfig->max_out_queue, tkn_elem->value);
+
+		break;
+
+	case SKL_TKN_U8_TIME_SLOT:
+		mconfig->time_slot = tkn_elem->value;
+		break;
+
+	case SKL_TKN_U8_CORE_ID:
+		mconfig->core_id = tkn_elem->value;
+
+	case SKL_TKN_U8_MOD_TYPE:
+		mconfig->m_type = tkn_elem->value;
+		break;
+
+	case SKL_TKN_U8_DEV_TYPE:
+		mconfig->dev_type = tkn_elem->value;
+		break;
+
+	case SKL_TKN_U8_HW_CONN_TYPE:
+		mconfig->hw_conn_type = tkn_elem->value;
+		break;
+
+	case SKL_TKN_U16_MOD_INST_ID:
+		mconfig->id.instance_id =
+		tkn_elem->value;
+		break;
+
+	case SKL_TKN_U32_MEM_PAGES:
+		mconfig->mem_pages = tkn_elem->value;
+		break;
+
+	case SKL_TKN_U32_MAX_MCPS:
+		mconfig->mcps = tkn_elem->value;
+		break;
+
+	case SKL_TKN_U32_OBS:
+		mconfig->obs = tkn_elem->value;
+		break;
+
+	case SKL_TKN_U32_IBS:
+		mconfig->ibs = tkn_elem->value;
+		break;
+
+	case SKL_TKN_U32_VBUS_ID:
+		mconfig->vbus_id = tkn_elem->value;
+		break;
+
+	case SKL_TKN_U32_PARAMS_FIXUP:
+		mconfig->params_fixup = tkn_elem->value;
+		break;
+
+	case SKL_TKN_U32_CONVERTER:
+		mconfig->converter = tkn_elem->value;
+		break;
+
+	case SKL_TKN_U32_PIPE_ID:
+		ret = skl_tplg_add_pipe(dev,
+				mconfig, skl, tkn_elem);
+
+		if (ret < 0)
+			return is_pipe_exists;
+
+		if (ret == EEXIST)
+			is_pipe_exists = 1;
+
+		break;
+
+	case SKL_TKN_U32_PIPE_CONN_TYPE:
+	case SKL_TKN_U32_PIPE_PRIORITY:
+	case SKL_TKN_U32_PIPE_MEM_PGS:
+		if (is_pipe_exists) {
+			ret = skl_tplg_fill_pipe_tkn(dev, mconfig->pipe,
+					tkn_elem->token, tkn_elem->value);
+			if (ret < 0)
+				return ret;
+		}
+
+		break;
+
+	/*
+	 * SKL_TKN_U32_DIR_PIN_COUNT token has the value for both
+	 * direction and the pin count. The first four bits represent
+	 * direction and next four the pin count.
+	 */
+	case SKL_TKN_U32_DIR_PIN_COUNT:
+		dir = tkn_elem->value & SKL_IN_DIR_BIT_MASK;
+		pin_index = (tkn_elem->value &
+			SKL_PIN_COUNT_MASK) >> 4;
+
+		break;
+
+	case SKL_TKN_U32_FMT_CH:
+	case SKL_TKN_U32_FMT_FREQ:
+	case SKL_TKN_U32_FMT_BIT_DEPTH:
+	case SKL_TKN_U32_FMT_SAMPLE_SIZE:
+	case SKL_TKN_U32_FMT_CH_CONFIG:
+	case SKL_TKN_U32_FMT_INTERLEAVE:
+	case SKL_TKN_U32_FMT_SAMPLE_TYPE:
+	case SKL_TKN_U32_FMT_CH_MAP:
+		ret = skl_tplg_fill_fmt(dev, mconfig, tkn_elem->token,
+				tkn_elem->value, dir, pin_index);
+
+		if (ret < 0)
+			return ret;
+
+		break;
+
+	case SKL_TKN_U32_PIN_MOD_ID:
+	case SKL_TKN_U32_PIN_INST_ID:
+		ret = skl_tplg_fill_pins_info(dev,
+				mconfig, tkn_elem, dir,
+				pin_index);
+		if (ret < 0)
+			return ret;
+
+		break;
+
+	case SKL_TKN_U32_CAPS_SIZE:
+		mconfig->formats_config.caps_size =
+			tkn_elem->value;
+
+		break;
+
+	case SKL_TKN_U32_PROC_DOMAIN:
+		mconfig->domain =
+			tkn_elem->value;
+
+		break;
+
+	case SKL_TKN_U8_IN_PIN_TYPE:
+	case SKL_TKN_U8_OUT_PIN_TYPE:
+	case SKL_TKN_U8_CONN_TYPE:
+		break;
+
+	default:
+		dev_err(dev, "Token %d not handled\n",
+				tkn_elem->token);
+		return -EINVAL;
+	}
+
+	tkn_count++;
+
+	return tkn_count;
+}
+
+/*
+ * Parse the vendor array for specific tokens to construct
+ * module private data
+ */
+static int skl_tplg_get_tokens(struct device *dev,
+		char *pvt_data,	struct skl *skl,
+		struct skl_module_cfg *mconfig, int block_size)
+{
+	struct snd_soc_tplg_vendor_array *array;
+	struct snd_soc_tplg_vendor_value_elem *tkn_elem;
+	int tkn_count = 0, ret;
+	int off = 0, tuple_size = 0;
+
+	if (block_size <= 0)
+		return -EINVAL;
+
+	while (tuple_size < block_size) {
+		array = (struct snd_soc_tplg_vendor_array *)(pvt_data + off);
+
+		off += array->size;
+
+		switch (array->type) {
+		case SND_SOC_TPLG_TUPLE_TYPE_STRING:
+			dev_warn(dev, "no string tokens expected for skl tplg");
+			continue;
+
+		case SND_SOC_TPLG_TUPLE_TYPE_UUID:
+			ret = skl_tplg_get_uuid(dev, mconfig, array->uuid);
+			if (ret < 0)
+				return ret;
+
+			tuple_size += sizeof(*array->uuid);
+
+			continue;
+
+		default:
+			tkn_elem = array->value;
+			tkn_count = 0;
+			break;
+		}
+
+		while (tkn_count <= (array->num_elems - 1)) {
+			ret = skl_tplg_get_token(dev, tkn_elem,
+					skl, mconfig);
+
+			if (ret < 0)
+				return ret;
+
+			tkn_count = tkn_count + ret;
+			tkn_elem++;
+		}
+
+		tuple_size += tkn_count * sizeof(*tkn_elem);
+	}
+
+	return 0;
+}
+
+/*
+ * Every data block is preceded by a descriptor to read the number
+ * of data blocks, they type of the block and it's size
+ */
+static int skl_tplg_get_desc_blocks(struct device *dev,
+		struct snd_soc_tplg_vendor_array *array)
+{
+	struct snd_soc_tplg_vendor_value_elem *tkn_elem;
+
+	tkn_elem = array->value;
+
+	switch (tkn_elem->token) {
+	case SKL_TKN_U8_NUM_BLOCKS:
+	case SKL_TKN_U8_BLOCK_TYPE:
+	case SKL_TKN_U16_BLOCK_SIZE:
+		return tkn_elem->value;
+
+	default:
+		dev_err(dev, "Invalid descriptor token %d", tkn_elem->token);
+		break;
+	}
+
+	return -EINVAL;
+}
+
+/*
+ * Parse the private data for the token and corresponding value.
+ * The private data can have multiple data blocks. So, a data block
+ * is preceded by a descriptor for number of blocks and a descriptor
+ * for the type and size of the suceeding data block.
+ */
+static int skl_tplg_get_pvt_data(struct snd_soc_tplg_dapm_widget *tplg_w,
+				struct skl *skl, struct device *dev,
+				struct skl_module_cfg *mconfig)
+{
+	struct snd_soc_tplg_vendor_array *array;
+	int num_blocks, block_size = 0, block_type, off = 0;
+	char *data;
+	int ret;
+
+	/* Read the NUM_DATA_BLOCKS descriptor */
+	array = (struct snd_soc_tplg_vendor_array *)tplg_w->priv.data;
+	ret = skl_tplg_get_desc_blocks(dev, array);
+	if (ret < 0)
+		return ret;
+	num_blocks = ret;
+
+	off += array->size;
+	array = (struct snd_soc_tplg_vendor_array *)(tplg_w->priv.data + off);
+
+	/* Read the BLOCK_TYPE and BLOCK_SIZE descriptor */
+	while (num_blocks > 0) {
+		ret = skl_tplg_get_desc_blocks(dev, array);
+
+		if (ret < 0)
+			return ret;
+		block_type = ret;
+		off += array->size;
+
+		array = (struct snd_soc_tplg_vendor_array *)
+			(tplg_w->priv.data + off);
+
+		ret = skl_tplg_get_desc_blocks(dev, array);
+
+		if (ret < 0)
+			return ret;
+		block_size = ret;
+		off += array->size;
+
+		array = (struct snd_soc_tplg_vendor_array *)
+			(tplg_w->priv.data + off);
+
+		data = (tplg_w->priv.data + off);
+
+		if (block_type == SKL_TYPE_TUPLE) {
+			ret = skl_tplg_get_tokens(dev, data,
+					skl, mconfig, block_size);
+
+			if (ret < 0)
+				return ret;
+
+			--num_blocks;
+		} else {
+			if (mconfig->formats_config.caps_size > 0)
+				memcpy(mconfig->formats_config.caps, data,
+					mconfig->formats_config.caps_size);
+			--num_blocks;
+		}
+	}
+
+	return 0;
 }
 
 static void skl_clear_pin_config(struct snd_soc_platform *platform,
@@ -1606,9 +2102,6 @@
 	struct skl *skl = ebus_to_skl(ebus);
 	struct hdac_bus *bus = ebus_to_hbus(ebus);
 	struct skl_module_cfg *mconfig;
-	struct skl_pipe *pipe;
-	struct skl_dfw_module *dfw_config =
-				(struct skl_dfw_module *)tplg_w->priv.data;
 
 	if (!tplg_w->priv.size)
 		goto bind_event;
@@ -1619,76 +2112,17 @@
 		return -ENOMEM;
 
 	w->priv = mconfig;
-	memcpy(&mconfig->guid, &dfw_config->uuid, 16);
 
-	ret = snd_skl_get_module_info(skl->skl_sst, mconfig->guid, dfw_config);
+	/*
+	 * module binary can be loaded later, so set it to query when
+	 * module is load for a use case
+	 */
+	mconfig->id.module_id = -1;
+
+	/* Parse private data for tuples */
+	ret = skl_tplg_get_pvt_data(tplg_w, skl, bus->dev, mconfig);
 	if (ret < 0)
 		return ret;
-
-	mconfig->id.module_id = dfw_config->module_id;
-	mconfig->id.instance_id = dfw_config->instance_id;
-	mconfig->mcps = dfw_config->max_mcps;
-	mconfig->ibs = dfw_config->ibs;
-	mconfig->obs = dfw_config->obs;
-	mconfig->core_id = dfw_config->core_id;
-	mconfig->max_in_queue = dfw_config->max_in_queue;
-	mconfig->max_out_queue = dfw_config->max_out_queue;
-	mconfig->is_loadable = dfw_config->is_loadable;
-	skl_tplg_fill_fmt(mconfig->in_fmt, dfw_config->in_fmt,
-						MODULE_MAX_IN_PINS);
-	skl_tplg_fill_fmt(mconfig->out_fmt, dfw_config->out_fmt,
-						MODULE_MAX_OUT_PINS);
-
-	mconfig->params_fixup = dfw_config->params_fixup;
-	mconfig->converter = dfw_config->converter;
-	mconfig->m_type = dfw_config->module_type;
-	mconfig->vbus_id = dfw_config->vbus_id;
-	mconfig->mem_pages = dfw_config->mem_pages;
-
-	pipe = skl_tplg_add_pipe(bus->dev, skl, &dfw_config->pipe);
-	if (pipe)
-		mconfig->pipe = pipe;
-
-	mconfig->dev_type = dfw_config->dev_type;
-	mconfig->hw_conn_type = dfw_config->hw_conn_type;
-	mconfig->time_slot = dfw_config->time_slot;
-	mconfig->formats_config.caps_size = dfw_config->caps.caps_size;
-
-	mconfig->m_in_pin = devm_kzalloc(bus->dev, (mconfig->max_in_queue) *
-						sizeof(*mconfig->m_in_pin),
-						GFP_KERNEL);
-	if (!mconfig->m_in_pin)
-		return -ENOMEM;
-
-	mconfig->m_out_pin = devm_kzalloc(bus->dev, (mconfig->max_out_queue) *
-						sizeof(*mconfig->m_out_pin),
-						GFP_KERNEL);
-	if (!mconfig->m_out_pin)
-		return -ENOMEM;
-
-	skl_fill_module_pin_info(dfw_config->in_pin, mconfig->m_in_pin,
-						dfw_config->is_dynamic_in_pin,
-						mconfig->max_in_queue);
-
-	skl_fill_module_pin_info(dfw_config->out_pin, mconfig->m_out_pin,
-						 dfw_config->is_dynamic_out_pin,
-							mconfig->max_out_queue);
-
-
-	if (mconfig->formats_config.caps_size == 0)
-		goto bind_event;
-
-	mconfig->formats_config.caps = (u32 *)devm_kzalloc(bus->dev,
-			mconfig->formats_config.caps_size, GFP_KERNEL);
-
-	if (mconfig->formats_config.caps == NULL)
-		return -ENOMEM;
-
-	memcpy(mconfig->formats_config.caps, dfw_config->caps.caps,
-						 dfw_config->caps.caps_size);
-	mconfig->formats_config.param_id = dfw_config->caps.param_id;
-	mconfig->formats_config.set_params = dfw_config->caps.set_params;
-
 bind_event:
 	if (tplg_w->event_type == 0) {
 		dev_dbg(bus->dev, "ASoC: No event handler required\n");
@@ -1767,11 +2201,225 @@
 	return 0;
 }
 
+static int skl_tplg_fill_str_mfest_tkn(struct device *dev,
+		struct snd_soc_tplg_vendor_string_elem *str_elem,
+		struct skl_dfw_manifest *minfo)
+{
+	int tkn_count = 0;
+	static int ref_count;
+
+	switch (str_elem->token) {
+	case SKL_TKN_STR_LIB_NAME:
+		if (ref_count > minfo->lib_count - 1) {
+			ref_count = 0;
+			return -EINVAL;
+		}
+
+		strncpy(minfo->lib[ref_count].name, str_elem->string,
+				ARRAY_SIZE(minfo->lib[ref_count].name));
+		ref_count++;
+		tkn_count++;
+		break;
+
+	default:
+		dev_err(dev, "Not a string token %d", str_elem->token);
+		break;
+	}
+
+	return tkn_count;
+}
+
+static int skl_tplg_get_str_tkn(struct device *dev,
+		struct snd_soc_tplg_vendor_array *array,
+		struct skl_dfw_manifest *minfo)
+{
+	int tkn_count = 0, ret;
+	struct snd_soc_tplg_vendor_string_elem *str_elem;
+
+	str_elem = (struct snd_soc_tplg_vendor_string_elem *)array->value;
+	while (tkn_count < array->num_elems) {
+		ret = skl_tplg_fill_str_mfest_tkn(dev, str_elem, minfo);
+		str_elem++;
+
+		if (ret < 0)
+			return ret;
+
+		tkn_count = tkn_count + ret;
+	}
+
+	return tkn_count;
+}
+
+static int skl_tplg_get_int_tkn(struct device *dev,
+		struct snd_soc_tplg_vendor_value_elem *tkn_elem,
+		struct skl_dfw_manifest *minfo)
+{
+	int tkn_count = 0;
+
+	switch (tkn_elem->token) {
+	case SKL_TKN_U32_LIB_COUNT:
+		minfo->lib_count = tkn_elem->value;
+		tkn_count++;
+		break;
+
+	default:
+		dev_err(dev, "Not a manifest token %d", tkn_elem->token);
+		return -EINVAL;
+	}
+
+	return tkn_count;
+}
+
+/*
+ * Fill the manifest structure by parsing the tokens based on the
+ * type.
+ */
+static int skl_tplg_get_manifest_tkn(struct device *dev,
+		char *pvt_data, struct skl_dfw_manifest *minfo,
+		int block_size)
+{
+	int tkn_count = 0, ret;
+	int off = 0, tuple_size = 0;
+	struct snd_soc_tplg_vendor_array *array;
+	struct snd_soc_tplg_vendor_value_elem *tkn_elem;
+
+	if (block_size <= 0)
+		return -EINVAL;
+
+	while (tuple_size < block_size) {
+		array = (struct snd_soc_tplg_vendor_array *)(pvt_data + off);
+		off += array->size;
+		switch (array->type) {
+		case SND_SOC_TPLG_TUPLE_TYPE_STRING:
+			ret = skl_tplg_get_str_tkn(dev, array, minfo);
+
+			if (ret < 0)
+				return ret;
+			tkn_count += ret;
+
+			tuple_size += tkn_count *
+				sizeof(struct snd_soc_tplg_vendor_string_elem);
+			continue;
+
+		case SND_SOC_TPLG_TUPLE_TYPE_UUID:
+			dev_warn(dev, "no uuid tokens for skl tplf manifest");
+			continue;
+
+		default:
+			tkn_elem = array->value;
+			tkn_count = 0;
+			break;
+		}
+
+		while (tkn_count <= array->num_elems - 1) {
+			ret = skl_tplg_get_int_tkn(dev,
+					tkn_elem, minfo);
+			if (ret < 0)
+				return ret;
+
+			tkn_count = tkn_count + ret;
+			tkn_elem++;
+			tuple_size += tkn_count *
+				sizeof(struct snd_soc_tplg_vendor_value_elem);
+			break;
+		}
+		tkn_count = 0;
+	}
+
+	return 0;
+}
+
+/*
+ * Parse manifest private data for tokens. The private data block is
+ * preceded by descriptors for type and size of data block.
+ */
+static int skl_tplg_get_manifest_data(struct snd_soc_tplg_manifest *manifest,
+			struct device *dev, struct skl_dfw_manifest *minfo)
+{
+	struct snd_soc_tplg_vendor_array *array;
+	int num_blocks, block_size = 0, block_type, off = 0;
+	char *data;
+	int ret;
+
+	/* Read the NUM_DATA_BLOCKS descriptor */
+	array = (struct snd_soc_tplg_vendor_array *)manifest->priv.data;
+	ret = skl_tplg_get_desc_blocks(dev, array);
+	if (ret < 0)
+		return ret;
+	num_blocks = ret;
+
+	off += array->size;
+	array = (struct snd_soc_tplg_vendor_array *)
+			(manifest->priv.data + off);
+
+	/* Read the BLOCK_TYPE and BLOCK_SIZE descriptor */
+	while (num_blocks > 0) {
+		ret = skl_tplg_get_desc_blocks(dev, array);
+
+		if (ret < 0)
+			return ret;
+		block_type = ret;
+		off += array->size;
+
+		array = (struct snd_soc_tplg_vendor_array *)
+			(manifest->priv.data + off);
+
+		ret = skl_tplg_get_desc_blocks(dev, array);
+
+		if (ret < 0)
+			return ret;
+		block_size = ret;
+		off += array->size;
+
+		array = (struct snd_soc_tplg_vendor_array *)
+			(manifest->priv.data + off);
+
+		data = (manifest->priv.data + off);
+
+		if (block_type == SKL_TYPE_TUPLE) {
+			ret = skl_tplg_get_manifest_tkn(dev, data, minfo,
+					block_size);
+
+			if (ret < 0)
+				return ret;
+
+			--num_blocks;
+		} else {
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+static int skl_manifest_load(struct snd_soc_component *cmpnt,
+				struct snd_soc_tplg_manifest *manifest)
+{
+	struct skl_dfw_manifest *minfo;
+	struct hdac_ext_bus *ebus = snd_soc_component_get_drvdata(cmpnt);
+	struct hdac_bus *bus = ebus_to_hbus(ebus);
+	struct skl *skl = ebus_to_skl(ebus);
+	int ret = 0;
+
+	minfo = &skl->skl_sst->manifest;
+
+	skl_tplg_get_manifest_data(manifest, bus->dev, minfo);
+
+	if (minfo->lib_count > HDA_MAX_LIB) {
+		dev_err(bus->dev, "Exceeding max Library count. Got:%d\n",
+					minfo->lib_count);
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
 static struct snd_soc_tplg_ops skl_tplg_ops  = {
 	.widget_load = skl_tplg_widget_load,
 	.control_load = skl_tplg_control_load,
 	.bytes_ext_ops = skl_tlv_ops,
 	.bytes_ext_ops_count = ARRAY_SIZE(skl_tlv_ops),
+	.manifest = skl_manifest_load,
 };
 
 /*
diff -uwr linux-4.8-rc4.new/sound/soc/intel/skylake/skl-topology.h linux-4.8-rc4.orig/sound/soc/intel/skylake/skl-topology.h
--- linux-4.8-rc4.new/sound/soc/intel/skylake/skl-topology.h	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/intel/skylake/skl-topology.h	2016-09-04 01:14:31.744286657 +0000
@@ -216,7 +216,7 @@
 struct skl_module_cfg;
 
 struct skl_module_inst_id {
-	u32 module_id;
+	int module_id;
 	u32 instance_id;
 };
 
diff -uwr linux-4.8-rc4.new/sound/soc/intel/skylake/skl-tplg-interface.h linux-4.8-rc4.orig/sound/soc/intel/skylake/skl-tplg-interface.h
--- linux-4.8-rc4.new/sound/soc/intel/skylake/skl-tplg-interface.h	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/intel/skylake/skl-tplg-interface.h	2016-09-04 01:14:51.659563861 +0000
@@ -148,84 +148,34 @@
 	SKL_PARAM_BIND
 };
 
-struct skl_dfw_module_pin {
-	u16 module_id;
-	u16 instance_id;
-} __packed;
-
-struct skl_dfw_module_fmt {
-	u32 channels;
-	u32 freq;
-	u32 bit_depth;
-	u32 valid_bit_depth;
-	u32 ch_cfg;
-	u32 interleaving_style;
-	u32 sample_type;
-	u32 ch_map;
-} __packed;
-
-struct skl_dfw_module_caps {
+struct skl_dfw_algo_data {
 	u32 set_params:2;
 	u32 rsvd:30;
 	u32 param_id;
-	u32 caps_size;
-	u32 caps[HDA_SST_CFG_MAX];
-};
-
-struct skl_dfw_pipe {
-	u8 pipe_id;
-	u8 pipe_priority;
-	u16 conn_type:4;
-	u16 rsvd:4;
-	u16 memory_pages:8;
+	u32 max;
+	char params[0];
 } __packed;
 
-struct skl_dfw_module {
-	u8 uuid[16];
+#define LIB_NAME_LENGTH	128
+#define HDA_MAX_LIB	16
 
-	u16 module_id;
-	u16 instance_id;
-	u32 max_mcps;
-	u32 mem_pages;
-	u32 obs;
-	u32 ibs;
-	u32 vbus_id;
-
-	u32 max_in_queue:8;
-	u32 max_out_queue:8;
-	u32 time_slot:8;
-	u32 core_id:4;
-	u32 rsvd1:4;
-
-	u32 module_type:8;
-	u32 conn_type:4;
-	u32 dev_type:4;
-	u32 hw_conn_type:4;
-	u32 rsvd2:12;
-
-	u32 params_fixup:8;
-	u32 converter:8;
-	u32 input_pin_type:1;
-	u32 output_pin_type:1;
-	u32 is_dynamic_in_pin:1;
-	u32 is_dynamic_out_pin:1;
-	u32 is_loadable:1;
-	u32 rsvd3:11;
-
-	struct skl_dfw_pipe pipe;
-	struct skl_dfw_module_fmt in_fmt[MAX_IN_QUEUE];
-	struct skl_dfw_module_fmt out_fmt[MAX_OUT_QUEUE];
-	struct skl_dfw_module_pin in_pin[MAX_IN_QUEUE];
-	struct skl_dfw_module_pin out_pin[MAX_OUT_QUEUE];
-	struct skl_dfw_module_caps caps;
+struct lib_info {
+	char name[LIB_NAME_LENGTH];
 } __packed;
 
-struct skl_dfw_algo_data {
-	u32 set_params:2;
-	u32 rsvd:30;
-	u32 param_id;
-	u32 max;
-	char params[0];
+struct skl_dfw_manifest {
+	u32 lib_count;
+	struct lib_info lib[HDA_MAX_LIB];
 } __packed;
 
+enum skl_tkn_dir {
+	SKL_DIR_IN,
+	SKL_DIR_OUT
+};
+
+enum skl_tuple_type {
+	SKL_TYPE_TUPLE,
+	SKL_TYPE_DATA
+};
+
 #endif
diff -uwr linux-4.8-rc4.new/sound/soc/mediatek/common/mtk-afe-fe-dai.c linux-4.8-rc4.orig/sound/soc/mediatek/common/mtk-afe-fe-dai.c
--- linux-4.8-rc4.new/sound/soc/mediatek/common/mtk-afe-fe-dai.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/mediatek/common/mtk-afe-fe-dai.c	2016-09-04 01:14:41.231942316 +0000
@@ -23,7 +23,8 @@
 
 #define AFE_BASE_END_OFFSET 8
 
-int mtk_regmap_update_bits(struct regmap *map, int reg, unsigned int mask,
+static int mtk_regmap_update_bits(struct regmap *map, int reg,
+			   unsigned int mask,
 			   unsigned int val)
 {
 	if (reg < 0)
@@ -31,7 +32,7 @@
 	return regmap_update_bits(map, reg, mask, val);
 }
 
-int mtk_regmap_write(struct regmap *map, int reg, unsigned int val)
+static int mtk_regmap_write(struct regmap *map, int reg, unsigned int val)
 {
 	if (reg < 0)
 		return 0;
diff -uwr linux-4.8-rc4.new/sound/soc/omap/mcbsp.c linux-4.8-rc4.orig/sound/soc/omap/mcbsp.c
--- linux-4.8-rc4.new/sound/soc/omap/mcbsp.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/omap/mcbsp.c	2016-09-04 01:14:41.255941445 +0000
@@ -221,7 +221,8 @@
 
 	/* Enable TX/RX sync error interrupts by default */
 	if (mcbsp->irq)
-		MCBSP_WRITE(mcbsp, IRQEN, RSYNCERREN | XSYNCERREN);
+		MCBSP_WRITE(mcbsp, IRQEN, RSYNCERREN | XSYNCERREN |
+			    RUNDFLEN | ROVFLEN | XUNDFLEN | XOVFLEN);
 }
 
 /**
diff -uwr linux-4.8-rc4.new/sound/soc/omap/omap-abe-twl6040.c linux-4.8-rc4.orig/sound/soc/omap/omap-abe-twl6040.c
--- linux-4.8-rc4.new/sound/soc/omap/omap-abe-twl6040.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/omap/omap-abe-twl6040.c	2016-09-04 01:14:53.811485760 +0000
@@ -305,23 +305,14 @@
 
 	snd_soc_card_set_drvdata(card, priv);
 
-	ret = snd_soc_register_card(card);
+	ret = devm_snd_soc_register_card(&pdev->dev, card);
 	if (ret)
-		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n",
+		dev_err(&pdev->dev, "devm_snd_soc_register_card() failed: %d\n",
 			ret);
 
 	return ret;
 }
 
-static int omap_abe_remove(struct platform_device *pdev)
-{
-	struct snd_soc_card *card = platform_get_drvdata(pdev);
-
-	snd_soc_unregister_card(card);
-
-	return 0;
-}
-
 static const struct of_device_id omap_abe_of_match[] = {
 	{.compatible = "ti,abe-twl6040", },
 	{ },
@@ -335,7 +326,6 @@
 		.of_match_table = omap_abe_of_match,
 	},
 	.probe = omap_abe_probe,
-	.remove = omap_abe_remove,
 };
 
 static int __init omap_abe_init(void)
diff -uwr linux-4.8-rc4.new/sound/soc/qcom/lpass.h linux-4.8-rc4.orig/sound/soc/qcom/lpass.h
--- linux-4.8-rc4.new/sound/soc/qcom/lpass.h	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/qcom/lpass.h	2016-09-04 01:14:37.800066871 +0000
@@ -58,6 +58,8 @@
 	/* 8016 specific */
 	struct clk *pcnoc_mport_clk;
 	struct clk *pcnoc_sway_clk;
+
+	void *private_data;
 };
 
 /* Vairant data per each SOC */
diff -uwr linux-4.8-rc4.new/sound/soc/qcom/lpass-platform.c linux-4.8-rc4.orig/sound/soc/qcom/lpass-platform.c
--- linux-4.8-rc4.new/sound/soc/qcom/lpass-platform.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/qcom/lpass-platform.c	2016-09-04 01:14:37.780067597 +0000
@@ -84,9 +84,9 @@
 		struct snd_pcm_hw_params *params)
 {
 	struct snd_soc_pcm_runtime *soc_runtime = substream->private_data;
-	struct lpass_pcm_data *pcm_data = snd_soc_pcm_get_drvdata(soc_runtime);
 	struct lpass_data *drvdata =
 		snd_soc_platform_get_drvdata(soc_runtime->platform);
+	struct lpass_pcm_data *pcm_data = drvdata->private_data;
 	struct lpass_variant *v = drvdata->variant;
 	snd_pcm_format_t format = params_format(params);
 	unsigned int channels = params_channels(params);
@@ -177,9 +177,9 @@
 static int lpass_platform_pcmops_hw_free(struct snd_pcm_substream *substream)
 {
 	struct snd_soc_pcm_runtime *soc_runtime = substream->private_data;
-	struct lpass_pcm_data *pcm_data = snd_soc_pcm_get_drvdata(soc_runtime);
 	struct lpass_data *drvdata =
 		snd_soc_platform_get_drvdata(soc_runtime->platform);
+	struct lpass_pcm_data *pcm_data = drvdata->private_data;
 	struct lpass_variant *v = drvdata->variant;
 	unsigned int reg;
 	int ret;
@@ -201,9 +201,9 @@
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct snd_soc_pcm_runtime *soc_runtime = substream->private_data;
-	struct lpass_pcm_data *pcm_data = snd_soc_pcm_get_drvdata(soc_runtime);
 	struct lpass_data *drvdata =
 		snd_soc_platform_get_drvdata(soc_runtime->platform);
+	struct lpass_pcm_data *pcm_data = drvdata->private_data;
 	struct lpass_variant *v = drvdata->variant;
 	int ret, ch, dir = substream->stream;
 
@@ -255,9 +255,9 @@
 		int cmd)
 {
 	struct snd_soc_pcm_runtime *soc_runtime = substream->private_data;
-	struct lpass_pcm_data *pcm_data = snd_soc_pcm_get_drvdata(soc_runtime);
 	struct lpass_data *drvdata =
 		snd_soc_platform_get_drvdata(soc_runtime->platform);
+	struct lpass_pcm_data *pcm_data = drvdata->private_data;
 	struct lpass_variant *v = drvdata->variant;
 	int ret, ch, dir = substream->stream;
 
@@ -331,9 +331,9 @@
 		struct snd_pcm_substream *substream)
 {
 	struct snd_soc_pcm_runtime *soc_runtime = substream->private_data;
-	struct lpass_pcm_data *pcm_data = snd_soc_pcm_get_drvdata(soc_runtime);
 	struct lpass_data *drvdata =
 			snd_soc_platform_get_drvdata(soc_runtime->platform);
+	struct lpass_pcm_data *pcm_data = drvdata->private_data;
 	struct lpass_variant *v = drvdata->variant;
 	unsigned int base_addr, curr_addr;
 	int ret, ch, dir = substream->stream;
@@ -483,7 +483,7 @@
 		return -ENOMEM;
 
 	data->i2s_port = cpu_dai->driver->id;
-	snd_soc_pcm_set_drvdata(soc_runtime, data);
+	drvdata->private_data = data;
 
 	psubstream = pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream;
 	if (psubstream) {
@@ -570,8 +570,8 @@
 		substream = pcm->streams[i].substream;
 		if (substream) {
 			rt = substream->private_data;
-			data = snd_soc_pcm_get_drvdata(rt);
 			drvdata = snd_soc_platform_get_drvdata(rt->platform);
+			data = drvdata->private_data;
 
 			ch = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 				? data->rdma_ch
diff -uwr linux-4.8-rc4.new/sound/soc/rockchip/Kconfig linux-4.8-rc4.orig/sound/soc/rockchip/Kconfig
--- linux-4.8-rc4.new/sound/soc/rockchip/Kconfig	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/rockchip/Kconfig	2016-09-04 01:14:50.087620913 +0000
@@ -41,3 +41,15 @@
 	help
 	  Say Y or M here if you want to add support for SoC audio on Rockchip
 	  boards using the RT5645/RT5650 codec, such as Veyron.
+
+config SND_SOC_RK3399_GRU_SOUND
+	tristate "ASoC support multiple codecs for Rockchip RK3399 GRU boards"
+	depends on SND_SOC_ROCKCHIP && I2C && GPIOLIB && CLKDEV_LOOKUP
+	select SND_SOC_ROCKCHIP_I2S
+	select SND_SOC_MAX98357A
+	select SND_SOC_RT5514
+	select SND_SOC_DA7219
+	select SND_SOC_RT5514_SPI
+	help
+	  Say Y or M here if you want to add support multiple codecs for SoC
+	  audio on Rockchip RK3399 GRU boards.
diff -uwr linux-4.8-rc4.new/sound/soc/rockchip/Makefile linux-4.8-rc4.orig/sound/soc/rockchip/Makefile
--- linux-4.8-rc4.new/sound/soc/rockchip/Makefile	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/rockchip/Makefile	2016-09-04 01:14:31.912280560 +0000
@@ -7,6 +7,8 @@
 
 snd-soc-rockchip-max98090-objs := rockchip_max98090.o
 snd-soc-rockchip-rt5645-objs := rockchip_rt5645.o
+snd-soc-rk3399-gru-sound-objs := rk3399_gru_sound.o
 
 obj-$(CONFIG_SND_SOC_ROCKCHIP_MAX98090) += snd-soc-rockchip-max98090.o
 obj-$(CONFIG_SND_SOC_ROCKCHIP_RT5645) += snd-soc-rockchip-rt5645.o
+obj-$(CONFIG_SND_SOC_RK3399_GRU_SOUND) += snd-soc-rk3399-gru-sound.o
diff -uwr linux-4.8-rc4.new/sound/soc/samsung/ac97.c linux-4.8-rc4.orig/sound/soc/samsung/ac97.c
--- linux-4.8-rc4.new/sound/soc/samsung/ac97.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/samsung/ac97.c	2016-09-04 01:14:31.972278382 +0000
@@ -38,16 +38,16 @@
 };
 static struct s3c_ac97_info s3c_ac97;
 
-static struct s3c_dma_params s3c_ac97_pcm_out = {
-	.dma_size	= 4,
+static struct snd_dmaengine_dai_dma_data s3c_ac97_pcm_out = {
+	.addr_width	= 4,
 };
 
-static struct s3c_dma_params s3c_ac97_pcm_in = {
-	.dma_size	= 4,
+static struct snd_dmaengine_dai_dma_data s3c_ac97_pcm_in = {
+	.addr_width	= 4,
 };
 
-static struct s3c_dma_params s3c_ac97_mic_in = {
-	.dma_size	= 4,
+static struct snd_dmaengine_dai_dma_data s3c_ac97_mic_in = {
+	.addr_width	= 4,
 };
 
 static void s3c_ac97_activate(struct snd_ac97 *ac97)
@@ -273,14 +273,14 @@
 
 static int s3c_ac97_dai_probe(struct snd_soc_dai *dai)
 {
-	samsung_asoc_init_dma_data(dai, &s3c_ac97_pcm_out, &s3c_ac97_pcm_in);
+	snd_soc_dai_init_dma_data(dai, &s3c_ac97_pcm_out, &s3c_ac97_pcm_in);
 
 	return 0;
 }
 
 static int s3c_ac97_mic_dai_probe(struct snd_soc_dai *dai)
 {
-	samsung_asoc_init_dma_data(dai, NULL, &s3c_ac97_mic_in);
+	snd_soc_dai_init_dma_data(dai, NULL, &s3c_ac97_mic_in);
 
 	return 0;
 }
@@ -346,12 +346,12 @@
 	if (IS_ERR(s3c_ac97.regs))
 		return PTR_ERR(s3c_ac97.regs);
 
-	s3c_ac97_pcm_out.slave = ac97_pdata->dma_playback;
-	s3c_ac97_pcm_out.dma_addr = mem_res->start + S3C_AC97_PCM_DATA;
-	s3c_ac97_pcm_in.slave = ac97_pdata->dma_capture;
-	s3c_ac97_pcm_in.dma_addr = mem_res->start + S3C_AC97_PCM_DATA;
-	s3c_ac97_mic_in.slave = ac97_pdata->dma_capture_mic;
-	s3c_ac97_mic_in.dma_addr = mem_res->start + S3C_AC97_MIC_DATA;
+	s3c_ac97_pcm_out.filter_data = ac97_pdata->dma_playback;
+	s3c_ac97_pcm_out.addr = mem_res->start + S3C_AC97_PCM_DATA;
+	s3c_ac97_pcm_in.filter_data = ac97_pdata->dma_capture;
+	s3c_ac97_pcm_in.addr = mem_res->start + S3C_AC97_PCM_DATA;
+	s3c_ac97_mic_in.filter_data = ac97_pdata->dma_capture_mic;
+	s3c_ac97_mic_in.addr = mem_res->start + S3C_AC97_MIC_DATA;
 
 	init_completion(&s3c_ac97.done);
 	mutex_init(&s3c_ac97.lock);
diff -uwr linux-4.8-rc4.new/sound/soc/samsung/dmaengine.c linux-4.8-rc4.orig/sound/soc/samsung/dmaengine.c
--- linux-4.8-rc4.new/sound/soc/samsung/dmaengine.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/samsung/dmaengine.c	2016-09-04 01:14:31.984277947 +0000
@@ -16,49 +16,18 @@
  */
 
 #include <linux/module.h>
-#include <linux/amba/pl08x.h>
-#include <linux/platform_data/dma-s3c24xx.h>
-
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/dmaengine_pcm.h>
 #include <sound/soc.h>
-#include <sound/soc-dai.h>
 
 #include "dma.h"
 
-void samsung_asoc_init_dma_data(struct snd_soc_dai *dai,
-				struct s3c_dma_params *playback,
-				struct s3c_dma_params *capture)
-{
-	struct snd_dmaengine_dai_dma_data *playback_data = NULL;
-	struct snd_dmaengine_dai_dma_data *capture_data = NULL;
-
-	if (playback) {
-		playback_data = &playback->dma_data;
-		playback_data->filter_data = playback->slave;
-		playback_data->chan_name = playback->ch_name;
-		playback_data->addr = playback->dma_addr;
-		playback_data->addr_width = playback->dma_size;
-	}
-	if (capture) {
-		capture_data = &capture->dma_data;
-		capture_data->filter_data = capture->slave;
-		capture_data->chan_name = capture->ch_name;
-		capture_data->addr = capture->dma_addr;
-		capture_data->addr_width = capture->dma_size;
-	}
-
-	snd_soc_dai_init_dma_data(dai, playback_data, capture_data);
-}
-EXPORT_SYMBOL_GPL(samsung_asoc_init_dma_data);
-
 int samsung_asoc_dma_platform_register(struct device *dev, dma_filter_fn filter,
 				       const char *tx, const char *rx)
 {
 	unsigned int flags = SND_DMAENGINE_PCM_FLAG_COMPAT;
-
 	struct snd_dmaengine_pcm_config *pcm_conf;
 
 	pcm_conf = devm_kzalloc(dev, sizeof(*pcm_conf), GFP_KERNEL);
diff -uwr linux-4.8-rc4.new/sound/soc/samsung/dma.h linux-4.8-rc4.orig/sound/soc/samsung/dma.h
--- linux-4.8-rc4.new/sound/soc/samsung/dma.h	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/samsung/dma.h	2016-09-04 01:14:31.980278091 +0000
@@ -1,6 +1,4 @@
 /*
- *  dma.h --
- *
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
  *  Free Software Foundation;  either version 2 of the  License, or (at your
@@ -9,27 +7,15 @@
  *  ALSA PCM interface for the Samsung SoC
  */
 
-#ifndef _S3C_AUDIO_H
-#define _S3C_AUDIO_H
+#ifndef _SAMSUNG_DMA_H
+#define _SAMSUNG_DMA_H
 
 #include <sound/dmaengine_pcm.h>
-#include <linux/dmaengine.h>
-
-struct s3c_dma_params {
-	void *slave;				/* Channel ID */
-	dma_addr_t dma_addr;
-	int dma_size;			/* Size of the DMA transfer */
-	char *ch_name;
-	struct snd_dmaengine_dai_dma_data dma_data;
-};
 
-void samsung_asoc_init_dma_data(struct snd_soc_dai *dai,
-				struct s3c_dma_params *playback,
-				struct s3c_dma_params *capture);
 /*
  * @tx, @rx arguments can be NULL if the DMA channel names are "tx", "rx",
  * otherwise actual DMA channel names must be passed to this function.
  */
 int samsung_asoc_dma_platform_register(struct device *dev, dma_filter_fn filter,
 				       const char *tx, const char *rx);
-#endif
+#endif /* _SAMSUNG_DMA_H */
diff -uwr linux-4.8-rc4.new/sound/soc/samsung/i2s.c linux-4.8-rc4.orig/sound/soc/samsung/i2s.c
--- linux-4.8-rc4.new/sound/soc/samsung/i2s.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/samsung/i2s.c	2016-09-04 01:14:53.859484018 +0000
@@ -87,9 +87,9 @@
 	/* Driver for this DAI */
 	struct snd_soc_dai_driver i2s_dai_drv;
 	/* DMA parameters */
-	struct s3c_dma_params dma_playback;
-	struct s3c_dma_params dma_capture;
-	struct s3c_dma_params idma_playback;
+	struct snd_dmaengine_dai_dma_data dma_playback;
+	struct snd_dmaengine_dai_dma_data dma_capture;
+	struct snd_dmaengine_dai_dma_data idma_playback;
 	dma_filter_fn filter;
 	u32	quirks;
 	u32	suspend_i2smod;
@@ -692,15 +692,15 @@
 		break;
 	case 2:
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-			i2s->dma_playback.dma_size = 4;
+			i2s->dma_playback.addr_width = 4;
 		else
-			i2s->dma_capture.dma_size = 4;
+			i2s->dma_capture.addr_width = 4;
 		break;
 	case 1:
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-			i2s->dma_playback.dma_size = 2;
+			i2s->dma_playback.addr_width = 2;
 		else
-			i2s->dma_capture.dma_size = 2;
+			i2s->dma_capture.addr_width = 2;
 
 		break;
 	default:
@@ -754,7 +754,7 @@
 	writel(mod, i2s->addr + I2SMOD);
 	spin_unlock_irqrestore(i2s->lock, flags);
 
-	samsung_asoc_init_dma_data(dai, &i2s->dma_playback, &i2s->dma_capture);
+	snd_soc_dai_init_dma_data(dai, &i2s->dma_playback, &i2s->dma_capture);
 
 	i2s->frmclk = params_rate(params);
 
@@ -991,10 +991,10 @@
 	unsigned long flags;
 
 	if (is_secondary(i2s)) { /* If this is probe on the secondary DAI */
-		samsung_asoc_init_dma_data(dai, &other->sec_dai->dma_playback,
+		snd_soc_dai_init_dma_data(dai, &other->sec_dai->dma_playback,
 					   NULL);
 	} else {
-		samsung_asoc_init_dma_data(dai, &i2s->dma_playback,
+		snd_soc_dai_init_dma_data(dai, &i2s->dma_playback,
 					   &i2s->dma_capture);
 
 		if (i2s->quirks & QUIRK_NEED_RSTCLR)
@@ -1002,7 +1002,7 @@
 
 		if (i2s->quirks & QUIRK_SUPPORTS_IDMA)
 			idma_reg_addr_init(i2s->addr,
-					i2s->sec_dai->idma_playback.dma_addr);
+					i2s->sec_dai->idma_playback.addr);
 	}
 
 	/* Reset any constraint on RFS and BFS */
@@ -1262,8 +1262,8 @@
 			return -EINVAL;
 		}
 
-		pri_dai->dma_playback.slave = i2s_pdata->dma_playback;
-		pri_dai->dma_capture.slave = i2s_pdata->dma_capture;
+		pri_dai->dma_playback.filter_data = i2s_pdata->dma_playback;
+		pri_dai->dma_capture.filter_data = i2s_pdata->dma_capture;
 		pri_dai->filter = i2s_pdata->dma_filter;
 
 		if (&i2s_pdata->type)
@@ -1302,12 +1302,12 @@
 		dev_err(&pdev->dev, "failed to enable clock: %d\n", ret);
 		return ret;
 	}
-	pri_dai->dma_playback.dma_addr = regs_base + I2STXD;
-	pri_dai->dma_capture.dma_addr = regs_base + I2SRXD;
-	pri_dai->dma_playback.ch_name = "tx";
-	pri_dai->dma_capture.ch_name = "rx";
-	pri_dai->dma_playback.dma_size = 4;
-	pri_dai->dma_capture.dma_size = 4;
+	pri_dai->dma_playback.addr = regs_base + I2STXD;
+	pri_dai->dma_capture.addr = regs_base + I2SRXD;
+	pri_dai->dma_playback.chan_name = "tx";
+	pri_dai->dma_capture.chan_name = "rx";
+	pri_dai->dma_playback.addr_width = 4;
+	pri_dai->dma_capture.addr_width = 4;
 	pri_dai->quirks = quirks;
 	pri_dai->variant_regs = i2s_dai_data->i2s_variant_regs;
 
@@ -1318,31 +1318,33 @@
 		sec_dai = i2s_alloc_dai(pdev, true);
 		if (!sec_dai) {
 			dev_err(&pdev->dev, "Unable to alloc I2S_sec\n");
-			return -ENOMEM;
+			ret = -ENOMEM;
+			goto err_disable_clk;
 		}
 
 		sec_dai->lock = &pri_dai->spinlock;
 		sec_dai->variant_regs = pri_dai->variant_regs;
-		sec_dai->dma_playback.dma_addr = regs_base + I2STXDS;
-		sec_dai->dma_playback.ch_name = "tx-sec";
+		sec_dai->dma_playback.addr = regs_base + I2STXDS;
+		sec_dai->dma_playback.chan_name = "tx-sec";
 
 		if (!np) {
-			sec_dai->dma_playback.slave = i2s_pdata->dma_play_sec;
+			sec_dai->dma_playback.filter_data = i2s_pdata->dma_play_sec;
 			sec_dai->filter = i2s_pdata->dma_filter;
 		}
 
-		sec_dai->dma_playback.dma_size = 4;
+		sec_dai->dma_playback.addr_width = 4;
 		sec_dai->addr = pri_dai->addr;
 		sec_dai->clk = pri_dai->clk;
 		sec_dai->quirks = quirks;
-		sec_dai->idma_playback.dma_addr = idma_addr;
+		sec_dai->idma_playback.addr = idma_addr;
 		sec_dai->pri_dai = pri_dai;
 		pri_dai->sec_dai = sec_dai;
 	}
 
 	if (i2s_pdata && i2s_pdata->cfg_gpio && i2s_pdata->cfg_gpio(pdev)) {
 		dev_err(&pdev->dev, "Unable to configure gpio\n");
-		return -EINVAL;
+		ret = -EINVAL;
+		goto err_disable_clk;
 	}
 
 	ret = devm_snd_soc_register_component(&pri_dai->pdev->dev,
@@ -1366,6 +1368,8 @@
 err_free_dai:
 	if (sec_dai)
 		i2s_free_sec_dai(sec_dai);
+err_disable_clk:
+	clk_disable_unprepare(pri_dai->clk);
 	return ret;
 }
 
diff -uwr linux-4.8-rc4.new/sound/soc/samsung/idma.c linux-4.8-rc4.orig/sound/soc/samsung/idma.c
--- linux-4.8-rc4.new/sound/soc/samsung/idma.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/samsung/idma.c	2016-09-04 01:14:31.984277947 +0000
@@ -22,7 +22,6 @@
 
 #include "i2s.h"
 #include "idma.h"
-#include "dma.h"
 #include "i2s-regs.h"
 
 #define ST_RUNNING		(1<<0)
diff -uwr linux-4.8-rc4.new/sound/soc/samsung/pcm.c linux-4.8-rc4.orig/sound/soc/samsung/pcm.c
--- linux-4.8-rc4.new/sound/soc/samsung/pcm.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/samsung/pcm.c	2016-09-04 01:14:31.980278091 +0000
@@ -127,25 +127,25 @@
 	struct clk	*pclk;
 	struct clk	*cclk;
 
-	struct s3c_dma_params	*dma_playback;
-	struct s3c_dma_params	*dma_capture;
+	struct snd_dmaengine_dai_dma_data *dma_playback;
+	struct snd_dmaengine_dai_dma_data *dma_capture;
 };
 
-static struct s3c_dma_params s3c_pcm_stereo_out[] = {
+static struct snd_dmaengine_dai_dma_data s3c_pcm_stereo_out[] = {
 	[0] = {
-		.dma_size	= 4,
+		.addr_width	= 4,
 	},
 	[1] = {
-		.dma_size	= 4,
+		.addr_width	= 4,
 	},
 };
 
-static struct s3c_dma_params s3c_pcm_stereo_in[] = {
+static struct snd_dmaengine_dai_dma_data s3c_pcm_stereo_in[] = {
 	[0] = {
-		.dma_size	= 4,
+		.addr_width	= 4,
 	},
 	[1] = {
-		.dma_size	= 4,
+		.addr_width	= 4,
 	},
 };
 
@@ -552,15 +552,13 @@
 	}
 	clk_prepare_enable(pcm->pclk);
 
-	s3c_pcm_stereo_in[pdev->id].dma_addr = mem_res->start
-							+ S3C_PCM_RXFIFO;
-	s3c_pcm_stereo_out[pdev->id].dma_addr = mem_res->start
-							+ S3C_PCM_TXFIFO;
+	s3c_pcm_stereo_in[pdev->id].addr = mem_res->start + S3C_PCM_RXFIFO;
+	s3c_pcm_stereo_out[pdev->id].addr = mem_res->start + S3C_PCM_TXFIFO;
 
 	filter = NULL;
 	if (pcm_pdata) {
-		s3c_pcm_stereo_in[pdev->id].slave = pcm_pdata->dma_capture;
-		s3c_pcm_stereo_out[pdev->id].slave = pcm_pdata->dma_playback;
+		s3c_pcm_stereo_in[pdev->id].filter_data = pcm_pdata->dma_capture;
+		s3c_pcm_stereo_out[pdev->id].filter_data = pcm_pdata->dma_playback;
 		filter = pcm_pdata->dma_filter;
 	}
 
diff -uwr linux-4.8-rc4.new/sound/soc/samsung/s3c2412-i2s.c linux-4.8-rc4.orig/sound/soc/samsung/s3c2412-i2s.c
--- linux-4.8-rc4.new/sound/soc/samsung/s3c2412-i2s.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/samsung/s3c2412-i2s.c	2016-09-04 01:14:31.968278528 +0000
@@ -34,14 +34,14 @@
 
 #include <linux/platform_data/asoc-s3c.h>
 
-static struct s3c_dma_params s3c2412_i2s_pcm_stereo_out = {
-	.ch_name	= "tx",
-	.dma_size	= 4,
+static struct snd_dmaengine_dai_dma_data s3c2412_i2s_pcm_stereo_out = {
+	.chan_name	= "tx",
+	.addr_width	= 4,
 };
 
-static struct s3c_dma_params s3c2412_i2s_pcm_stereo_in = {
-	.ch_name	= "rx",
-	.dma_size	= 4,
+static struct snd_dmaengine_dai_dma_data s3c2412_i2s_pcm_stereo_in = {
+	.chan_name	= "rx",
+	.addr_width	= 4,
 };
 
 static struct s3c_i2sv2_info s3c2412_i2s;
@@ -52,7 +52,7 @@
 
 	pr_debug("Entered %s\n", __func__);
 
-	samsung_asoc_init_dma_data(dai, &s3c2412_i2s_pcm_stereo_out,
+	snd_soc_dai_init_dma_data(dai, &s3c2412_i2s_pcm_stereo_out,
 		&s3c2412_i2s_pcm_stereo_in);
 
 	ret = s3c_i2sv2_probe(dai, &s3c2412_i2s, S3C2410_PA_IIS);
@@ -163,10 +163,10 @@
 	if (IS_ERR(s3c2412_i2s.regs))
 		return PTR_ERR(s3c2412_i2s.regs);
 
-	s3c2412_i2s_pcm_stereo_out.dma_addr = res->start + S3C2412_IISTXD;
-	s3c2412_i2s_pcm_stereo_out.slave = pdata->dma_playback;
-	s3c2412_i2s_pcm_stereo_in.dma_addr = res->start + S3C2412_IISRXD;
-	s3c2412_i2s_pcm_stereo_in.slave = pdata->dma_capture;
+	s3c2412_i2s_pcm_stereo_out.addr = res->start + S3C2412_IISTXD;
+	s3c2412_i2s_pcm_stereo_out.filter_data = pdata->dma_playback;
+	s3c2412_i2s_pcm_stereo_in.addr = res->start + S3C2412_IISRXD;
+	s3c2412_i2s_pcm_stereo_in.filter_data = pdata->dma_capture;
 
 	ret = s3c_i2sv2_register_component(&pdev->dev, -1,
 					   &s3c2412_i2s_component,
diff -uwr linux-4.8-rc4.new/sound/soc/samsung/s3c24xx-i2s.c linux-4.8-rc4.orig/sound/soc/samsung/s3c24xx-i2s.c
--- linux-4.8-rc4.new/sound/soc/samsung/s3c24xx-i2s.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/samsung/s3c24xx-i2s.c	2016-09-04 01:14:31.960278818 +0000
@@ -32,14 +32,14 @@
 
 #include <linux/platform_data/asoc-s3c.h>
 
-static struct s3c_dma_params s3c24xx_i2s_pcm_stereo_out = {
-	.ch_name	= "tx",
-	.dma_size	= 2,
+static struct snd_dmaengine_dai_dma_data s3c24xx_i2s_pcm_stereo_out = {
+	.chan_name	= "tx",
+	.addr_width	= 2,
 };
 
-static struct s3c_dma_params s3c24xx_i2s_pcm_stereo_in = {
-	.ch_name	= "rx",
-	.dma_size	= 2,
+static struct snd_dmaengine_dai_dma_data s3c24xx_i2s_pcm_stereo_in = {
+	.chan_name	= "rx",
+	.addr_width	= 2,
 };
 
 struct s3c24xx_i2s_info {
@@ -360,7 +360,7 @@
 {
 	pr_debug("Entered %s\n", __func__);
 
-	samsung_asoc_init_dma_data(dai, &s3c24xx_i2s_pcm_stereo_out,
+	snd_soc_dai_init_dma_data(dai, &s3c24xx_i2s_pcm_stereo_out,
 		&s3c24xx_i2s_pcm_stereo_in);
 
 	s3c24xx_i2s.iis_clk = devm_clk_get(dai->dev, "iis");
@@ -469,10 +469,10 @@
 	if (IS_ERR(s3c24xx_i2s.regs))
 		return PTR_ERR(s3c24xx_i2s.regs);
 
-	s3c24xx_i2s_pcm_stereo_out.dma_addr = res->start + S3C2410_IISFIFO;
-	s3c24xx_i2s_pcm_stereo_out.slave = pdata->dma_playback;
-	s3c24xx_i2s_pcm_stereo_in.dma_addr = res->start + S3C2410_IISFIFO;
-	s3c24xx_i2s_pcm_stereo_in.slave = pdata->dma_capture;
+	s3c24xx_i2s_pcm_stereo_out.addr = res->start + S3C2410_IISFIFO;
+	s3c24xx_i2s_pcm_stereo_out.filter_data = pdata->dma_playback;
+	s3c24xx_i2s_pcm_stereo_in.addr = res->start + S3C2410_IISFIFO;
+	s3c24xx_i2s_pcm_stereo_in.filter_data = pdata->dma_capture;
 
 	ret = devm_snd_soc_register_component(&pdev->dev,
 			&s3c24xx_i2s_component, &s3c24xx_i2s_dai, 1);
diff -uwr linux-4.8-rc4.new/sound/soc/samsung/s3c24xx_uda134x.c linux-4.8-rc4.orig/sound/soc/samsung/s3c24xx_uda134x.c
--- linux-4.8-rc4.new/sound/soc/samsung/s3c24xx_uda134x.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/samsung/s3c24xx_uda134x.c	2016-09-04 01:14:32.100273736 +0000
@@ -54,8 +54,6 @@
 };
 #endif
 
-static struct platform_device *s3c24xx_uda134x_snd_device;
-
 static int s3c24xx_uda134x_startup(struct snd_pcm_substream *substream)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
@@ -68,7 +66,7 @@
 	mutex_lock(&clk_lock);
 	pr_debug("%s %d\n", __func__, clk_users);
 	if (clk_users == 0) {
-		xtal = clk_get(&s3c24xx_uda134x_snd_device->dev, "xtal");
+		xtal = clk_get(rtd->dev, "xtal");
 		if (IS_ERR(xtal)) {
 			printk(KERN_ERR "%s cannot get xtal\n", __func__);
 			ret = PTR_ERR(xtal);
@@ -102,7 +100,7 @@
 						 SNDRV_PCM_HW_PARAM_RATE,
 						 &hw_constraints_rates);
 		if (ret < 0)
-			printk(KERN_ERR "%s cannot set constraints\n",
+			dev_err(rtd->dev, "%s cannot set constraints\n",
 			       __func__);
 #endif
 	}
@@ -112,7 +110,6 @@
 static void s3c24xx_uda134x_shutdown(struct snd_pcm_substream *substream)
 {
 	mutex_lock(&clk_lock);
-	pr_debug("%s %d\n", __func__, clk_users);
 	clk_users -= 1;
 	if (clk_users == 0) {
 		clk_put(xtal);
@@ -159,18 +156,19 @@
 		clk_source = S3C24XX_CLKSRC_PCLK;
 		div = bi % 33;
 	}
-	pr_debug("%s desired rate %lu, %d\n", __func__, rate, bi);
+
+	dev_dbg(rtd->dev, "%s desired rate %lu, %d\n", __func__, rate, bi);
 
 	clk = (fs_mode == S3C2410_IISMOD_384FS ? 384 : 256) * rate;
-	pr_debug("%s will use: %s %s %d sysclk %d err %ld\n", __func__,
+
+	dev_dbg(rtd->dev, "%s will use: %s %s %d sysclk %d err %ld\n", __func__,
 		 fs_mode == S3C2410_IISMOD_384FS ? "384FS" : "256FS",
 		 clk_source == S3C24XX_CLKSRC_MPLL ? "MPLLin" : "PCLK",
 		 div, clk, err);
 
 	if ((err * 100 / rate) > 5) {
-		printk(KERN_ERR "S3C24XX_UDA134X: effective frequency "
-		       "too different from desired (%ld%%)\n",
-		       err * 100 / rate);
+		dev_err(rtd->dev, "effective frequency too different "
+				  "from desired (%ld%%)\n", err * 100 / rate);
 		return -EINVAL;
 	}
 
@@ -227,115 +225,27 @@
 	.num_links = 1,
 };
 
-static struct s3c24xx_uda134x_platform_data *s3c24xx_uda134x_l3_pins;
-
-static void setdat(int v)
-{
-	gpio_set_value(s3c24xx_uda134x_l3_pins->l3_data, v > 0);
-}
-
-static void setclk(int v)
-{
-	gpio_set_value(s3c24xx_uda134x_l3_pins->l3_clk, v > 0);
-}
-
-static void setmode(int v)
-{
-	gpio_set_value(s3c24xx_uda134x_l3_pins->l3_mode, v > 0);
-}
-
-/* FIXME - This must be codec platform data but in which board file ?? */
-static struct uda134x_platform_data s3c24xx_uda134x = {
-	.l3 = {
-		.setdat = setdat,
-		.setclk = setclk,
-		.setmode = setmode,
-		.data_hold = 1,
-		.data_setup = 1,
-		.clock_high = 1,
-		.mode_hold = 1,
-		.mode = 1,
-		.mode_setup = 1,
-	},
-};
-
-static int s3c24xx_uda134x_setup_pin(int pin, char *fun)
-{
-	if (gpio_request(pin, "s3c24xx_uda134x") < 0) {
-		printk(KERN_ERR "S3C24XX_UDA134X SoC Audio: "
-		       "l3 %s pin already in use", fun);
-		return -EBUSY;
-	}
-	gpio_direction_output(pin, 0);
-	return 0;
-}
-
 static int s3c24xx_uda134x_probe(struct platform_device *pdev)
 {
+	struct snd_soc_card *card = &snd_soc_s3c24xx_uda134x;
 	int ret;
 
-	printk(KERN_INFO "S3C24XX_UDA134X SoC Audio driver\n");
+	platform_set_drvdata(pdev, card);
+	card->dev = &pdev->dev;
 
-	s3c24xx_uda134x_l3_pins = pdev->dev.platform_data;
-	if (s3c24xx_uda134x_l3_pins == NULL) {
-		printk(KERN_ERR "S3C24XX_UDA134X SoC Audio: "
-		       "unable to find platform data\n");
-		return -ENODEV;
-	}
-	s3c24xx_uda134x.power = s3c24xx_uda134x_l3_pins->power;
-	s3c24xx_uda134x.model = s3c24xx_uda134x_l3_pins->model;
-
-	if (s3c24xx_uda134x_setup_pin(s3c24xx_uda134x_l3_pins->l3_data,
-				      "data") < 0)
-		return -EBUSY;
-	if (s3c24xx_uda134x_setup_pin(s3c24xx_uda134x_l3_pins->l3_clk,
-				      "clk") < 0) {
-		gpio_free(s3c24xx_uda134x_l3_pins->l3_data);
-		return -EBUSY;
-	}
-	if (s3c24xx_uda134x_setup_pin(s3c24xx_uda134x_l3_pins->l3_mode,
-				      "mode") < 0) {
-		gpio_free(s3c24xx_uda134x_l3_pins->l3_data);
-		gpio_free(s3c24xx_uda134x_l3_pins->l3_clk);
-		return -EBUSY;
-	}
-
-	s3c24xx_uda134x_snd_device = platform_device_alloc("soc-audio", -1);
-	if (!s3c24xx_uda134x_snd_device) {
-		printk(KERN_ERR "S3C24XX_UDA134X SoC Audio: "
-		       "Unable to register\n");
-		return -ENOMEM;
-	}
-
-	platform_set_drvdata(s3c24xx_uda134x_snd_device,
-			     &snd_soc_s3c24xx_uda134x);
-	platform_device_add_data(s3c24xx_uda134x_snd_device, &s3c24xx_uda134x, sizeof(s3c24xx_uda134x));
-	ret = platform_device_add(s3c24xx_uda134x_snd_device);
-	if (ret) {
-		printk(KERN_ERR "S3C24XX_UDA134X SoC Audio: Unable to add\n");
-		platform_device_put(s3c24xx_uda134x_snd_device);
-	}
+	ret = devm_snd_soc_register_card(&pdev->dev, card);
+	if (ret)
+		dev_err(&pdev->dev, "failed to register card: %d\n", ret);
 
 	return ret;
 }
 
-static int s3c24xx_uda134x_remove(struct platform_device *pdev)
-{
-	platform_device_unregister(s3c24xx_uda134x_snd_device);
-	gpio_free(s3c24xx_uda134x_l3_pins->l3_data);
-	gpio_free(s3c24xx_uda134x_l3_pins->l3_clk);
-	gpio_free(s3c24xx_uda134x_l3_pins->l3_mode);
-	return 0;
-}
-
 static struct platform_driver s3c24xx_uda134x_driver = {
 	.probe  = s3c24xx_uda134x_probe,
-	.remove = s3c24xx_uda134x_remove,
 	.driver = {
 		.name = "s3c24xx_uda134x",
 	},
 };
-
 module_platform_driver(s3c24xx_uda134x_driver);
 
 MODULE_AUTHOR("Zoltan Devai, Christian Pellegrin <chripell@evolware.org>");
diff -uwr linux-4.8-rc4.new/sound/soc/samsung/s3c-i2s-v2.c linux-4.8-rc4.orig/sound/soc/samsung/s3c-i2s-v2.c
--- linux-4.8-rc4.new/sound/soc/samsung/s3c-i2s-v2.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/samsung/s3c-i2s-v2.c	2016-09-04 01:14:32.004277220 +0000
@@ -24,7 +24,6 @@
 
 #include "regs-i2s-v2.h"
 #include "s3c-i2s-v2.h"
-#include "dma.h"
 
 #undef S3C_IIS_V2_SUPPORTED
 
@@ -302,7 +301,7 @@
 				 struct snd_soc_dai *dai)
 {
 	struct s3c_i2sv2_info *i2s = to_info(dai);
-	struct s3c_dma_params *dma_data;
+	struct snd_dmaengine_dai_dma_data *dma_data;
 	u32 iismod;
 
 	pr_debug("Entered %s\n", __func__);
diff -uwr linux-4.8-rc4.new/sound/soc/samsung/s3c-i2s-v2.h linux-4.8-rc4.orig/sound/soc/samsung/s3c-i2s-v2.h
--- linux-4.8-rc4.new/sound/soc/samsung/s3c-i2s-v2.h	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/samsung/s3c-i2s-v2.h	2016-09-04 01:14:31.968278528 +0000
@@ -60,8 +60,8 @@
 
 	unsigned char	 master;
 
-	struct s3c_dma_params	*dma_playback;
-	struct s3c_dma_params	*dma_capture;
+	struct snd_dmaengine_dai_dma_data *dma_playback;
+	struct snd_dmaengine_dai_dma_data *dma_capture;
 
 	u32		 suspend_iismod;
 	u32		 suspend_iiscon;
diff -uwr linux-4.8-rc4.new/sound/soc/samsung/smdk_wm8580pcm.c linux-4.8-rc4.orig/sound/soc/samsung/smdk_wm8580pcm.c
--- linux-4.8-rc4.new/sound/soc/samsung/smdk_wm8580pcm.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/samsung/smdk_wm8580pcm.c	2016-09-04 01:14:32.012276931 +0000
@@ -16,7 +16,6 @@
 #include <asm/mach-types.h>
 
 #include "../codecs/wm8580.h"
-#include "dma.h"
 #include "pcm.h"
 
 /*
diff -uwr linux-4.8-rc4.new/sound/soc/samsung/smdk_wm8994pcm.c linux-4.8-rc4.orig/sound/soc/samsung/smdk_wm8994pcm.c
--- linux-4.8-rc4.new/sound/soc/samsung/smdk_wm8994pcm.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/samsung/smdk_wm8994pcm.c	2016-09-04 01:14:32.024276495 +0000
@@ -15,7 +15,6 @@
 #include <sound/pcm_params.h>
 
 #include "../codecs/wm8994.h"
-#include "dma.h"
 #include "pcm.h"
 
 /*
diff -uwr linux-4.8-rc4.new/sound/soc/samsung/spdif.c linux-4.8-rc4.orig/sound/soc/samsung/spdif.c
--- linux-4.8-rc4.new/sound/soc/samsung/spdif.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/samsung/spdif.c	2016-09-04 01:14:31.976278237 +0000
@@ -90,10 +90,10 @@
 	u32		saved_clkcon;
 	u32		saved_con;
 	u32		saved_cstas;
-	struct s3c_dma_params	*dma_playback;
+	struct snd_dmaengine_dai_dma_data *dma_playback;
 };
 
-static struct s3c_dma_params spdif_stereo_out;
+static struct snd_dmaengine_dai_dma_data spdif_stereo_out;
 static struct samsung_spdif_info spdif_info;
 
 static inline struct samsung_spdif_info *to_info(struct snd_soc_dai *cpu_dai)
@@ -179,7 +179,7 @@
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct samsung_spdif_info *spdif = to_info(rtd->cpu_dai);
 	void __iomem *regs = spdif->regs;
-	struct s3c_dma_params *dma_data;
+	struct snd_dmaengine_dai_dma_data *dma_data;
 	u32 con, clkcon, cstas;
 	unsigned long flags;
 	int i, ratio;
@@ -425,11 +425,11 @@
 		goto err4;
 	}
 
-	spdif_stereo_out.dma_size = 2;
-	spdif_stereo_out.dma_addr = mem_res->start + DATA_OUTBUF;
+	spdif_stereo_out.addr_width = 2;
+	spdif_stereo_out.addr = mem_res->start + DATA_OUTBUF;
 	filter = NULL;
 	if (spdif_pdata) {
-		spdif_stereo_out.slave = spdif_pdata->dma_playback;
+		spdif_stereo_out.filter_data = spdif_pdata->dma_playback;
 		filter = spdif_pdata->dma_filter;
 	}
 
diff -uwr linux-4.8-rc4.new/sound/soc/sh/Kconfig linux-4.8-rc4.orig/sound/soc/sh/Kconfig
--- linux-4.8-rc4.new/sound/soc/sh/Kconfig	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/sh/Kconfig	2016-09-04 01:14:53.851484308 +0000
@@ -42,12 +42,6 @@
 	help
 	  This option enables R-Car SRU/SCU/SSIU/SSI sound support
 
-config SND_SOC_RSRC_CARD
-	tristate "Renesas Sampling Rate Convert Sound Card"
-	select SND_SIMPLE_CARD_UTILS
-	help
-	  This option enables simple sound if you need sampling rate convert
-
 ##
 ## Boards
 ##
diff -uwr linux-4.8-rc4.new/sound/soc/sh/rcar/core.c linux-4.8-rc4.orig/sound/soc/sh/rcar/core.c
--- linux-4.8-rc4.new/sound/soc/sh/rcar/core.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/sh/rcar/core.c	2016-09-04 01:14:41.235942171 +0000
@@ -110,6 +110,7 @@
 /*
  *	rsnd_mod functions
  */
+#ifdef DEBUG
 void rsnd_mod_make_sure(struct rsnd_mod *mod, enum rsnd_mod_type type)
 {
 	if (mod->type != type) {
@@ -120,6 +121,7 @@
 			 rsnd_mod_name(mod), rsnd_mod_id(mod));
 	}
 }
+#endif
 
 char *rsnd_mod_name(struct rsnd_mod *mod)
 {
diff -uwr linux-4.8-rc4.new/sound/soc/sh/rcar/Makefile linux-4.8-rc4.orig/sound/soc/sh/rcar/Makefile
--- linux-4.8-rc4.new/sound/soc/sh/rcar/Makefile	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/sh/rcar/Makefile	2016-09-04 01:14:53.851484308 +0000
@@ -1,5 +1,2 @@
 snd-soc-rcar-objs	:= core.o gen.o dma.o adg.o ssi.o ssiu.o src.o ctu.o mix.o dvc.o cmd.o
 obj-$(CONFIG_SND_SOC_RCAR)	+= snd-soc-rcar.o
-
-snd-soc-rsrc-card-objs	:= rsrc-card.o
-obj-$(CONFIG_SND_SOC_RSRC_CARD)	+= snd-soc-rsrc-card.o
diff -uwr linux-4.8-rc4.new/sound/soc/sh/rcar/ssi.c linux-4.8-rc4.orig/sound/soc/sh/rcar/ssi.c
--- linux-4.8-rc4.new/sound/soc/sh/rcar/ssi.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/sh/rcar/ssi.c	2016-09-04 01:14:31.872282011 +0000
@@ -928,7 +928,7 @@
 		}
 
 		ops = &rsnd_ssi_non_ops;
-		if (of_get_property(np, "pio-transfer", NULL))
+		if (of_property_read_bool(np, "pio-transfer"))
 			ops = &rsnd_ssi_pio_ops;
 		else
 			ops = &rsnd_ssi_dma_ops;
diff -uwr linux-4.8-rc4.new/sound/soc/soc-core.c linux-4.8-rc4.orig/sound/soc/soc-core.c
--- linux-4.8-rc4.new/sound/soc/soc-core.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/soc-core.c	2016-09-04 01:14:32.148271994 +0000
@@ -3332,19 +3332,6 @@
 	if (ret)
 		goto err_free;
 
-	if (codec_drv->controls) {
-		codec->component.controls = codec_drv->controls;
-		codec->component.num_controls = codec_drv->num_controls;
-	}
-	if (codec_drv->dapm_widgets) {
-		codec->component.dapm_widgets = codec_drv->dapm_widgets;
-		codec->component.num_dapm_widgets = codec_drv->num_dapm_widgets;
-	}
-	if (codec_drv->dapm_routes) {
-		codec->component.dapm_routes = codec_drv->dapm_routes;
-		codec->component.num_dapm_routes = codec_drv->num_dapm_routes;
-	}
-
 	if (codec_drv->probe)
 		codec->component.probe = snd_soc_codec_drv_probe;
 	if (codec_drv->remove)
@@ -3732,7 +3719,7 @@
 	 * SND_SOC_DAIFMT_CLOCK_MASK area
 	 */
 	snprintf(prop, sizeof(prop), "%scontinuous-clock", prefix);
-	if (of_get_property(np, prop, NULL))
+	if (of_property_read_bool(np, prop))
 		format |= SND_SOC_DAIFMT_CONT;
 	else
 		format |= SND_SOC_DAIFMT_GATED;
diff -uwr linux-4.8-rc4.new/sound/soc/soc-dapm.c linux-4.8-rc4.orig/sound/soc/soc-dapm.c
--- linux-4.8-rc4.new/sound/soc/soc-dapm.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/soc-dapm.c	2016-09-04 01:14:45.231797147 +0000
@@ -1169,7 +1169,7 @@
  * @custom_stop_condition: (optional) a function meant to stop the widget graph
  *                         walk based on custom logic.
  *
- * Queries DAPM graph as to whether an valid audio stream path exists for
+ * Queries DAPM graph as to whether a valid audio stream path exists for
  * the initial stream specified by name. This takes into account
  * current mixer and mux kcontrol settings. Creates list of valid widgets.
  *
@@ -1294,8 +1294,7 @@
 	return w->new_power;
 }
 
-/* Generic check to see if a widget should be powered.
- */
+/* Generic check to see if a widget should be powered. */
 static int dapm_generic_check_power(struct snd_soc_dapm_widget *w)
 {
 	int in, out;
@@ -1646,7 +1645,7 @@
 	struct snd_soc_dapm_context *d = data;
 	int ret;
 
-	/* If we're off and we're not supposed to be go into STANDBY */
+	/* If we're off and we're not supposed to go into STANDBY */
 	if (d->bias_level == SND_SOC_BIAS_OFF &&
 	    d->target_bias_level != SND_SOC_BIAS_OFF) {
 		if (d->dev)
@@ -1798,7 +1797,7 @@
  * A complete path is a route that has valid endpoints i.e.:-
  *
  *  o DAC to output pin.
- *  o Input Pin to ADC.
+ *  o Input pin to ADC.
  *  o Input pin to Output pin (bypass, sidetone)
  *  o DAC to ADC (loopback).
  */
@@ -2114,7 +2113,7 @@
  * soc_dapm_connect_path() - Connects or disconnects a path
  * @path: The path to update
  * @connect: The new connect state of the path. True if the path is connected,
- *  false if it is disconneted.
+ *  false if it is disconnected.
  * @reason: The reason why the path changed (for debugging only)
  */
 static void soc_dapm_connect_path(struct snd_soc_dapm_path *path,
@@ -2233,7 +2232,7 @@
 		if (w->dapm != dapm)
 			continue;
 
-		/* only display widgets that burnm power */
+		/* only display widgets that burn power */
 		switch (w->id) {
 		case snd_soc_dapm_hp:
 		case snd_soc_dapm_mic:
@@ -2461,7 +2460,7 @@
 
 	switch (w->id) {
 	case snd_soc_dapm_input:
-		/* On a fully routed card a input is never a source */
+		/* On a fully routed card an input is never a source */
 		if (w->dapm->card->fully_routed)
 			return;
 		ep = SND_SOC_DAPM_EP_SOURCE;
@@ -3445,7 +3444,7 @@
 		w->endpoints[dir] = -1;
 	}
 
-	/* machine layer set ups unconnected pins and insertions */
+	/* machine layer sets up unconnected pins and insertions */
 	w->connected = 1;
 	return w;
 }
diff -uwr linux-4.8-rc4.new/sound/soc/soc-topology.c linux-4.8-rc4.orig/sound/soc/soc-topology.c
--- linux-4.8-rc4.new/sound/soc/soc-topology.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/soc-topology.c	2016-09-04 01:14:51.671563426 +0000
@@ -48,9 +48,10 @@
 #define SOC_TPLG_PASS_PCM_DAI		4
 #define SOC_TPLG_PASS_GRAPH		5
 #define SOC_TPLG_PASS_PINS		6
+#define SOC_TPLG_PASS_BE_DAI		7
 
 #define SOC_TPLG_PASS_START	SOC_TPLG_PASS_MANIFEST
-#define SOC_TPLG_PASS_END	SOC_TPLG_PASS_PINS
+#define SOC_TPLG_PASS_END	SOC_TPLG_PASS_BE_DAI
 
 struct soc_tplg {
 	const struct firmware *fw;
@@ -1475,6 +1476,7 @@
 	if (widget == NULL) {
 		dev_err(tplg->dev, "ASoC: failed to create widget %s controls\n",
 			w->name);
+		ret = -ENOMEM;
 		goto hdr_err;
 	}
 
@@ -1554,6 +1556,25 @@
 	stream->rate_min = caps->rate_min;
 	stream->rate_max = caps->rate_max;
 	stream->formats = caps->formats;
+	stream->sig_bits = caps->sig_bits;
+}
+
+static void set_dai_flags(struct snd_soc_dai_driver *dai_drv,
+			  unsigned int flag_mask, unsigned int flags)
+{
+	if (flag_mask & SND_SOC_TPLG_DAI_FLGBIT_SYMMETRIC_RATES)
+		dai_drv->symmetric_rates =
+			flags & SND_SOC_TPLG_DAI_FLGBIT_SYMMETRIC_RATES ? 1 : 0;
+
+	if (flag_mask & SND_SOC_TPLG_DAI_FLGBIT_SYMMETRIC_CHANNELS)
+		dai_drv->symmetric_channels =
+			flags & SND_SOC_TPLG_DAI_FLGBIT_SYMMETRIC_CHANNELS ?
+			1 : 0;
+
+	if (flag_mask & SND_SOC_TPLG_DAI_FLGBIT_SYMMETRIC_SAMPLEBITS)
+		dai_drv->symmetric_samplebits =
+			flags & SND_SOC_TPLG_DAI_FLGBIT_SYMMETRIC_SAMPLEBITS ?
+			1 : 0;
 }
 
 static int soc_tplg_dai_create(struct soc_tplg *tplg,
@@ -1690,6 +1711,94 @@
 	return 0;
 }
 
+/* *
+ * soc_tplg_be_dai_config - Find and configure an existing BE DAI.
+ * @tplg: topology context
+ * @be: topology BE DAI configs.
+ *
+ * The BE dai should already be registered by the platform driver. The
+ * platform driver should specify the BE DAI name and ID for matching.
+ */
+static int soc_tplg_be_dai_config(struct soc_tplg *tplg,
+				  struct snd_soc_tplg_be_dai *be)
+{
+	struct snd_soc_dai_link_component dai_component = {0};
+	struct snd_soc_dai *dai;
+	struct snd_soc_dai_driver *dai_drv;
+	struct snd_soc_pcm_stream *stream;
+	struct snd_soc_tplg_stream_caps *caps;
+	int ret;
+
+	dai_component.dai_name = be->dai_name;
+	dai = snd_soc_find_dai(&dai_component);
+	if (!dai) {
+		dev_err(tplg->dev, "ASoC: BE DAI %s not registered\n",
+			be->dai_name);
+		return -EINVAL;
+	}
+
+	if (be->dai_id != dai->id) {
+		dev_err(tplg->dev, "ASoC: BE DAI %s id mismatch\n",
+			be->dai_name);
+		return -EINVAL;
+	}
+
+	dai_drv = dai->driver;
+	if (!dai_drv)
+		return -EINVAL;
+
+	if (be->playback) {
+		stream = &dai_drv->playback;
+		caps = &be->caps[SND_SOC_TPLG_STREAM_PLAYBACK];
+		set_stream_info(stream, caps);
+	}
+
+	if (be->capture) {
+		stream = &dai_drv->capture;
+		caps = &be->caps[SND_SOC_TPLG_STREAM_CAPTURE];
+		set_stream_info(stream, caps);
+	}
+
+	if (be->flag_mask)
+		set_dai_flags(dai_drv, be->flag_mask, be->flags);
+
+	/* pass control to component driver for optional further init */
+	ret = soc_tplg_dai_load(tplg, dai_drv);
+	if (ret < 0) {
+		dev_err(tplg->comp->dev, "ASoC: DAI loading failed\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int soc_tplg_be_dai_elems_load(struct soc_tplg *tplg,
+				      struct snd_soc_tplg_hdr *hdr)
+{
+	struct snd_soc_tplg_be_dai *be;
+	int count = hdr->count;
+	int i;
+
+	if (tplg->pass != SOC_TPLG_PASS_BE_DAI)
+		return 0;
+
+	/* config the existing BE DAIs */
+	for (i = 0; i < count; i++) {
+		be = (struct snd_soc_tplg_be_dai *)tplg->pos;
+		if (be->size != sizeof(*be)) {
+			dev_err(tplg->dev, "ASoC: invalid BE DAI size\n");
+			return -EINVAL;
+		}
+
+		soc_tplg_be_dai_config(tplg, be);
+		tplg->pos += (sizeof(*be) + be->priv.size);
+	}
+
+	dev_dbg(tplg->dev, "ASoC: Configure %d BE DAIs\n", count);
+	return 0;
+}
+
+
 static int soc_tplg_manifest_load(struct soc_tplg *tplg,
 	struct snd_soc_tplg_hdr *hdr)
 {
@@ -1793,6 +1902,8 @@
 		return soc_tplg_dapm_widget_elems_load(tplg, hdr);
 	case SND_SOC_TPLG_TYPE_PCM:
 		return soc_tplg_pcm_elems_load(tplg, hdr);
+	case SND_SOC_TPLG_TYPE_BE_DAI:
+		return soc_tplg_be_dai_elems_load(tplg, hdr);
 	case SND_SOC_TPLG_TYPE_MANIFEST:
 		return soc_tplg_manifest_load(tplg, hdr);
 	default:
diff -uwr linux-4.8-rc4.new/sound/soc/sunxi/Kconfig linux-4.8-rc4.orig/sound/soc/sunxi/Kconfig
--- linux-4.8-rc4.new/sound/soc/sunxi/Kconfig	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/sunxi/Kconfig	2016-09-04 01:14:53.819485470 +0000
@@ -1,4 +1,5 @@
 menu "Allwinner SoC Audio support"
+	depends on ARCH_SUNXI || COMPILE_TEST
 
 config SND_SUN4I_CODEC
 	tristate "Allwinner A10 Codec Support"
diff -uwr linux-4.8-rc4.new/sound/soc/sunxi/sun4i-codec.c linux-4.8-rc4.orig/sound/soc/sunxi/sun4i-codec.c
--- linux-4.8-rc4.new/sound/soc/sunxi/sun4i-codec.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/sunxi/sun4i-codec.c	2016-09-04 01:14:32.128272721 +0000
@@ -628,12 +628,14 @@
 };
 
 static struct snd_soc_codec_driver sun4i_codec_codec = {
+	.component_driver = {
 	.controls		= sun4i_codec_widgets,
 	.num_controls		= ARRAY_SIZE(sun4i_codec_widgets),
 	.dapm_widgets		= sun4i_codec_codec_dapm_widgets,
 	.num_dapm_widgets	= ARRAY_SIZE(sun4i_codec_codec_dapm_widgets),
 	.dapm_routes		= sun4i_codec_codec_dapm_routes,
 	.num_dapm_routes	= ARRAY_SIZE(sun4i_codec_codec_dapm_routes),
+	},
 };
 
 static const struct snd_soc_component_driver sun4i_codec_component = {
diff -uwr linux-4.8-rc4.new/sound/soc/sunxi/sun4i-spdif.c linux-4.8-rc4.orig/sound/soc/sunxi/sun4i-spdif.c
--- linux-4.8-rc4.new/sound/soc/sunxi/sun4i-spdif.c	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/sunxi/sun4i-spdif.c	2016-09-04 01:14:41.263941155 +0000
@@ -29,6 +29,7 @@
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/pm_runtime.h>
+#include <linux/reset.h>
 #include <sound/dmaengine_pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/soc.h>
@@ -162,6 +163,7 @@
 	struct platform_device *pdev;
 	struct clk *spdif_clk;
 	struct clk *apb_clk;
+	struct reset_control *rst;
 	struct snd_soc_dai_driver cpu_dai_drv;
 	struct regmap *regmap;
 	struct snd_dmaengine_dai_dma_data dma_params_tx;
@@ -411,6 +413,7 @@
 
 static const struct of_device_id sun4i_spdif_of_match[] = {
 	{ .compatible = "allwinner,sun4i-a10-spdif", },
+	{ .compatible = "allwinner,sun6i-a31-spdif", },
 	{ /* sentinel */ }
 };
 MODULE_DEVICE_TABLE(of, sun4i_spdif_of_match);
@@ -482,11 +485,23 @@
 	}
 
 	host->dma_params_tx.addr = res->start + SUN4I_SPDIF_TXFIFO;
-	host->dma_params_tx.maxburst = 4;
+	host->dma_params_tx.maxburst = 8;
 	host->dma_params_tx.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
 
 	platform_set_drvdata(pdev, host);
 
+	if (of_device_is_compatible(pdev->dev.of_node,
+				    "allwinner,sun6i-a31-spdif")) {
+		host->rst = devm_reset_control_get_optional(&pdev->dev, NULL);
+		if (IS_ERR(host->rst) && PTR_ERR(host->rst) == -EPROBE_DEFER) {
+			ret = -EPROBE_DEFER;
+			dev_err(&pdev->dev, "Failed to get reset: %d\n", ret);
+			goto err_disable_apb_clk;
+		}
+		if (!IS_ERR(host->rst))
+			reset_control_deassert(host->rst);
+	}
+
 	ret = devm_snd_soc_register_component(&pdev->dev,
 				&sun4i_spdif_component, &sun4i_spdif_dai, 1);
 	if (ret)
diff -uwr linux-4.8-rc4.new/sound/soc/tegra/Kconfig linux-4.8-rc4.orig/sound/soc/tegra/Kconfig
--- linux-4.8-rc4.new/sound/soc/tegra/Kconfig	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/tegra/Kconfig	2016-09-04 01:14:42.491896588 +0000
@@ -138,3 +138,14 @@
 	help
 	  Say Y or M here if you want to add support for SoC audio on Tegra
 	  boards using the RT5677 codec, such as Ryu.
+
+config SND_SOC_TEGRA_SGTL5000
+	tristate "SoC Audio support for Tegra boards using a SGTL5000 codec"
+	depends on SND_SOC_TEGRA && I2C && GPIOLIB
+	select SND_SOC_TEGRA20_I2S if ARCH_TEGRA_2x_SOC
+	select SND_SOC_TEGRA30_I2S if ARCH_TEGRA_3x_SOC
+	select SND_SOC_SGTL5000
+	help
+	  Say Y or M here if you want to add support for SoC audio on Tegra
+	  boards using the SGTL5000 codec, such as Apalis T30, Apalis TK1 or
+	  Colibri T30.
diff -uwr linux-4.8-rc4.new/sound/soc/tegra/Makefile linux-4.8-rc4.orig/sound/soc/tegra/Makefile
--- linux-4.8-rc4.new/sound/soc/tegra/Makefile	2016-08-28 22:04:33.000000000 +0000
+++ linux-4.8-rc4.orig/sound/soc/tegra/Makefile	2016-09-04 01:14:42.491896588 +0000
@@ -26,6 +26,7 @@
 snd-soc-tegra-trimslice-objs := trimslice.o
 snd-soc-tegra-alc5632-objs := tegra_alc5632.o
 snd-soc-tegra-max98090-objs := tegra_max98090.o
+snd-soc-tegra-sgtl5000-objs := tegra_sgtl5000.o
 
 obj-$(CONFIG_SND_SOC_TEGRA_RT5640) += snd-soc-tegra-rt5640.o
 obj-$(CONFIG_SND_SOC_TEGRA_RT5677) += snd-soc-tegra-rt5677.o
@@ -35,3 +36,4 @@
 obj-$(CONFIG_SND_SOC_TEGRA_TRIMSLICE) += snd-soc-tegra-trimslice.o
 obj-$(CONFIG_SND_SOC_TEGRA_ALC5632) += snd-soc-tegra-alc5632.o
 obj-$(CONFIG_SND_SOC_TEGRA_MAX98090) += snd-soc-tegra-max98090.o
+obj-$(CONFIG_SND_SOC_TEGRA_SGTL5000) += snd-soc-tegra-sgtl5000.o
\ No newline at end of file
